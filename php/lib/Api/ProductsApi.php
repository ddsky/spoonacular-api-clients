<?php
/**
 * ProductsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.7.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ProductsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'autocompleteProductSearch' => [
            'application/json',
        ],
        'classifyGroceryProduct' => [
            'application/json',
        ],
        'classifyGroceryProductBulk' => [
            'application/json',
        ],
        'getComparableProducts' => [
            'application/json',
        ],
        'getProductInformation' => [
            'application/json',
        ],
        'productNutritionByIDImage' => [
            'application/json',
        ],
        'productNutritionLabelImage' => [
            'application/json',
        ],
        'productNutritionLabelWidget' => [
            'application/json',
        ],
        'searchGroceryProducts' => [
            'application/json',
        ],
        'searchGroceryProductsByUPC' => [
            'application/json',
        ],
        'visualizeProductNutritionByID' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation autocompleteProductSearch
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  int $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteProductSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AutocompleteProductSearch200Response
     */
    public function autocompleteProductSearch($query, $number = null, string $contentType = self::contentTypes['autocompleteProductSearch'][0])
    {
        list($response) = $this->autocompleteProductSearchWithHttpInfo($query, $number, $contentType);
        return $response;
    }

    /**
     * Operation autocompleteProductSearchWithHttpInfo
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  int $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteProductSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AutocompleteProductSearch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteProductSearchWithHttpInfo($query, $number = null, string $contentType = self::contentTypes['autocompleteProductSearch'][0])
    {
        $request = $this->autocompleteProductSearchRequest($query, $number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AutocompleteProductSearch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AutocompleteProductSearch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AutocompleteProductSearch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AutocompleteProductSearch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AutocompleteProductSearch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteProductSearchAsync
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  int $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteProductSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteProductSearchAsync($query, $number = null, string $contentType = self::contentTypes['autocompleteProductSearch'][0])
    {
        return $this->autocompleteProductSearchAsyncWithHttpInfo($query, $number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteProductSearchAsyncWithHttpInfo
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  int $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteProductSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteProductSearchAsyncWithHttpInfo($query, $number = null, string $contentType = self::contentTypes['autocompleteProductSearch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AutocompleteProductSearch200Response';
        $request = $this->autocompleteProductSearchRequest($query, $number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteProductSearch'
     *
     * @param  string $query The (partial) search query. (required)
     * @param  int $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteProductSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autocompleteProductSearchRequest($query, $number = null, string $contentType = self::contentTypes['autocompleteProductSearch'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteProductSearch'
            );
        }

        if ($number !== null && $number > 25) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling ProductsApi.autocompleteProductSearch, must be smaller than or equal to 25.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling ProductsApi.autocompleteProductSearch, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/food/products/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyGroceryProduct
     *
     * Classify Grocery Product
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductRequest $classify_grocery_product_request classify_grocery_product_request (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProduct'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClassifyGroceryProduct200Response
     */
    public function classifyGroceryProduct($classify_grocery_product_request, $locale = null, string $contentType = self::contentTypes['classifyGroceryProduct'][0])
    {
        list($response) = $this->classifyGroceryProductWithHttpInfo($classify_grocery_product_request, $locale, $contentType);
        return $response;
    }

    /**
     * Operation classifyGroceryProductWithHttpInfo
     *
     * Classify Grocery Product
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductRequest $classify_grocery_product_request (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProduct'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClassifyGroceryProduct200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyGroceryProductWithHttpInfo($classify_grocery_product_request, $locale = null, string $contentType = self::contentTypes['classifyGroceryProduct'][0])
    {
        $request = $this->classifyGroceryProductRequest($classify_grocery_product_request, $locale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ClassifyGroceryProduct200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClassifyGroceryProduct200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClassifyGroceryProduct200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ClassifyGroceryProduct200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClassifyGroceryProduct200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyGroceryProductAsync
     *
     * Classify Grocery Product
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductRequest $classify_grocery_product_request (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductAsync($classify_grocery_product_request, $locale = null, string $contentType = self::contentTypes['classifyGroceryProduct'][0])
    {
        return $this->classifyGroceryProductAsyncWithHttpInfo($classify_grocery_product_request, $locale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyGroceryProductAsyncWithHttpInfo
     *
     * Classify Grocery Product
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductRequest $classify_grocery_product_request (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductAsyncWithHttpInfo($classify_grocery_product_request, $locale = null, string $contentType = self::contentTypes['classifyGroceryProduct'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClassifyGroceryProduct200Response';
        $request = $this->classifyGroceryProductRequest($classify_grocery_product_request, $locale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyGroceryProduct'
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductRequest $classify_grocery_product_request (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function classifyGroceryProductRequest($classify_grocery_product_request, $locale = null, string $contentType = self::contentTypes['classifyGroceryProduct'][0])
    {

        // verify the required parameter 'classify_grocery_product_request' is set
        if ($classify_grocery_product_request === null || (is_array($classify_grocery_product_request) && count($classify_grocery_product_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classify_grocery_product_request when calling classifyGroceryProduct'
            );
        }



        $resourcePath = '/food/products/classify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locale,
            'locale', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($classify_grocery_product_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($classify_grocery_product_request));
            } else {
                $httpBody = $classify_grocery_product_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyGroceryProductBulk
     *
     * Classify Grocery Product Bulk
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductBulkRequestInner[] $classify_grocery_product_bulk_request_inner classify_grocery_product_bulk_request_inner (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProductBulk'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[]
     */
    public function classifyGroceryProductBulk($classify_grocery_product_bulk_request_inner, $locale = null, string $contentType = self::contentTypes['classifyGroceryProductBulk'][0])
    {
        list($response) = $this->classifyGroceryProductBulkWithHttpInfo($classify_grocery_product_bulk_request_inner, $locale, $contentType);
        return $response;
    }

    /**
     * Operation classifyGroceryProductBulkWithHttpInfo
     *
     * Classify Grocery Product Bulk
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductBulkRequestInner[] $classify_grocery_product_bulk_request_inner (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProductBulk'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyGroceryProductBulkWithHttpInfo($classify_grocery_product_bulk_request_inner, $locale = null, string $contentType = self::contentTypes['classifyGroceryProductBulk'][0])
    {
        $request = $this->classifyGroceryProductBulkRequest($classify_grocery_product_bulk_request_inner, $locale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyGroceryProductBulkAsync
     *
     * Classify Grocery Product Bulk
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductBulkRequestInner[] $classify_grocery_product_bulk_request_inner (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProductBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductBulkAsync($classify_grocery_product_bulk_request_inner, $locale = null, string $contentType = self::contentTypes['classifyGroceryProductBulk'][0])
    {
        return $this->classifyGroceryProductBulkAsyncWithHttpInfo($classify_grocery_product_bulk_request_inner, $locale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyGroceryProductBulkAsyncWithHttpInfo
     *
     * Classify Grocery Product Bulk
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductBulkRequestInner[] $classify_grocery_product_bulk_request_inner (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProductBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductBulkAsyncWithHttpInfo($classify_grocery_product_bulk_request_inner, $locale = null, string $contentType = self::contentTypes['classifyGroceryProductBulk'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClassifyGroceryProductBulk200ResponseInner[]';
        $request = $this->classifyGroceryProductBulkRequest($classify_grocery_product_bulk_request_inner, $locale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyGroceryProductBulk'
     *
     * @param  \OpenAPI\Client\Model\ClassifyGroceryProductBulkRequestInner[] $classify_grocery_product_bulk_request_inner (required)
     * @param  string $locale The display name of the returned category, supported is en_US (for American English) and en_GB (for British English). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyGroceryProductBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function classifyGroceryProductBulkRequest($classify_grocery_product_bulk_request_inner, $locale = null, string $contentType = self::contentTypes['classifyGroceryProductBulk'][0])
    {

        // verify the required parameter 'classify_grocery_product_bulk_request_inner' is set
        if ($classify_grocery_product_bulk_request_inner === null || (is_array($classify_grocery_product_bulk_request_inner) && count($classify_grocery_product_bulk_request_inner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $classify_grocery_product_bulk_request_inner when calling classifyGroceryProductBulk'
            );
        }
        if (count($classify_grocery_product_bulk_request_inner) < 0) {
            throw new \InvalidArgumentException('invalid value for "$classify_grocery_product_bulk_request_inner" when calling ProductsApi.classifyGroceryProductBulk, number of items must be greater than or equal to 0.');
        }
        


        $resourcePath = '/food/products/classifyBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locale,
            'locale', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($classify_grocery_product_bulk_request_inner)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($classify_grocery_product_bulk_request_inner));
            } else {
                $httpBody = $classify_grocery_product_bulk_request_inner;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getComparableProducts
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComparableProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetComparableProducts200Response
     */
    public function getComparableProducts($upc, string $contentType = self::contentTypes['getComparableProducts'][0])
    {
        list($response) = $this->getComparableProductsWithHttpInfo($upc, $contentType);
        return $response;
    }

    /**
     * Operation getComparableProductsWithHttpInfo
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComparableProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetComparableProducts200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getComparableProductsWithHttpInfo($upc, string $contentType = self::contentTypes['getComparableProducts'][0])
    {
        $request = $this->getComparableProductsRequest($upc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetComparableProducts200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetComparableProducts200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetComparableProducts200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetComparableProducts200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetComparableProducts200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getComparableProductsAsync
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComparableProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getComparableProductsAsync($upc, string $contentType = self::contentTypes['getComparableProducts'][0])
    {
        return $this->getComparableProductsAsyncWithHttpInfo($upc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getComparableProductsAsyncWithHttpInfo
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComparableProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getComparableProductsAsyncWithHttpInfo($upc, string $contentType = self::contentTypes['getComparableProducts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetComparableProducts200Response';
        $request = $this->getComparableProductsRequest($upc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getComparableProducts'
     *
     * @param  float $upc The UPC of the product for which you want to find comparable products. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComparableProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getComparableProductsRequest($upc, string $contentType = self::contentTypes['getComparableProducts'][0])
    {

        // verify the required parameter 'upc' is set
        if ($upc === null || (is_array($upc) && count($upc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upc when calling getComparableProducts'
            );
        }


        $resourcePath = '/food/products/upc/{upc}/comparable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($upc !== null) {
            $resourcePath = str_replace(
                '{' . 'upc' . '}',
                ObjectSerializer::toPathValue($upc),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductInformation
     *
     * Get Product Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetProductInformation200Response
     */
    public function getProductInformation($id, string $contentType = self::contentTypes['getProductInformation'][0])
    {
        list($response) = $this->getProductInformationWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getProductInformationWithHttpInfo
     *
     * Get Product Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetProductInformation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductInformationWithHttpInfo($id, string $contentType = self::contentTypes['getProductInformation'][0])
    {
        $request = $this->getProductInformationRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetProductInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetProductInformation200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetProductInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetProductInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetProductInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProductInformationAsync
     *
     * Get Product Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductInformationAsync($id, string $contentType = self::contentTypes['getProductInformation'][0])
    {
        return $this->getProductInformationAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductInformationAsyncWithHttpInfo
     *
     * Get Product Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductInformationAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getProductInformation'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetProductInformation200Response';
        $request = $this->getProductInformationRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductInformation'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductInformationRequest($id, string $contentType = self::contentTypes['getProductInformation'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProductInformation'
            );
        }


        $resourcePath = '/food/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productNutritionByIDImage
     *
     * Product Nutrition by ID Image
     *
     * @param  float $id The id of the product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function productNutritionByIDImage($id, string $contentType = self::contentTypes['productNutritionByIDImage'][0])
    {
        list($response) = $this->productNutritionByIDImageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation productNutritionByIDImageWithHttpInfo
     *
     * Product Nutrition by ID Image
     *
     * @param  float $id The id of the product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function productNutritionByIDImageWithHttpInfo($id, string $contentType = self::contentTypes['productNutritionByIDImage'][0])
    {
        $request = $this->productNutritionByIDImageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productNutritionByIDImageAsync
     *
     * Product Nutrition by ID Image
     *
     * @param  float $id The id of the product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productNutritionByIDImageAsync($id, string $contentType = self::contentTypes['productNutritionByIDImage'][0])
    {
        return $this->productNutritionByIDImageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productNutritionByIDImageAsyncWithHttpInfo
     *
     * Product Nutrition by ID Image
     *
     * @param  float $id The id of the product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productNutritionByIDImageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['productNutritionByIDImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->productNutritionByIDImageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productNutritionByIDImage'
     *
     * @param  float $id The id of the product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productNutritionByIDImageRequest($id, string $contentType = self::contentTypes['productNutritionByIDImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productNutritionByIDImage'
            );
        }


        $resourcePath = '/food/products/{id}/nutritionWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productNutritionLabelImage
     *
     * Product Nutrition Label Image
     *
     * @param  float $id The product id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function productNutritionLabelImage($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelImage'][0])
    {
        list($response) = $this->productNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);
        return $response;
    }

    /**
     * Operation productNutritionLabelImageWithHttpInfo
     *
     * Product Nutrition Label Image
     *
     * @param  float $id The product id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function productNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelImage'][0])
    {
        $request = $this->productNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productNutritionLabelImageAsync
     *
     * Product Nutrition Label Image
     *
     * @param  float $id The product id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productNutritionLabelImageAsync($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelImage'][0])
    {
        return $this->productNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productNutritionLabelImageAsyncWithHttpInfo
     *
     * Product Nutrition Label Image
     *
     * @param  float $id The product id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->productNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productNutritionLabelImage'
     *
     * @param  float $id The product id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productNutritionLabelImageRequest($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productNutritionLabelImage'
            );
        }





        $resourcePath = '/food/products/{id}/nutritionLabel.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productNutritionLabelWidget
     *
     * Product Nutrition Label Widget
     *
     * @param  float $id The product id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function productNutritionLabelWidget($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelWidget'][0])
    {
        list($response) = $this->productNutritionLabelWidgetWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);
        return $response;
    }

    /**
     * Operation productNutritionLabelWidgetWithHttpInfo
     *
     * Product Nutrition Label Widget
     *
     * @param  float $id The product id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function productNutritionLabelWidgetWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelWidget'][0])
    {
        $request = $this->productNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productNutritionLabelWidgetAsync
     *
     * Product Nutrition Label Widget
     *
     * @param  float $id The product id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productNutritionLabelWidgetAsync($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelWidget'][0])
    {
        return $this->productNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productNutritionLabelWidgetAsyncWithHttpInfo
     *
     * Product Nutrition Label Widget
     *
     * @param  float $id The product id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelWidget'][0])
    {
        $returnType = 'string';
        $request = $this->productNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productNutritionLabelWidget'
     *
     * @param  float $id The product id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productNutritionLabelWidgetRequest($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['productNutritionLabelWidget'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productNutritionLabelWidget'
            );
        }






        $resourcePath = '/food/products/{id}/nutritionLabel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGroceryProducts
     *
     * Search Grocery Products
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  bool $add_product_information If set to true, you get more information about the products returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchGroceryProducts200Response
     */
    public function searchGroceryProducts($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_product_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchGroceryProducts'][0])
    {
        list($response) = $this->searchGroceryProductsWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_product_information, $offset, $number, $contentType);
        return $response;
    }

    /**
     * Operation searchGroceryProductsWithHttpInfo
     *
     * Search Grocery Products
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  bool $add_product_information If set to true, you get more information about the products returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchGroceryProducts200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGroceryProductsWithHttpInfo($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_product_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchGroceryProducts'][0])
    {
        $request = $this->searchGroceryProductsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_product_information, $offset, $number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchGroceryProducts200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchGroceryProducts200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchGroceryProducts200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SearchGroceryProducts200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchGroceryProducts200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGroceryProductsAsync
     *
     * Search Grocery Products
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  bool $add_product_information If set to true, you get more information about the products returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsAsync($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_product_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchGroceryProducts'][0])
    {
        return $this->searchGroceryProductsAsyncWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_product_information, $offset, $number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGroceryProductsAsyncWithHttpInfo
     *
     * Search Grocery Products
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  bool $add_product_information If set to true, you get more information about the products returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsAsyncWithHttpInfo($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_product_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchGroceryProducts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchGroceryProducts200Response';
        $request = $this->searchGroceryProductsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_product_information, $offset, $number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGroceryProducts'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the product must have. (optional)
     * @param  float $max_calories The maximum amount of calories the product can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the product can have. (optional)
     * @param  bool $add_product_information If set to true, you get more information about the products returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchGroceryProductsRequest($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_product_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchGroceryProducts'][0])
    {











        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling ProductsApi.searchGroceryProducts, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling ProductsApi.searchGroceryProducts, must be bigger than or equal to 0.');
        }
        
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling ProductsApi.searchGroceryProducts, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling ProductsApi.searchGroceryProducts, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/food/products/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calories,
            'minCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calories,
            'maxCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_carbs,
            'minCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_carbs,
            'maxCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_protein,
            'minProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_protein,
            'maxProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fat,
            'minFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fat,
            'maxFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_product_information,
            'addProductInformation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGroceryProductsByUPC
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProductsByUPC'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response
     */
    public function searchGroceryProductsByUPC($upc, string $contentType = self::contentTypes['searchGroceryProductsByUPC'][0])
    {
        list($response) = $this->searchGroceryProductsByUPCWithHttpInfo($upc, $contentType);
        return $response;
    }

    /**
     * Operation searchGroceryProductsByUPCWithHttpInfo
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProductsByUPC'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGroceryProductsByUPCWithHttpInfo($upc, string $contentType = self::contentTypes['searchGroceryProductsByUPC'][0])
    {
        $request = $this->searchGroceryProductsByUPCRequest($upc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGroceryProductsByUPCAsync
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProductsByUPC'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsByUPCAsync($upc, string $contentType = self::contentTypes['searchGroceryProductsByUPC'][0])
    {
        return $this->searchGroceryProductsByUPCAsyncWithHttpInfo($upc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGroceryProductsByUPCAsyncWithHttpInfo
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProductsByUPC'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsByUPCAsyncWithHttpInfo($upc, string $contentType = self::contentTypes['searchGroceryProductsByUPC'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchGroceryProductsByUPC200Response';
        $request = $this->searchGroceryProductsByUPCRequest($upc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGroceryProductsByUPC'
     *
     * @param  float $upc The product&#39;s UPC. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGroceryProductsByUPC'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchGroceryProductsByUPCRequest($upc, string $contentType = self::contentTypes['searchGroceryProductsByUPC'][0])
    {

        // verify the required parameter 'upc' is set
        if ($upc === null || (is_array($upc) && count($upc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upc when calling searchGroceryProductsByUPC'
            );
        }


        $resourcePath = '/food/products/upc/{upc}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($upc !== null) {
            $resourcePath = str_replace(
                '{' . 'upc' . '}',
                ObjectSerializer::toPathValue($upc),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeProductNutritionByID
     *
     * Product Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeProductNutritionByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeProductNutritionByID($id, $default_css = true, string $contentType = self::contentTypes['visualizeProductNutritionByID'][0])
    {
        list($response) = $this->visualizeProductNutritionByIDWithHttpInfo($id, $default_css, $contentType);
        return $response;
    }

    /**
     * Operation visualizeProductNutritionByIDWithHttpInfo
     *
     * Product Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeProductNutritionByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeProductNutritionByIDWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeProductNutritionByID'][0])
    {
        $request = $this->visualizeProductNutritionByIDRequest($id, $default_css, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeProductNutritionByIDAsync
     *
     * Product Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeProductNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeProductNutritionByIDAsync($id, $default_css = true, string $contentType = self::contentTypes['visualizeProductNutritionByID'][0])
    {
        return $this->visualizeProductNutritionByIDAsyncWithHttpInfo($id, $default_css, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeProductNutritionByIDAsyncWithHttpInfo
     *
     * Product Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeProductNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeProductNutritionByIDAsyncWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeProductNutritionByID'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeProductNutritionByIDRequest($id, $default_css, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeProductNutritionByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeProductNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeProductNutritionByIDRequest($id, $default_css = true, string $contentType = self::contentTypes['visualizeProductNutritionByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeProductNutritionByID'
            );
        }



        $resourcePath = '/food/products/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
