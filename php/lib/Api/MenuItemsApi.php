<?php
/**
 * MenuItemsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.7.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * MenuItemsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MenuItemsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'autocompleteMenuItemSearch' => [
            'application/json',
        ],
        'getMenuItemInformation' => [
            'application/json',
        ],
        'menuItemNutritionByIDImage' => [
            'application/json',
        ],
        'menuItemNutritionLabelImage' => [
            'application/json',
        ],
        'menuItemNutritionLabelWidget' => [
            'application/json',
        ],
        'searchMenuItems' => [
            'application/json',
        ],
        'visualizeMenuItemNutritionByID' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation autocompleteMenuItemSearch
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteMenuItemSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response
     */
    public function autocompleteMenuItemSearch($query, $number = null, string $contentType = self::contentTypes['autocompleteMenuItemSearch'][0])
    {
        list($response) = $this->autocompleteMenuItemSearchWithHttpInfo($query, $number, $contentType);
        return $response;
    }

    /**
     * Operation autocompleteMenuItemSearchWithHttpInfo
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteMenuItemSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteMenuItemSearchWithHttpInfo($query, $number = null, string $contentType = self::contentTypes['autocompleteMenuItemSearch'][0])
    {
        $request = $this->autocompleteMenuItemSearchRequest($query, $number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteMenuItemSearchAsync
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteMenuItemSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteMenuItemSearchAsync($query, $number = null, string $contentType = self::contentTypes['autocompleteMenuItemSearch'][0])
    {
        return $this->autocompleteMenuItemSearchAsyncWithHttpInfo($query, $number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteMenuItemSearchAsyncWithHttpInfo
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteMenuItemSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteMenuItemSearchAsyncWithHttpInfo($query, $number = null, string $contentType = self::contentTypes['autocompleteMenuItemSearch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AutocompleteMenuItemSearch200Response';
        $request = $this->autocompleteMenuItemSearchRequest($query, $number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteMenuItemSearch'
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteMenuItemSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autocompleteMenuItemSearchRequest($query, $number = null, string $contentType = self::contentTypes['autocompleteMenuItemSearch'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteMenuItemSearch'
            );
        }

        if ($number !== null && $number > 25) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MenuItemsApi.autocompleteMenuItemSearch, must be smaller than or equal to 25.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MenuItemsApi.autocompleteMenuItemSearch, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/food/menuItems/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMenuItemInformation
     *
     * Get Menu Item Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMenuItemInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetMenuItemInformation200Response
     */
    public function getMenuItemInformation($id, string $contentType = self::contentTypes['getMenuItemInformation'][0])
    {
        list($response) = $this->getMenuItemInformationWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getMenuItemInformationWithHttpInfo
     *
     * Get Menu Item Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMenuItemInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetMenuItemInformation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMenuItemInformationWithHttpInfo($id, string $contentType = self::contentTypes['getMenuItemInformation'][0])
    {
        $request = $this->getMenuItemInformationRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetMenuItemInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetMenuItemInformation200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetMenuItemInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetMenuItemInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetMenuItemInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMenuItemInformationAsync
     *
     * Get Menu Item Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMenuItemInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuItemInformationAsync($id, string $contentType = self::contentTypes['getMenuItemInformation'][0])
    {
        return $this->getMenuItemInformationAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMenuItemInformationAsyncWithHttpInfo
     *
     * Get Menu Item Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMenuItemInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuItemInformationAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getMenuItemInformation'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetMenuItemInformation200Response';
        $request = $this->getMenuItemInformationRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMenuItemInformation'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMenuItemInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMenuItemInformationRequest($id, string $contentType = self::contentTypes['getMenuItemInformation'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMenuItemInformation'
            );
        }


        $resourcePath = '/food/menuItems/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemNutritionByIDImage
     *
     * Menu Item Nutrition by ID Image
     *
     * @param  float $id The menu item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function menuItemNutritionByIDImage($id, string $contentType = self::contentTypes['menuItemNutritionByIDImage'][0])
    {
        list($response) = $this->menuItemNutritionByIDImageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation menuItemNutritionByIDImageWithHttpInfo
     *
     * Menu Item Nutrition by ID Image
     *
     * @param  float $id The menu item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemNutritionByIDImageWithHttpInfo($id, string $contentType = self::contentTypes['menuItemNutritionByIDImage'][0])
    {
        $request = $this->menuItemNutritionByIDImageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemNutritionByIDImageAsync
     *
     * Menu Item Nutrition by ID Image
     *
     * @param  float $id The menu item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemNutritionByIDImageAsync($id, string $contentType = self::contentTypes['menuItemNutritionByIDImage'][0])
    {
        return $this->menuItemNutritionByIDImageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemNutritionByIDImageAsyncWithHttpInfo
     *
     * Menu Item Nutrition by ID Image
     *
     * @param  float $id The menu item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemNutritionByIDImageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['menuItemNutritionByIDImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->menuItemNutritionByIDImageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemNutritionByIDImage'
     *
     * @param  float $id The menu item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemNutritionByIDImageRequest($id, string $contentType = self::contentTypes['menuItemNutritionByIDImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling menuItemNutritionByIDImage'
            );
        }


        $resourcePath = '/food/menuItems/{id}/nutritionWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemNutritionLabelImage
     *
     * Menu Item Nutrition Label Image
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function menuItemNutritionLabelImage($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelImage'][0])
    {
        list($response) = $this->menuItemNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);
        return $response;
    }

    /**
     * Operation menuItemNutritionLabelImageWithHttpInfo
     *
     * Menu Item Nutrition Label Image
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelImage'][0])
    {
        $request = $this->menuItemNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemNutritionLabelImageAsync
     *
     * Menu Item Nutrition Label Image
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemNutritionLabelImageAsync($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelImage'][0])
    {
        return $this->menuItemNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemNutritionLabelImageAsyncWithHttpInfo
     *
     * Menu Item Nutrition Label Image
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->menuItemNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemNutritionLabelImage'
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemNutritionLabelImageRequest($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling menuItemNutritionLabelImage'
            );
        }





        $resourcePath = '/food/menuItems/{id}/nutritionLabel.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menuItemNutritionLabelWidget
     *
     * Menu Item Nutrition Label Widget
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function menuItemNutritionLabelWidget($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelWidget'][0])
    {
        list($response) = $this->menuItemNutritionLabelWidgetWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);
        return $response;
    }

    /**
     * Operation menuItemNutritionLabelWidgetWithHttpInfo
     *
     * Menu Item Nutrition Label Widget
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function menuItemNutritionLabelWidgetWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelWidget'][0])
    {
        $request = $this->menuItemNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation menuItemNutritionLabelWidgetAsync
     *
     * Menu Item Nutrition Label Widget
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemNutritionLabelWidgetAsync($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelWidget'][0])
    {
        return $this->menuItemNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menuItemNutritionLabelWidgetAsyncWithHttpInfo
     *
     * Menu Item Nutrition Label Widget
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menuItemNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelWidget'][0])
    {
        $returnType = 'string';
        $request = $this->menuItemNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menuItemNutritionLabelWidget'
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['menuItemNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function menuItemNutritionLabelWidgetRequest($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['menuItemNutritionLabelWidget'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling menuItemNutritionLabelWidget'
            );
        }






        $resourcePath = '/food/menuItems/{id}/nutritionLabel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchMenuItems
     *
     * Search Menu Items
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  bool $add_menu_item_information If set to true, you get more information about the menu items returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMenuItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchMenuItems200Response
     */
    public function searchMenuItems($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_menu_item_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchMenuItems'][0])
    {
        list($response) = $this->searchMenuItemsWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_menu_item_information, $offset, $number, $contentType);
        return $response;
    }

    /**
     * Operation searchMenuItemsWithHttpInfo
     *
     * Search Menu Items
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  bool $add_menu_item_information If set to true, you get more information about the menu items returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMenuItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchMenuItems200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchMenuItemsWithHttpInfo($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_menu_item_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchMenuItems'][0])
    {
        $request = $this->searchMenuItemsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_menu_item_information, $offset, $number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchMenuItems200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchMenuItems200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchMenuItems200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SearchMenuItems200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchMenuItems200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchMenuItemsAsync
     *
     * Search Menu Items
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  bool $add_menu_item_information If set to true, you get more information about the menu items returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMenuItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMenuItemsAsync($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_menu_item_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchMenuItems'][0])
    {
        return $this->searchMenuItemsAsyncWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_menu_item_information, $offset, $number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchMenuItemsAsyncWithHttpInfo
     *
     * Search Menu Items
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  bool $add_menu_item_information If set to true, you get more information about the menu items returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMenuItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMenuItemsAsyncWithHttpInfo($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_menu_item_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchMenuItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchMenuItems200Response';
        $request = $this->searchMenuItemsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $add_menu_item_information, $offset, $number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchMenuItems'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  float $min_calories The minimum amount of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum amount of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the menu item can have. (optional)
     * @param  bool $add_menu_item_information If set to true, you get more information about the menu items returned. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchMenuItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchMenuItemsRequest($query = null, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $add_menu_item_information = null, $offset = null, $number = 10, string $contentType = self::contentTypes['searchMenuItems'][0])
    {











        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MenuItemsApi.searchMenuItems, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MenuItemsApi.searchMenuItems, must be bigger than or equal to 0.');
        }
        
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MenuItemsApi.searchMenuItems, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MenuItemsApi.searchMenuItems, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/food/menuItems/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calories,
            'minCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calories,
            'maxCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_carbs,
            'minCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_carbs,
            'maxCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_protein,
            'minProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_protein,
            'maxProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fat,
            'minFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fat,
            'maxFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_menu_item_information,
            'addMenuItemInformation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeMenuItemNutritionByID
     *
     * Menu Item Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeMenuItemNutritionByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeMenuItemNutritionByID($id, $default_css = true, string $contentType = self::contentTypes['visualizeMenuItemNutritionByID'][0])
    {
        list($response) = $this->visualizeMenuItemNutritionByIDWithHttpInfo($id, $default_css, $contentType);
        return $response;
    }

    /**
     * Operation visualizeMenuItemNutritionByIDWithHttpInfo
     *
     * Menu Item Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeMenuItemNutritionByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeMenuItemNutritionByIDWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeMenuItemNutritionByID'][0])
    {
        $request = $this->visualizeMenuItemNutritionByIDRequest($id, $default_css, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeMenuItemNutritionByIDAsync
     *
     * Menu Item Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeMenuItemNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeMenuItemNutritionByIDAsync($id, $default_css = true, string $contentType = self::contentTypes['visualizeMenuItemNutritionByID'][0])
    {
        return $this->visualizeMenuItemNutritionByIDAsyncWithHttpInfo($id, $default_css, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeMenuItemNutritionByIDAsyncWithHttpInfo
     *
     * Menu Item Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeMenuItemNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeMenuItemNutritionByIDAsyncWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeMenuItemNutritionByID'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeMenuItemNutritionByIDRequest($id, $default_css, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeMenuItemNutritionByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeMenuItemNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeMenuItemNutritionByIDRequest($id, $default_css = true, string $contentType = self::contentTypes['visualizeMenuItemNutritionByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeMenuItemNutritionByID'
            );
        }



        $resourcePath = '/food/menuItems/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
