<?php
/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.spoonacular.client\com.spoonacular;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.spoonacular.client\ApiException;
use com.spoonacular.client\Configuration;
use com.spoonacular.client\HeaderSelector;
use com.spoonacular.client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation analyzeRecipe
     *
     * Analyze Recipe
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function analyzeRecipe($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null)
    {
        list($response) = $this->analyzeRecipeWithHttpInfo($analyze_recipe_request, $language, $include_nutrition, $include_taste);
        return $response;
    }

    /**
     * Operation analyzeRecipeWithHttpInfo
     *
     * Analyze Recipe
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeRecipeWithHttpInfo($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null)
    {
        $request = $this->analyzeRecipeRequest($analyze_recipe_request, $language, $include_nutrition, $include_taste);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeRecipeAsync
     *
     * Analyze Recipe
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeAsync($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null)
    {
        return $this->analyzeRecipeAsyncWithHttpInfo($analyze_recipe_request, $language, $include_nutrition, $include_taste)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeRecipeAsyncWithHttpInfo
     *
     * Analyze Recipe
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeAsyncWithHttpInfo($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null)
    {
        $returnType = 'object';
        $request = $this->analyzeRecipeRequest($analyze_recipe_request, $language, $include_nutrition, $include_taste);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeRecipe'
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function analyzeRecipeRequest($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null)
    {
        // verify the required parameter 'analyze_recipe_request' is set
        if ($analyze_recipe_request === null || (is_array($analyze_recipe_request) && count($analyze_recipe_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $analyze_recipe_request when calling analyzeRecipe'
            );
        }

        $resourcePath = '/recipes/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_taste,
            'includeTaste', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($analyze_recipe_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($analyze_recipe_request));
            } else {
                $httpBody = $analyze_recipe_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRecipeCardGet
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createRecipeCardGet($id, $mask = null, $background_image = null, $background_color = null, $font_color = null)
    {
        list($response) = $this->createRecipeCardGetWithHttpInfo($id, $mask, $background_image, $background_color, $font_color);
        return $response;
    }

    /**
     * Operation createRecipeCardGetWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRecipeCardGetWithHttpInfo($id, $mask = null, $background_image = null, $background_color = null, $font_color = null)
    {
        $request = $this->createRecipeCardGetRequest($id, $mask, $background_image, $background_color, $font_color);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRecipeCardGetAsync
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardGetAsync($id, $mask = null, $background_image = null, $background_color = null, $font_color = null)
    {
        return $this->createRecipeCardGetAsyncWithHttpInfo($id, $mask, $background_image, $background_color, $font_color)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRecipeCardGetAsyncWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardGetAsyncWithHttpInfo($id, $mask = null, $background_image = null, $background_color = null, $font_color = null)
    {
        $returnType = 'object';
        $request = $this->createRecipeCardGetRequest($id, $mask, $background_image, $background_color, $font_color);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRecipeCardGet'
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRecipeCardGetRequest($id, $mask = null, $background_image = null, $background_color = null, $font_color = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createRecipeCardGet'
            );
        }

        $resourcePath = '/recipes/{id}/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask,
            'mask', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_image,
            'backgroundImage', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $font_color,
            'fontColor', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRestaurants
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response
     */
    public function searchRestaurants($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null)
    {
        list($response) = $this->searchRestaurantsWithHttpInfo($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page);
        return $response;
    }

    /**
     * Operation searchRestaurantsWithHttpInfo
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRestaurantsWithHttpInfo($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null)
    {
        $request = $this->searchRestaurantsRequest($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRestaurantsAsync
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantsAsync($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null)
    {
        return $this->searchRestaurantsAsyncWithHttpInfo($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRestaurantsAsyncWithHttpInfo
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantsAsyncWithHttpInfo($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRestaurants200Response';
        $request = $this->searchRestaurantsRequest($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRestaurants'
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRestaurantsRequest($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null)
    {

        $resourcePath = '/food/restaurants/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lat,
            'lat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lng,
            'lng', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance,
            'distance', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $budget,
            'budget', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cuisine,
            'cuisine', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_rating,
            'min-rating', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_open,
            'is-open', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
