--[[
  spoonacular API
 
  The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 800,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 
  The version of the OpenAPI document: 1.0
  Contact: mail@spoonacular.com
  Generated by: https://openapi-generator.tech
]]

--package spoonacular

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local spoonacular_todo_object_mapping = require "spoonacular.model.todo_object_mapping"
local spoonacular_inline_object = require "spoonacular.model.inline_object"
local spoonacular_inline_response_200 = require "spoonacular.model.inline_response_200"
local spoonacular_inline_response_200_1 = require "spoonacular.model.inline_response_200_1"
local spoonacular_inline_response_200_10 = require "spoonacular.model.inline_response_200_10"
local spoonacular_inline_response_200_11 = require "spoonacular.model.inline_response_200_11"
local spoonacular_inline_response_200_12 = require "spoonacular.model.inline_response_200_12"
local spoonacular_inline_response_200_13 = require "spoonacular.model.inline_response_200_13"
local spoonacular_inline_response_200_14 = require "spoonacular.model.inline_response_200_14"
local spoonacular_inline_response_200_15 = require "spoonacular.model.inline_response_200_15"
local spoonacular_inline_response_200_16 = require "spoonacular.model.inline_response_200_16"
local spoonacular_inline_response_200_17 = require "spoonacular.model.inline_response_200_17"
local spoonacular_inline_response_200_18 = require "spoonacular.model.inline_response_200_18"
local spoonacular_inline_response_200_19 = require "spoonacular.model.inline_response_200_19"
local spoonacular_inline_response_200_2 = require "spoonacular.model.inline_response_200_2"
local spoonacular_inline_response_200_20 = require "spoonacular.model.inline_response_200_20"
local spoonacular_inline_response_200_21 = require "spoonacular.model.inline_response_200_21"
local spoonacular_inline_response_200_23 = require "spoonacular.model.inline_response_200_23"
local spoonacular_inline_response_200_3 = require "spoonacular.model.inline_response_200_3"
local spoonacular_inline_response_200_4 = require "spoonacular.model.inline_response_200_4"
local spoonacular_inline_response_200_5 = require "spoonacular.model.inline_response_200_5"
local spoonacular_inline_response_200_50 = require "spoonacular.model.inline_response_200_50"
local spoonacular_inline_response_200_6 = require "spoonacular.model.inline_response_200_6"
local spoonacular_inline_response_200_7 = require "spoonacular.model.inline_response_200_7"
local spoonacular_inline_response_200_8 = require "spoonacular.model.inline_response_200_8"
local spoonacular_inline_response_200_9 = require "spoonacular.model.inline_response_200_9"

local recipes_api = {}
local recipes_api_mt = {
	__name = "recipes_api";
	__index = recipes_api;
}

local function new_recipes_api(authority, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	local host, port = http_util.split_authority(authority, default_scheme)
	return setmetatable({
		host = host;
		port = port;
		basePath = basePath or "https://api.spoonacular.com";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, recipes_api_mt)
end

function recipes_api:analyze_a_recipe_search_query(q)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/queries/analyze?q=%s",
			self.basePath, http_util.encodeURIComponent(q));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_18.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:analyze_recipe_instructions(content_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/analyzeInstructions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_16.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:autocomplete_recipe_search(query, Number_)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/autocomplete?query=%s&number=%s",
			self.basePath, http_util.encodeURIComponent(query), http_util.encodeURIComponent(Number_));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_inline_response_200_7.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:classify_cuisine(content_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/cuisine",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_17.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:compute_glycemic_load(inline_object, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/food/ingredients/glycemicLoad?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(inline_object))

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_23.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:convert_amounts(ingredient_name, source_amount, source_unit, target_unit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/convert?ingredientName=%s&sourceAmount=%s&sourceUnit=%s&targetUnit=%s",
			self.basePath, http_util.encodeURIComponent(ingredient_name), http_util.encodeURIComponent(source_amount), http_util.encodeURIComponent(source_unit), http_util.encodeURIComponent(target_unit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_19.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:create_recipe_card(content_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeRecipe",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_15.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:equipment_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:extract_recipe_from_website(url, force_extraction, analyze, include_nutrition, include_taste)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/extract?url=%s&forceExtraction=%s&analyze=%s&includeNutrition=%s&includeTaste=%s",
			self.basePath, http_util.encodeURIComponent(url), http_util.encodeURIComponent(force_extraction), http_util.encodeURIComponent(analyze), http_util.encodeURIComponent(include_nutrition), http_util.encodeURIComponent(include_taste));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_3.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_analyzed_recipe_instructions(id, step_breakdown)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/analyzedInstructions?stepBreakdown=%s",
			self.basePath, id, http_util.encodeURIComponent(step_breakdown));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_13.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_random_recipes(limit_license, tags, Number_)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/random?limitLicense=%s&tags=%s&number=%s",
			self.basePath, http_util.encodeURIComponent(limit_license), http_util.encodeURIComponent(tags), http_util.encodeURIComponent(Number_));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_6.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_equipment_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_9.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_information(id, include_nutrition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/information?includeNutrition=%s",
			self.basePath, id, http_util.encodeURIComponent(include_nutrition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_3.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_information_bulk(ids, include_nutrition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/informationBulk?ids=%s&includeNutrition=%s",
			self.basePath, http_util.encodeURIComponent(ids), http_util.encodeURIComponent(include_nutrition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_inline_response_200_4.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_ingredients_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_11.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_nutrition_widget_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_12.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_price_breakdown_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_10.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_taste_by_id(id, normalize)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget.json?normalize=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_8.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_similar_recipes(id, Number_, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/similar?number=%s&limitLicense=%s",
			self.basePath, id, http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_inline_response_200_5.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:guess_nutrition_by_dish_name(title)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/guessNutrition?title=%s",
			self.basePath, http_util.encodeURIComponent(title));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_21.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:ingredients_by_id_image(id, measure)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget.png?measure=%s",
			self.basePath, id, http_util.encodeURIComponent(measure));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:parse_ingredients(content_type, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/parseIngredients?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_inline_response_200_20.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:price_breakdown_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:quick_answer(q)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/quickAnswer?q=%s",
			self.basePath, http_util.encodeURIComponent(q));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_50.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_label_image(id, show_optional_nutrients, show_zero_values, show_ingredients)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionLabel.png?showOptionalNutrients=%s&showZeroValues=%s&showIngredients=%s",
			self.basePath, id, http_util.encodeURIComponent(show_optional_nutrients), http_util.encodeURIComponent(show_zero_values), http_util.encodeURIComponent(show_ingredients));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_label_widget(id, default_css, show_optional_nutrients, show_zero_values, show_ingredients)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionLabel?defaultCss=%s&showOptionalNutrients=%s&showZeroValues=%s&showIngredients=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css), http_util.encodeURIComponent(show_optional_nutrients), http_util.encodeURIComponent(show_zero_values), http_util.encodeURIComponent(show_ingredients));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_taste_by_id_image(id, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget.png?normalize=%s&rgb=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes(query, cuisine, exclude_cuisine, diet, intolerances, equipment, include_ingredients, exclude_ingredients, type, instructions_required, fill_ingredients, add_recipe_information, add_recipe_nutrition, author, tags, recipe_box_id, title_match, max_ready_time, ignore_pantry, sort, sort_direction, min_carbs, max_carbs, min_protein, max_protein, min_calories, max_calories, min_fat, max_fat, min_alcohol, max_alcohol, min_caffeine, max_caffeine, min_copper, max_copper, min_calcium, max_calcium, min_choline, max_choline, min_cholesterol, max_cholesterol, min_fluoride, max_fluoride, min_saturated_fat, max_saturated_fat, min_vitamin_a, max_vitamin_a, min_vitamin_c, max_vitamin_c, min_vitamin_d, max_vitamin_d, min_vitamin_e, max_vitamin_e, min_vitamin_k, max_vitamin_k, min_vitamin_b1, max_vitamin_b1, min_vitamin_b2, max_vitamin_b2, min_vitamin_b5, max_vitamin_b5, min_vitamin_b3, max_vitamin_b3, min_vitamin_b6, max_vitamin_b6, min_vitamin_b12, max_vitamin_b12, min_fiber, max_fiber, min_folate, max_folate, min_folic_acid, max_folic_acid, min_iodine, max_iodine, min_iron, max_iron, min_magnesium, max_magnesium, min_manganese, max_manganese, min_phosphorus, max_phosphorus, min_potassium, max_potassium, min_selenium, max_selenium, min_sodium, max_sodium, min_sugar, max_sugar, min_zinc, max_zinc, offset, Number_, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/complexSearch?query=%s&cuisine=%s&excludeCuisine=%s&diet=%s&intolerances=%s&equipment=%s&includeIngredients=%s&excludeIngredients=%s&type=%s&instructionsRequired=%s&fillIngredients=%s&addRecipeInformation=%s&addRecipeNutrition=%s&author=%s&tags=%s&recipeBoxId=%s&titleMatch=%s&maxReadyTime=%s&ignorePantry=%s&sort=%s&sortDirection=%s&minCarbs=%s&maxCarbs=%s&minProtein=%s&maxProtein=%s&minCalories=%s&maxCalories=%s&minFat=%s&maxFat=%s&minAlcohol=%s&maxAlcohol=%s&minCaffeine=%s&maxCaffeine=%s&minCopper=%s&maxCopper=%s&minCalcium=%s&maxCalcium=%s&minCholine=%s&maxCholine=%s&minCholesterol=%s&maxCholesterol=%s&minFluoride=%s&maxFluoride=%s&minSaturatedFat=%s&maxSaturatedFat=%s&minVitaminA=%s&maxVitaminA=%s&minVitaminC=%s&maxVitaminC=%s&minVitaminD=%s&maxVitaminD=%s&minVitaminE=%s&maxVitaminE=%s&minVitaminK=%s&maxVitaminK=%s&minVitaminB1=%s&maxVitaminB1=%s&minVitaminB2=%s&maxVitaminB2=%s&minVitaminB5=%s&maxVitaminB5=%s&minVitaminB3=%s&maxVitaminB3=%s&minVitaminB6=%s&maxVitaminB6=%s&minVitaminB12=%s&maxVitaminB12=%s&minFiber=%s&maxFiber=%s&minFolate=%s&maxFolate=%s&minFolicAcid=%s&maxFolicAcid=%s&minIodine=%s&maxIodine=%s&minIron=%s&maxIron=%s&minMagnesium=%s&maxMagnesium=%s&minManganese=%s&maxManganese=%s&minPhosphorus=%s&maxPhosphorus=%s&minPotassium=%s&maxPotassium=%s&minSelenium=%s&maxSelenium=%s&minSodium=%s&maxSodium=%s&minSugar=%s&maxSugar=%s&minZinc=%s&maxZinc=%s&offset=%s&number=%s&limitLicense=%s",
			self.basePath, http_util.encodeURIComponent(query), http_util.encodeURIComponent(cuisine), http_util.encodeURIComponent(exclude_cuisine), http_util.encodeURIComponent(diet), http_util.encodeURIComponent(intolerances), http_util.encodeURIComponent(equipment), http_util.encodeURIComponent(include_ingredients), http_util.encodeURIComponent(exclude_ingredients), http_util.encodeURIComponent(type), http_util.encodeURIComponent(instructions_required), http_util.encodeURIComponent(fill_ingredients), http_util.encodeURIComponent(add_recipe_information), http_util.encodeURIComponent(add_recipe_nutrition), http_util.encodeURIComponent(author), http_util.encodeURIComponent(tags), http_util.encodeURIComponent(recipe_box_id), http_util.encodeURIComponent(title_match), http_util.encodeURIComponent(max_ready_time), http_util.encodeURIComponent(ignore_pantry), http_util.encodeURIComponent(sort), http_util.encodeURIComponent(sort_direction), http_util.encodeURIComponent(min_carbs), http_util.encodeURIComponent(max_carbs), http_util.encodeURIComponent(min_protein), http_util.encodeURIComponent(max_protein), http_util.encodeURIComponent(min_calories), http_util.encodeURIComponent(max_calories), http_util.encodeURIComponent(min_fat), http_util.encodeURIComponent(max_fat), http_util.encodeURIComponent(min_alcohol), http_util.encodeURIComponent(max_alcohol), http_util.encodeURIComponent(min_caffeine), http_util.encodeURIComponent(max_caffeine), http_util.encodeURIComponent(min_copper), http_util.encodeURIComponent(max_copper), http_util.encodeURIComponent(min_calcium), http_util.encodeURIComponent(max_calcium), http_util.encodeURIComponent(min_choline), http_util.encodeURIComponent(max_choline), http_util.encodeURIComponent(min_cholesterol), http_util.encodeURIComponent(max_cholesterol), http_util.encodeURIComponent(min_fluoride), http_util.encodeURIComponent(max_fluoride), http_util.encodeURIComponent(min_saturated_fat), http_util.encodeURIComponent(max_saturated_fat), http_util.encodeURIComponent(min_vitamin_a), http_util.encodeURIComponent(max_vitamin_a), http_util.encodeURIComponent(min_vitamin_c), http_util.encodeURIComponent(max_vitamin_c), http_util.encodeURIComponent(min_vitamin_d), http_util.encodeURIComponent(max_vitamin_d), http_util.encodeURIComponent(min_vitamin_e), http_util.encodeURIComponent(max_vitamin_e), http_util.encodeURIComponent(min_vitamin_k), http_util.encodeURIComponent(max_vitamin_k), http_util.encodeURIComponent(min_vitamin_b1), http_util.encodeURIComponent(max_vitamin_b1), http_util.encodeURIComponent(min_vitamin_b2), http_util.encodeURIComponent(max_vitamin_b2), http_util.encodeURIComponent(min_vitamin_b5), http_util.encodeURIComponent(max_vitamin_b5), http_util.encodeURIComponent(min_vitamin_b3), http_util.encodeURIComponent(max_vitamin_b3), http_util.encodeURIComponent(min_vitamin_b6), http_util.encodeURIComponent(max_vitamin_b6), http_util.encodeURIComponent(min_vitamin_b12), http_util.encodeURIComponent(max_vitamin_b12), http_util.encodeURIComponent(min_fiber), http_util.encodeURIComponent(max_fiber), http_util.encodeURIComponent(min_folate), http_util.encodeURIComponent(max_folate), http_util.encodeURIComponent(min_folic_acid), http_util.encodeURIComponent(max_folic_acid), http_util.encodeURIComponent(min_iodine), http_util.encodeURIComponent(max_iodine), http_util.encodeURIComponent(min_iron), http_util.encodeURIComponent(max_iron), http_util.encodeURIComponent(min_magnesium), http_util.encodeURIComponent(max_magnesium), http_util.encodeURIComponent(min_manganese), http_util.encodeURIComponent(max_manganese), http_util.encodeURIComponent(min_phosphorus), http_util.encodeURIComponent(max_phosphorus), http_util.encodeURIComponent(min_potassium), http_util.encodeURIComponent(max_potassium), http_util.encodeURIComponent(min_selenium), http_util.encodeURIComponent(max_selenium), http_util.encodeURIComponent(min_sodium), http_util.encodeURIComponent(max_sodium), http_util.encodeURIComponent(min_sugar), http_util.encodeURIComponent(max_sugar), http_util.encodeURIComponent(min_zinc), http_util.encodeURIComponent(max_zinc), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes_by_ingredients(ingredients, Number_, limit_license, ranking, ignore_pantry)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/findByIngredients?ingredients=%s&number=%s&limitLicense=%s&ranking=%s&ignorePantry=%s",
			self.basePath, http_util.encodeURIComponent(ingredients), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license), http_util.encodeURIComponent(ranking), http_util.encodeURIComponent(ignore_pantry));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_inline_response_200_1.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes_by_nutrients(min_carbs, max_carbs, min_protein, max_protein, min_calories, max_calories, min_fat, max_fat, min_alcohol, max_alcohol, min_caffeine, max_caffeine, min_copper, max_copper, min_calcium, max_calcium, min_choline, max_choline, min_cholesterol, max_cholesterol, min_fluoride, max_fluoride, min_saturated_fat, max_saturated_fat, min_vitamin_a, max_vitamin_a, min_vitamin_c, max_vitamin_c, min_vitamin_d, max_vitamin_d, min_vitamin_e, max_vitamin_e, min_vitamin_k, max_vitamin_k, min_vitamin_b1, max_vitamin_b1, min_vitamin_b2, max_vitamin_b2, min_vitamin_b5, max_vitamin_b5, min_vitamin_b3, max_vitamin_b3, min_vitamin_b6, max_vitamin_b6, min_vitamin_b12, max_vitamin_b12, min_fiber, max_fiber, min_folate, max_folate, min_folic_acid, max_folic_acid, min_iodine, max_iodine, min_iron, max_iron, min_magnesium, max_magnesium, min_manganese, max_manganese, min_phosphorus, max_phosphorus, min_potassium, max_potassium, min_selenium, max_selenium, min_sodium, max_sodium, min_sugar, max_sugar, min_zinc, max_zinc, offset, Number_, random, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/findByNutrients?minCarbs=%s&maxCarbs=%s&minProtein=%s&maxProtein=%s&minCalories=%s&maxCalories=%s&minFat=%s&maxFat=%s&minAlcohol=%s&maxAlcohol=%s&minCaffeine=%s&maxCaffeine=%s&minCopper=%s&maxCopper=%s&minCalcium=%s&maxCalcium=%s&minCholine=%s&maxCholine=%s&minCholesterol=%s&maxCholesterol=%s&minFluoride=%s&maxFluoride=%s&minSaturatedFat=%s&maxSaturatedFat=%s&minVitaminA=%s&maxVitaminA=%s&minVitaminC=%s&maxVitaminC=%s&minVitaminD=%s&maxVitaminD=%s&minVitaminE=%s&maxVitaminE=%s&minVitaminK=%s&maxVitaminK=%s&minVitaminB1=%s&maxVitaminB1=%s&minVitaminB2=%s&maxVitaminB2=%s&minVitaminB5=%s&maxVitaminB5=%s&minVitaminB3=%s&maxVitaminB3=%s&minVitaminB6=%s&maxVitaminB6=%s&minVitaminB12=%s&maxVitaminB12=%s&minFiber=%s&maxFiber=%s&minFolate=%s&maxFolate=%s&minFolicAcid=%s&maxFolicAcid=%s&minIodine=%s&maxIodine=%s&minIron=%s&maxIron=%s&minMagnesium=%s&maxMagnesium=%s&minManganese=%s&maxManganese=%s&minPhosphorus=%s&maxPhosphorus=%s&minPotassium=%s&maxPotassium=%s&minSelenium=%s&maxSelenium=%s&minSodium=%s&maxSodium=%s&minSugar=%s&maxSugar=%s&minZinc=%s&maxZinc=%s&offset=%s&number=%s&random=%s&limitLicense=%s",
			self.basePath, http_util.encodeURIComponent(min_carbs), http_util.encodeURIComponent(max_carbs), http_util.encodeURIComponent(min_protein), http_util.encodeURIComponent(max_protein), http_util.encodeURIComponent(min_calories), http_util.encodeURIComponent(max_calories), http_util.encodeURIComponent(min_fat), http_util.encodeURIComponent(max_fat), http_util.encodeURIComponent(min_alcohol), http_util.encodeURIComponent(max_alcohol), http_util.encodeURIComponent(min_caffeine), http_util.encodeURIComponent(max_caffeine), http_util.encodeURIComponent(min_copper), http_util.encodeURIComponent(max_copper), http_util.encodeURIComponent(min_calcium), http_util.encodeURIComponent(max_calcium), http_util.encodeURIComponent(min_choline), http_util.encodeURIComponent(max_choline), http_util.encodeURIComponent(min_cholesterol), http_util.encodeURIComponent(max_cholesterol), http_util.encodeURIComponent(min_fluoride), http_util.encodeURIComponent(max_fluoride), http_util.encodeURIComponent(min_saturated_fat), http_util.encodeURIComponent(max_saturated_fat), http_util.encodeURIComponent(min_vitamin_a), http_util.encodeURIComponent(max_vitamin_a), http_util.encodeURIComponent(min_vitamin_c), http_util.encodeURIComponent(max_vitamin_c), http_util.encodeURIComponent(min_vitamin_d), http_util.encodeURIComponent(max_vitamin_d), http_util.encodeURIComponent(min_vitamin_e), http_util.encodeURIComponent(max_vitamin_e), http_util.encodeURIComponent(min_vitamin_k), http_util.encodeURIComponent(max_vitamin_k), http_util.encodeURIComponent(min_vitamin_b1), http_util.encodeURIComponent(max_vitamin_b1), http_util.encodeURIComponent(min_vitamin_b2), http_util.encodeURIComponent(max_vitamin_b2), http_util.encodeURIComponent(min_vitamin_b5), http_util.encodeURIComponent(max_vitamin_b5), http_util.encodeURIComponent(min_vitamin_b3), http_util.encodeURIComponent(max_vitamin_b3), http_util.encodeURIComponent(min_vitamin_b6), http_util.encodeURIComponent(max_vitamin_b6), http_util.encodeURIComponent(min_vitamin_b12), http_util.encodeURIComponent(max_vitamin_b12), http_util.encodeURIComponent(min_fiber), http_util.encodeURIComponent(max_fiber), http_util.encodeURIComponent(min_folate), http_util.encodeURIComponent(max_folate), http_util.encodeURIComponent(min_folic_acid), http_util.encodeURIComponent(max_folic_acid), http_util.encodeURIComponent(min_iodine), http_util.encodeURIComponent(max_iodine), http_util.encodeURIComponent(min_iron), http_util.encodeURIComponent(max_iron), http_util.encodeURIComponent(min_magnesium), http_util.encodeURIComponent(max_magnesium), http_util.encodeURIComponent(min_manganese), http_util.encodeURIComponent(max_manganese), http_util.encodeURIComponent(min_phosphorus), http_util.encodeURIComponent(max_phosphorus), http_util.encodeURIComponent(min_potassium), http_util.encodeURIComponent(max_potassium), http_util.encodeURIComponent(min_selenium), http_util.encodeURIComponent(max_selenium), http_util.encodeURIComponent(min_sodium), http_util.encodeURIComponent(max_sodium), http_util.encodeURIComponent(min_sugar), http_util.encodeURIComponent(max_sugar), http_util.encodeURIComponent(min_zinc), http_util.encodeURIComponent(max_zinc), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(random), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_inline_response_200_2.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:summarize_recipe(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/summary",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_inline_response_200_14.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_equipment(content_type, accept)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeEquipment",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_price_breakdown(content_type, accept, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizePriceEstimator?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_equipment_by_id(id, default_css)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_ingredients_by_id(id, default_css, measure)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget?defaultCss=%s&measure=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css), http_util.encodeURIComponent(measure));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_nutrition(content_type, accept, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeNutrition?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_nutrition_by_id(id, default_css, accept)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_price_breakdown_by_id(id, default_css)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_taste(language, content_type, accept, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeTaste?language=%s&normalize=%s&rgb=%s",
			self.basePath, http_util.encodeURIComponent(language), http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_taste_by_id(id, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget?normalize=%s&rgb=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- TODO: api key in query 'apiKey'

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_recipes_api;
}
