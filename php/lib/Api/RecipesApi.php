<?php
/**
 * RecipesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.7.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * RecipesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RecipesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'analyzeARecipeSearchQuery' => [
            'application/json',
        ],
        'analyzeRecipeInstructions' => [
            'application/x-www-form-urlencoded',
        ],
        'autocompleteRecipeSearch' => [
            'application/json',
        ],
        'classifyCuisine' => [
            'application/x-www-form-urlencoded',
        ],
        'computeGlycemicLoad' => [
            'application/json',
        ],
        'convertAmounts' => [
            'application/json',
        ],
        'createRecipeCard' => [
            'multipart/form-data',
        ],
        'equipmentByIDImage' => [
            'application/json',
        ],
        'extractRecipeFromWebsite' => [
            'application/json',
        ],
        'getAnalyzedRecipeInstructions' => [
            'application/json',
        ],
        'getRandomRecipes' => [
            'application/json',
        ],
        'getRecipeEquipmentByID' => [
            'application/json',
        ],
        'getRecipeInformation' => [
            'application/json',
        ],
        'getRecipeInformationBulk' => [
            'application/json',
        ],
        'getRecipeIngredientsByID' => [
            'application/json',
        ],
        'getRecipeNutritionWidgetByID' => [
            'application/json',
        ],
        'getRecipePriceBreakdownByID' => [
            'application/json',
        ],
        'getRecipeTasteByID' => [
            'application/json',
        ],
        'getSimilarRecipes' => [
            'application/json',
        ],
        'guessNutritionByDishName' => [
            'application/json',
        ],
        'parseIngredients' => [
            'application/x-www-form-urlencoded',
        ],
        'priceBreakdownByIDImage' => [
            'application/json',
        ],
        'quickAnswer' => [
            'application/json',
        ],
        'recipeNutritionByIDImage' => [
            'application/json',
        ],
        'recipeNutritionLabelImage' => [
            'application/json',
        ],
        'recipeNutritionLabelWidget' => [
            'application/json',
        ],
        'recipeTasteByIDImage' => [
            'application/json',
        ],
        'searchRecipes' => [
            'application/json',
        ],
        'searchRecipesByIngredients' => [
            'application/json',
        ],
        'searchRecipesByNutrients' => [
            'application/json',
        ],
        'summarizeRecipe' => [
            'application/json',
        ],
        'visualizeEquipment' => [
            'application/x-www-form-urlencoded',
        ],
        'visualizePriceBreakdown' => [
            'application/x-www-form-urlencoded',
        ],
        'visualizeRecipeEquipmentByID' => [
            'application/json',
        ],
        'visualizeRecipeIngredientsByID' => [
            'application/json',
        ],
        'visualizeRecipeNutrition' => [
            'application/x-www-form-urlencoded',
        ],
        'visualizeRecipeNutritionByID' => [
            'application/json',
        ],
        'visualizeRecipePriceBreakdownByID' => [
            'application/json',
        ],
        'visualizeRecipeTaste' => [
            'application/x-www-form-urlencoded',
        ],
        'visualizeRecipeTasteByID' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation analyzeARecipeSearchQuery
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeARecipeSearchQuery'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response
     */
    public function analyzeARecipeSearchQuery($q, string $contentType = self::contentTypes['analyzeARecipeSearchQuery'][0])
    {
        list($response) = $this->analyzeARecipeSearchQueryWithHttpInfo($q, $contentType);
        return $response;
    }

    /**
     * Operation analyzeARecipeSearchQueryWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeARecipeSearchQuery'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeARecipeSearchQueryWithHttpInfo($q, string $contentType = self::contentTypes['analyzeARecipeSearchQuery'][0])
    {
        $request = $this->analyzeARecipeSearchQueryRequest($q, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeARecipeSearchQueryAsync
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeARecipeSearchQuery'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsync($q, string $contentType = self::contentTypes['analyzeARecipeSearchQuery'][0])
    {
        return $this->analyzeARecipeSearchQueryAsyncWithHttpInfo($q, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeARecipeSearchQueryAsyncWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeARecipeSearchQuery'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsyncWithHttpInfo($q, string $contentType = self::contentTypes['analyzeARecipeSearchQuery'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AnalyzeARecipeSearchQuery200Response';
        $request = $this->analyzeARecipeSearchQueryRequest($q, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeARecipeSearchQuery'
     *
     * @param  string $q The recipe search query. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeARecipeSearchQuery'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function analyzeARecipeSearchQueryRequest($q, string $contentType = self::contentTypes['analyzeARecipeSearchQuery'][0])
    {

        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling analyzeARecipeSearchQuery'
            );
        }


        $resourcePath = '/recipes/queries/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation analyzeRecipeInstructions
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response
     */
    public function analyzeRecipeInstructions($instructions, string $contentType = self::contentTypes['analyzeRecipeInstructions'][0])
    {
        list($response) = $this->analyzeRecipeInstructionsWithHttpInfo($instructions, $contentType);
        return $response;
    }

    /**
     * Operation analyzeRecipeInstructionsWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeRecipeInstructionsWithHttpInfo($instructions, string $contentType = self::contentTypes['analyzeRecipeInstructions'][0])
    {
        $request = $this->analyzeRecipeInstructionsRequest($instructions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeRecipeInstructionsAsync
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsync($instructions, string $contentType = self::contentTypes['analyzeRecipeInstructions'][0])
    {
        return $this->analyzeRecipeInstructionsAsyncWithHttpInfo($instructions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeRecipeInstructionsAsyncWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsyncWithHttpInfo($instructions, string $contentType = self::contentTypes['analyzeRecipeInstructions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AnalyzeRecipeInstructions200Response';
        $request = $this->analyzeRecipeInstructionsRequest($instructions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeRecipeInstructions'
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function analyzeRecipeInstructionsRequest($instructions, string $contentType = self::contentTypes['analyzeRecipeInstructions'][0])
    {

        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling analyzeRecipeInstructions'
            );
        }


        $resourcePath = '/recipes/analyzeInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteRecipeSearch
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteRecipeSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[]
     */
    public function autocompleteRecipeSearch($query = null, $number = 10, string $contentType = self::contentTypes['autocompleteRecipeSearch'][0])
    {
        list($response) = $this->autocompleteRecipeSearchWithHttpInfo($query, $number, $contentType);
        return $response;
    }

    /**
     * Operation autocompleteRecipeSearchWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteRecipeSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteRecipeSearchWithHttpInfo($query = null, $number = 10, string $contentType = self::contentTypes['autocompleteRecipeSearch'][0])
    {
        $request = $this->autocompleteRecipeSearchRequest($query, $number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteRecipeSearchAsync
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteRecipeSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsync($query = null, $number = 10, string $contentType = self::contentTypes['autocompleteRecipeSearch'][0])
    {
        return $this->autocompleteRecipeSearchAsyncWithHttpInfo($query, $number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteRecipeSearchAsyncWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteRecipeSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsyncWithHttpInfo($query = null, $number = 10, string $contentType = self::contentTypes['autocompleteRecipeSearch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AutocompleteRecipeSearch200ResponseInner[]';
        $request = $this->autocompleteRecipeSearchRequest($query, $number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteRecipeSearch'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autocompleteRecipeSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autocompleteRecipeSearchRequest($query = null, $number = 10, string $contentType = self::contentTypes['autocompleteRecipeSearch'][0])
    {


        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.autocompleteRecipeSearch, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.autocompleteRecipeSearch, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/recipes/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyCuisine
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyCuisine'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClassifyCuisine200Response
     */
    public function classifyCuisine($title, $ingredient_list, $language = null, string $contentType = self::contentTypes['classifyCuisine'][0])
    {
        list($response) = $this->classifyCuisineWithHttpInfo($title, $ingredient_list, $language, $contentType);
        return $response;
    }

    /**
     * Operation classifyCuisineWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyCuisine'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClassifyCuisine200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyCuisineWithHttpInfo($title, $ingredient_list, $language = null, string $contentType = self::contentTypes['classifyCuisine'][0])
    {
        $request = $this->classifyCuisineRequest($title, $ingredient_list, $language, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ClassifyCuisine200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ClassifyCuisine200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ClassifyCuisine200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ClassifyCuisine200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClassifyCuisine200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyCuisineAsync
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyCuisine'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsync($title, $ingredient_list, $language = null, string $contentType = self::contentTypes['classifyCuisine'][0])
    {
        return $this->classifyCuisineAsyncWithHttpInfo($title, $ingredient_list, $language, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyCuisineAsyncWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyCuisine'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsyncWithHttpInfo($title, $ingredient_list, $language = null, string $contentType = self::contentTypes['classifyCuisine'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClassifyCuisine200Response';
        $request = $this->classifyCuisineRequest($title, $ingredient_list, $language, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyCuisine'
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['classifyCuisine'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function classifyCuisineRequest($title, $ingredient_list, $language = null, string $contentType = self::contentTypes['classifyCuisine'][0])
    {

        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling classifyCuisine'
            );
        }

        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling classifyCuisine'
            );
        }



        $resourcePath = '/recipes/cuisine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);



        // form params
        if ($title !== null) {
            $formParams['title'] = ObjectSerializer::toFormValue($title);
        }
        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation computeGlycemicLoad
     *
     * Compute Glycemic Load
     *
     * @param  \OpenAPI\Client\Model\ComputeGlycemicLoadRequest $compute_glycemic_load_request compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['computeGlycemicLoad'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComputeGlycemicLoad200Response
     */
    public function computeGlycemicLoad($compute_glycemic_load_request, $language = null, string $contentType = self::contentTypes['computeGlycemicLoad'][0])
    {
        list($response) = $this->computeGlycemicLoadWithHttpInfo($compute_glycemic_load_request, $language, $contentType);
        return $response;
    }

    /**
     * Operation computeGlycemicLoadWithHttpInfo
     *
     * Compute Glycemic Load
     *
     * @param  \OpenAPI\Client\Model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['computeGlycemicLoad'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComputeGlycemicLoad200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function computeGlycemicLoadWithHttpInfo($compute_glycemic_load_request, $language = null, string $contentType = self::contentTypes['computeGlycemicLoad'][0])
    {
        $request = $this->computeGlycemicLoadRequest($compute_glycemic_load_request, $language, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComputeGlycemicLoad200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComputeGlycemicLoad200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComputeGlycemicLoad200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComputeGlycemicLoad200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComputeGlycemicLoad200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation computeGlycemicLoadAsync
     *
     * Compute Glycemic Load
     *
     * @param  \OpenAPI\Client\Model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['computeGlycemicLoad'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeGlycemicLoadAsync($compute_glycemic_load_request, $language = null, string $contentType = self::contentTypes['computeGlycemicLoad'][0])
    {
        return $this->computeGlycemicLoadAsyncWithHttpInfo($compute_glycemic_load_request, $language, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation computeGlycemicLoadAsyncWithHttpInfo
     *
     * Compute Glycemic Load
     *
     * @param  \OpenAPI\Client\Model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['computeGlycemicLoad'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeGlycemicLoadAsyncWithHttpInfo($compute_glycemic_load_request, $language = null, string $contentType = self::contentTypes['computeGlycemicLoad'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComputeGlycemicLoad200Response';
        $request = $this->computeGlycemicLoadRequest($compute_glycemic_load_request, $language, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'computeGlycemicLoad'
     *
     * @param  \OpenAPI\Client\Model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['computeGlycemicLoad'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function computeGlycemicLoadRequest($compute_glycemic_load_request, $language = null, string $contentType = self::contentTypes['computeGlycemicLoad'][0])
    {

        // verify the required parameter 'compute_glycemic_load_request' is set
        if ($compute_glycemic_load_request === null || (is_array($compute_glycemic_load_request) && count($compute_glycemic_load_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $compute_glycemic_load_request when calling computeGlycemicLoad'
            );
        }



        $resourcePath = '/food/ingredients/glycemicLoad';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($compute_glycemic_load_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($compute_glycemic_load_request));
            } else {
                $httpBody = $compute_glycemic_load_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation convertAmounts
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['convertAmounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConvertAmounts200Response
     */
    public function convertAmounts($ingredient_name, $source_amount, $source_unit, $target_unit, string $contentType = self::contentTypes['convertAmounts'][0])
    {
        list($response) = $this->convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit, $contentType);
        return $response;
    }

    /**
     * Operation convertAmountsWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['convertAmounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConvertAmounts200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit, string $contentType = self::contentTypes['convertAmounts'][0])
    {
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConvertAmounts200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConvertAmounts200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConvertAmounts200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ConvertAmounts200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConvertAmounts200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation convertAmountsAsync
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['convertAmounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsync($ingredient_name, $source_amount, $source_unit, $target_unit, string $contentType = self::contentTypes['convertAmounts'][0])
    {
        return $this->convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation convertAmountsAsyncWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['convertAmounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit, string $contentType = self::contentTypes['convertAmounts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConvertAmounts200Response';
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'convertAmounts'
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['convertAmounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit, string $contentType = self::contentTypes['convertAmounts'][0])
    {

        // verify the required parameter 'ingredient_name' is set
        if ($ingredient_name === null || (is_array($ingredient_name) && count($ingredient_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_name when calling convertAmounts'
            );
        }

        // verify the required parameter 'source_amount' is set
        if ($source_amount === null || (is_array($source_amount) && count($source_amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_amount when calling convertAmounts'
            );
        }

        // verify the required parameter 'source_unit' is set
        if ($source_unit === null || (is_array($source_unit) && count($source_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_unit when calling convertAmounts'
            );
        }

        // verify the required parameter 'target_unit' is set
        if ($target_unit === null || (is_array($target_unit) && count($target_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_unit when calling convertAmounts'
            );
        }


        $resourcePath = '/recipes/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ingredient_name,
            'ingredientName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $source_amount,
            'sourceAmount', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $source_unit,
            'sourceUnit', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_unit,
            'targetUnit', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRecipeCard
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (&#39;ellipseMask&#39;, &#39;diamondMask&#39;, &#39;starMask&#39;, &#39;heartMask&#39;, &#39;potMask&#39;, &#39;fishMask&#39;). (required)
     * @param  string $background_image The background image (&#39;none&#39;, &#39;background1&#39;, or &#39;background2&#39;). (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (optional)
     * @param  string $image_url If you do not sent a binary image you can also pass the image URL. (optional)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreateRecipeCard200Response
     */
    public function createRecipeCard($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image = null, $image_url = null, $author = null, $background_color = null, $font_color = null, $source = null, string $contentType = self::contentTypes['createRecipeCard'][0])
    {
        list($response) = $this->createRecipeCardWithHttpInfo($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image, $image_url, $author, $background_color, $font_color, $source, $contentType);
        return $response;
    }

    /**
     * Operation createRecipeCardWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (&#39;ellipseMask&#39;, &#39;diamondMask&#39;, &#39;starMask&#39;, &#39;heartMask&#39;, &#39;potMask&#39;, &#39;fishMask&#39;). (required)
     * @param  string $background_image The background image (&#39;none&#39;, &#39;background1&#39;, or &#39;background2&#39;). (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (optional)
     * @param  string $image_url If you do not sent a binary image you can also pass the image URL. (optional)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreateRecipeCard200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRecipeCardWithHttpInfo($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image = null, $image_url = null, $author = null, $background_color = null, $font_color = null, $source = null, string $contentType = self::contentTypes['createRecipeCard'][0])
    {
        $request = $this->createRecipeCardRequest($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image, $image_url, $author, $background_color, $font_color, $source, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CreateRecipeCard200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CreateRecipeCard200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CreateRecipeCard200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CreateRecipeCard200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateRecipeCard200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRecipeCardAsync
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (&#39;ellipseMask&#39;, &#39;diamondMask&#39;, &#39;starMask&#39;, &#39;heartMask&#39;, &#39;potMask&#39;, &#39;fishMask&#39;). (required)
     * @param  string $background_image The background image (&#39;none&#39;, &#39;background1&#39;, or &#39;background2&#39;). (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (optional)
     * @param  string $image_url If you do not sent a binary image you can also pass the image URL. (optional)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsync($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image = null, $image_url = null, $author = null, $background_color = null, $font_color = null, $source = null, string $contentType = self::contentTypes['createRecipeCard'][0])
    {
        return $this->createRecipeCardAsyncWithHttpInfo($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image, $image_url, $author, $background_color, $font_color, $source, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRecipeCardAsyncWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (&#39;ellipseMask&#39;, &#39;diamondMask&#39;, &#39;starMask&#39;, &#39;heartMask&#39;, &#39;potMask&#39;, &#39;fishMask&#39;). (required)
     * @param  string $background_image The background image (&#39;none&#39;, &#39;background1&#39;, or &#39;background2&#39;). (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (optional)
     * @param  string $image_url If you do not sent a binary image you can also pass the image URL. (optional)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsyncWithHttpInfo($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image = null, $image_url = null, $author = null, $background_color = null, $font_color = null, $source = null, string $contentType = self::contentTypes['createRecipeCard'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CreateRecipeCard200Response';
        $request = $this->createRecipeCardRequest($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image, $image_url, $author, $background_color, $font_color, $source, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRecipeCard'
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings the recipe makes. (required)
     * @param  string $mask The mask to put over the recipe image (&#39;ellipseMask&#39;, &#39;diamondMask&#39;, &#39;starMask&#39;, &#39;heartMask&#39;, &#39;potMask&#39;, &#39;fishMask&#39;). (required)
     * @param  string $background_image The background image (&#39;none&#39;, &#39;background1&#39;, or &#39;background2&#39;). (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (optional)
     * @param  string $image_url If you do not sent a binary image you can also pass the image URL. (optional)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRecipeCardRequest($title, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $image = null, $image_url = null, $author = null, $background_color = null, $font_color = null, $source = null, string $contentType = self::contentTypes['createRecipeCard'][0])
    {

        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling createRecipeCard'
            );
        }

        // verify the required parameter 'ingredients' is set
        if ($ingredients === null || (is_array($ingredients) && count($ingredients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredients when calling createRecipeCard'
            );
        }

        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling createRecipeCard'
            );
        }

        // verify the required parameter 'ready_in_minutes' is set
        if ($ready_in_minutes === null || (is_array($ready_in_minutes) && count($ready_in_minutes) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ready_in_minutes when calling createRecipeCard'
            );
        }

        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling createRecipeCard'
            );
        }

        // verify the required parameter 'mask' is set
        if ($mask === null || (is_array($mask) && count($mask) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mask when calling createRecipeCard'
            );
        }

        // verify the required parameter 'background_image' is set
        if ($background_image === null || (is_array($background_image) && count($background_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $background_image when calling createRecipeCard'
            );
        }








        $resourcePath = '/recipes/visualizeRecipe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($title !== null) {
            $formParams['title'] = ObjectSerializer::toFormValue($title);
        }
        // form params
        if ($ingredients !== null) {
            $formParams['ingredients'] = ObjectSerializer::toFormValue($ingredients);
        }
        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }
        // form params
        if ($ready_in_minutes !== null) {
            $formParams['readyInMinutes'] = ObjectSerializer::toFormValue($ready_in_minutes);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($mask !== null) {
            $formParams['mask'] = ObjectSerializer::toFormValue($mask);
        }
        // form params
        if ($background_image !== null) {
            $formParams['backgroundImage'] = ObjectSerializer::toFormValue($background_image);
        }
        // form params
        if ($image !== null) {
            $multipart = true;
            $formParams['image'] = [];
            $paramFiles = is_array($image) ? $image : [$image];
            foreach ($paramFiles as $paramFile) {
                $formParams['image'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($image_url !== null) {
            $formParams['imageUrl'] = ObjectSerializer::toFormValue($image_url);
        }
        // form params
        if ($author !== null) {
            $formParams['author'] = ObjectSerializer::toFormValue($author);
        }
        // form params
        if ($background_color !== null) {
            $formParams['backgroundColor'] = ObjectSerializer::toFormValue($background_color);
        }
        // form params
        if ($font_color !== null) {
            $formParams['fontColor'] = ObjectSerializer::toFormValue($font_color);
        }
        // form params
        if ($source !== null) {
            $formParams['source'] = ObjectSerializer::toFormValue($source);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation equipmentByIDImage
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['equipmentByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function equipmentByIDImage($id, string $contentType = self::contentTypes['equipmentByIDImage'][0])
    {
        list($response) = $this->equipmentByIDImageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation equipmentByIDImageWithHttpInfo
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['equipmentByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function equipmentByIDImageWithHttpInfo($id, string $contentType = self::contentTypes['equipmentByIDImage'][0])
    {
        $request = $this->equipmentByIDImageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation equipmentByIDImageAsync
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['equipmentByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipmentByIDImageAsync($id, string $contentType = self::contentTypes['equipmentByIDImage'][0])
    {
        return $this->equipmentByIDImageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation equipmentByIDImageAsyncWithHttpInfo
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['equipmentByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipmentByIDImageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['equipmentByIDImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->equipmentByIDImageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'equipmentByIDImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['equipmentByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function equipmentByIDImageRequest($id, string $contentType = self::contentTypes['equipmentByIDImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling equipmentByIDImage'
            );
        }


        $resourcePath = '/recipes/{id}/equipmentWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractRecipeFromWebsite
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractRecipeFromWebsite'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipeInformation200Response
     */
    public function extractRecipeFromWebsite($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false, string $contentType = self::contentTypes['extractRecipeFromWebsite'][0])
    {
        list($response) = $this->extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction, $analyze, $include_nutrition, $include_taste, $contentType);
        return $response;
    }

    /**
     * Operation extractRecipeFromWebsiteWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractRecipeFromWebsite'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipeInformation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false, string $contentType = self::contentTypes['extractRecipeFromWebsite'][0])
    {
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction, $analyze, $include_nutrition, $include_taste, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipeInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipeInformation200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipeInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipeInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipeInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extractRecipeFromWebsiteAsync
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractRecipeFromWebsite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsync($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false, string $contentType = self::contentTypes['extractRecipeFromWebsite'][0])
    {
        return $this->extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction, $analyze, $include_nutrition, $include_taste, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractRecipeFromWebsiteAsyncWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractRecipeFromWebsite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false, string $contentType = self::contentTypes['extractRecipeFromWebsite'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipeInformation200Response';
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction, $analyze, $include_nutrition, $include_taste, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractRecipeFromWebsite'
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractRecipeFromWebsite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extractRecipeFromWebsiteRequest($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false, string $contentType = self::contentTypes['extractRecipeFromWebsite'][0])
    {

        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling extractRecipeFromWebsite'
            );
        }






        $resourcePath = '/recipes/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force_extraction,
            'forceExtraction', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $analyze,
            'analyze', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_taste,
            'includeTaste', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnalyzedRecipeInstructions
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalyzedRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response
     */
    public function getAnalyzedRecipeInstructions($id, $step_breakdown = null, string $contentType = self::contentTypes['getAnalyzedRecipeInstructions'][0])
    {
        list($response) = $this->getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown, $contentType);
        return $response;
    }

    /**
     * Operation getAnalyzedRecipeInstructionsWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalyzedRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown = null, string $contentType = self::contentTypes['getAnalyzedRecipeInstructions'][0])
    {
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsync
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalyzedRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsync($id, $step_breakdown = null, string $contentType = self::contentTypes['getAnalyzedRecipeInstructions'][0])
    {
        return $this->getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsyncWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalyzedRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown = null, string $contentType = self::contentTypes['getAnalyzedRecipeInstructions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAnalyzedRecipeInstructions200Response';
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnalyzedRecipeInstructions'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalyzedRecipeInstructions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnalyzedRecipeInstructionsRequest($id, $step_breakdown = null, string $contentType = self::contentTypes['getAnalyzedRecipeInstructions'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAnalyzedRecipeInstructions'
            );
        }



        $resourcePath = '/recipes/{id}/analyzedInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $step_breakdown,
            'stepBreakdown', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRandomRecipes
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $include_tags A comma-separated list of tags that the random recipe(s) must adhere to. (optional)
     * @param  string $exclude_tags A comma-separated list of tags that the random recipe(s) must not adhere to. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRandomRecipes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRandomRecipes200Response
     */
    public function getRandomRecipes($limit_license = true, $include_nutrition = false, $include_tags = null, $exclude_tags = null, $number = 10, string $contentType = self::contentTypes['getRandomRecipes'][0])
    {
        list($response) = $this->getRandomRecipesWithHttpInfo($limit_license, $include_nutrition, $include_tags, $exclude_tags, $number, $contentType);
        return $response;
    }

    /**
     * Operation getRandomRecipesWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $include_tags A comma-separated list of tags that the random recipe(s) must adhere to. (optional)
     * @param  string $exclude_tags A comma-separated list of tags that the random recipe(s) must not adhere to. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRandomRecipes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRandomRecipes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRandomRecipesWithHttpInfo($limit_license = true, $include_nutrition = false, $include_tags = null, $exclude_tags = null, $number = 10, string $contentType = self::contentTypes['getRandomRecipes'][0])
    {
        $request = $this->getRandomRecipesRequest($limit_license, $include_nutrition, $include_tags, $exclude_tags, $number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRandomRecipes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRandomRecipes200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRandomRecipes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRandomRecipes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRandomRecipes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRandomRecipesAsync
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $include_tags A comma-separated list of tags that the random recipe(s) must adhere to. (optional)
     * @param  string $exclude_tags A comma-separated list of tags that the random recipe(s) must not adhere to. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRandomRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsync($limit_license = true, $include_nutrition = false, $include_tags = null, $exclude_tags = null, $number = 10, string $contentType = self::contentTypes['getRandomRecipes'][0])
    {
        return $this->getRandomRecipesAsyncWithHttpInfo($limit_license, $include_nutrition, $include_tags, $exclude_tags, $number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRandomRecipesAsyncWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $include_tags A comma-separated list of tags that the random recipe(s) must adhere to. (optional)
     * @param  string $exclude_tags A comma-separated list of tags that the random recipe(s) must not adhere to. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRandomRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsyncWithHttpInfo($limit_license = true, $include_nutrition = false, $include_tags = null, $exclude_tags = null, $number = 10, string $contentType = self::contentTypes['getRandomRecipes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRandomRecipes200Response';
        $request = $this->getRandomRecipesRequest($limit_license, $include_nutrition, $include_tags, $exclude_tags, $number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRandomRecipes'
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $include_tags A comma-separated list of tags that the random recipe(s) must adhere to. (optional)
     * @param  string $exclude_tags A comma-separated list of tags that the random recipe(s) must not adhere to. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRandomRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRandomRecipesRequest($limit_license = true, $include_nutrition = false, $include_tags = null, $exclude_tags = null, $number = 10, string $contentType = self::contentTypes['getRandomRecipes'][0])
    {





        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getRandomRecipes, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getRandomRecipes, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/recipes/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_tags,
            'include-tags', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_tags,
            'exclude-tags', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeEquipmentByID
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipeEquipmentByID200Response
     */
    public function getRecipeEquipmentByID($id, string $contentType = self::contentTypes['getRecipeEquipmentByID'][0])
    {
        list($response) = $this->getRecipeEquipmentByIDWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getRecipeEquipmentByIDWithHttpInfo
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipeEquipmentByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeEquipmentByIDWithHttpInfo($id, string $contentType = self::contentTypes['getRecipeEquipmentByID'][0])
    {
        $request = $this->getRecipeEquipmentByIDRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipeEquipmentByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipeEquipmentByID200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipeEquipmentByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipeEquipmentByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipeEquipmentByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeEquipmentByIDAsync
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsync($id, string $contentType = self::contentTypes['getRecipeEquipmentByID'][0])
    {
        return $this->getRecipeEquipmentByIDAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getRecipeEquipmentByID'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipeEquipmentByID200Response';
        $request = $this->getRecipeEquipmentByIDRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeEquipmentByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeEquipmentByIDRequest($id, string $contentType = self::contentTypes['getRecipeEquipmentByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeEquipmentByID'
            );
        }


        $resourcePath = '/recipes/{id}/equipmentWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformation
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipeInformation200Response
     */
    public function getRecipeInformation($id, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformation'][0])
    {
        list($response) = $this->getRecipeInformationWithHttpInfo($id, $include_nutrition, $contentType);
        return $response;
    }

    /**
     * Operation getRecipeInformationWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipeInformation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationWithHttpInfo($id, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformation'][0])
    {
        $request = $this->getRecipeInformationRequest($id, $include_nutrition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipeInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipeInformation200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipeInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipeInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipeInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationAsync
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsync($id, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformation'][0])
    {
        return $this->getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationAsyncWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformation'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipeInformation200Response';
        $request = $this->getRecipeInformationRequest($id, $include_nutrition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformation'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeInformationRequest($id, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformation'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeInformation'
            );
        }



        $resourcePath = '/recipes/{id}/information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformationBulk
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformationBulk'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[]
     */
    public function getRecipeInformationBulk($ids, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformationBulk'][0])
    {
        list($response) = $this->getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition, $contentType);
        return $response;
    }

    /**
     * Operation getRecipeInformationBulkWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformationBulk'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformationBulk'][0])
    {
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationBulkAsync
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformationBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsync($ids, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformationBulk'][0])
    {
        return $this->getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationBulkAsyncWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformationBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformationBulk'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipeInformationBulk200ResponseInner[]';
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformationBulk'
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeInformationBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeInformationBulkRequest($ids, $include_nutrition = false, string $contentType = self::contentTypes['getRecipeInformationBulk'][0])
    {

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getRecipeInformationBulk'
            );
        }



        $resourcePath = '/recipes/informationBulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeIngredientsByID
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipeIngredientsByID200Response
     */
    public function getRecipeIngredientsByID($id, string $contentType = self::contentTypes['getRecipeIngredientsByID'][0])
    {
        list($response) = $this->getRecipeIngredientsByIDWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getRecipeIngredientsByIDWithHttpInfo
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipeIngredientsByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeIngredientsByIDWithHttpInfo($id, string $contentType = self::contentTypes['getRecipeIngredientsByID'][0])
    {
        $request = $this->getRecipeIngredientsByIDRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipeIngredientsByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipeIngredientsByID200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipeIngredientsByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipeIngredientsByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipeIngredientsByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeIngredientsByIDAsync
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsync($id, string $contentType = self::contentTypes['getRecipeIngredientsByID'][0])
    {
        return $this->getRecipeIngredientsByIDAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getRecipeIngredientsByID'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipeIngredientsByID200Response';
        $request = $this->getRecipeIngredientsByIDRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeIngredientsByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeIngredientsByIDRequest($id, string $contentType = self::contentTypes['getRecipeIngredientsByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeIngredientsByID'
            );
        }


        $resourcePath = '/recipes/{id}/ingredientWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeNutritionWidgetByID
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeNutritionWidgetByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response
     */
    public function getRecipeNutritionWidgetByID($id, string $contentType = self::contentTypes['getRecipeNutritionWidgetByID'][0])
    {
        list($response) = $this->getRecipeNutritionWidgetByIDWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getRecipeNutritionWidgetByIDWithHttpInfo
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeNutritionWidgetByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeNutritionWidgetByIDWithHttpInfo($id, string $contentType = self::contentTypes['getRecipeNutritionWidgetByID'][0])
    {
        $request = $this->getRecipeNutritionWidgetByIDRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeNutritionWidgetByIDAsync
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeNutritionWidgetByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionWidgetByIDAsync($id, string $contentType = self::contentTypes['getRecipeNutritionWidgetByID'][0])
    {
        return $this->getRecipeNutritionWidgetByIDAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeNutritionWidgetByIDAsyncWithHttpInfo
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeNutritionWidgetByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionWidgetByIDAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getRecipeNutritionWidgetByID'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipeNutritionWidgetByID200Response';
        $request = $this->getRecipeNutritionWidgetByIDRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeNutritionWidgetByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeNutritionWidgetByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeNutritionWidgetByIDRequest($id, string $contentType = self::contentTypes['getRecipeNutritionWidgetByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeNutritionWidgetByID'
            );
        }


        $resourcePath = '/recipes/{id}/nutritionWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipePriceBreakdownByID
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response
     */
    public function getRecipePriceBreakdownByID($id, string $contentType = self::contentTypes['getRecipePriceBreakdownByID'][0])
    {
        list($response) = $this->getRecipePriceBreakdownByIDWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getRecipePriceBreakdownByIDWithHttpInfo
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipePriceBreakdownByIDWithHttpInfo($id, string $contentType = self::contentTypes['getRecipePriceBreakdownByID'][0])
    {
        $request = $this->getRecipePriceBreakdownByIDRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsync
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsync($id, string $contentType = self::contentTypes['getRecipePriceBreakdownByID'][0])
    {
        return $this->getRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getRecipePriceBreakdownByID'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipePriceBreakdownByID200Response';
        $request = $this->getRecipePriceBreakdownByIDRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipePriceBreakdownByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipePriceBreakdownByIDRequest($id, string $contentType = self::contentTypes['getRecipePriceBreakdownByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipePriceBreakdownByID'
            );
        }


        $resourcePath = '/recipes/{id}/priceBreakdownWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeTasteByID
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetRecipeTasteByID200Response
     */
    public function getRecipeTasteByID($id, $normalize = true, string $contentType = self::contentTypes['getRecipeTasteByID'][0])
    {
        list($response) = $this->getRecipeTasteByIDWithHttpInfo($id, $normalize, $contentType);
        return $response;
    }

    /**
     * Operation getRecipeTasteByIDWithHttpInfo
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetRecipeTasteByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeTasteByIDWithHttpInfo($id, $normalize = true, string $contentType = self::contentTypes['getRecipeTasteByID'][0])
    {
        $request = $this->getRecipeTasteByIDRequest($id, $normalize, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetRecipeTasteByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetRecipeTasteByID200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetRecipeTasteByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetRecipeTasteByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetRecipeTasteByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeTasteByIDAsync
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeTasteByIDAsync($id, $normalize = true, string $contentType = self::contentTypes['getRecipeTasteByID'][0])
    {
        return $this->getRecipeTasteByIDAsyncWithHttpInfo($id, $normalize, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeTasteByIDAsyncWithHttpInfo
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeTasteByIDAsyncWithHttpInfo($id, $normalize = true, string $contentType = self::contentTypes['getRecipeTasteByID'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetRecipeTasteByID200Response';
        $request = $this->getRecipeTasteByIDRequest($id, $normalize, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeTasteByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeTasteByIDRequest($id, $normalize = true, string $contentType = self::contentTypes['getRecipeTasteByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeTasteByID'
            );
        }



        $resourcePath = '/recipes/{id}/tasteWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $normalize,
            'normalize', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSimilarRecipes
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSimilarRecipes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[]
     */
    public function getSimilarRecipes($id, $number = 10, $limit_license = true, string $contentType = self::contentTypes['getSimilarRecipes'][0])
    {
        list($response) = $this->getSimilarRecipesWithHttpInfo($id, $number, $limit_license, $contentType);
        return $response;
    }

    /**
     * Operation getSimilarRecipesWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSimilarRecipes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSimilarRecipesWithHttpInfo($id, $number = 10, $limit_license = true, string $contentType = self::contentTypes['getSimilarRecipes'][0])
    {
        $request = $this->getSimilarRecipesRequest($id, $number, $limit_license, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSimilarRecipesAsync
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSimilarRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsync($id, $number = 10, $limit_license = true, string $contentType = self::contentTypes['getSimilarRecipes'][0])
    {
        return $this->getSimilarRecipesAsyncWithHttpInfo($id, $number, $limit_license, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSimilarRecipesAsyncWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSimilarRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsyncWithHttpInfo($id, $number = 10, $limit_license = true, string $contentType = self::contentTypes['getSimilarRecipes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetSimilarRecipes200ResponseInner[]';
        $request = $this->getSimilarRecipesRequest($id, $number, $limit_license, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSimilarRecipes'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSimilarRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSimilarRecipesRequest($id, $number = 10, $limit_license = true, string $contentType = self::contentTypes['getSimilarRecipes'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSimilarRecipes'
            );
        }

        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getSimilarRecipes, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getSimilarRecipes, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/recipes/{id}/similar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation guessNutritionByDishName
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['guessNutritionByDishName'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuessNutritionByDishName200Response
     */
    public function guessNutritionByDishName($title, string $contentType = self::contentTypes['guessNutritionByDishName'][0])
    {
        list($response) = $this->guessNutritionByDishNameWithHttpInfo($title, $contentType);
        return $response;
    }

    /**
     * Operation guessNutritionByDishNameWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['guessNutritionByDishName'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuessNutritionByDishName200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function guessNutritionByDishNameWithHttpInfo($title, string $contentType = self::contentTypes['guessNutritionByDishName'][0])
    {
        $request = $this->guessNutritionByDishNameRequest($title, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuessNutritionByDishName200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuessNutritionByDishName200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuessNutritionByDishName200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GuessNutritionByDishName200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuessNutritionByDishName200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation guessNutritionByDishNameAsync
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['guessNutritionByDishName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsync($title, string $contentType = self::contentTypes['guessNutritionByDishName'][0])
    {
        return $this->guessNutritionByDishNameAsyncWithHttpInfo($title, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation guessNutritionByDishNameAsyncWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['guessNutritionByDishName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsyncWithHttpInfo($title, string $contentType = self::contentTypes['guessNutritionByDishName'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GuessNutritionByDishName200Response';
        $request = $this->guessNutritionByDishNameRequest($title, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'guessNutritionByDishName'
     *
     * @param  string $title The title of the dish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['guessNutritionByDishName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function guessNutritionByDishNameRequest($title, string $contentType = self::contentTypes['guessNutritionByDishName'][0])
    {

        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling guessNutritionByDishName'
            );
        }


        $resourcePath = '/recipes/guessNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseIngredients
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $include_nutrition include_nutrition (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseIngredients'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ParseIngredients200ResponseInner[]
     */
    public function parseIngredients($ingredient_list, $servings, $language = null, $include_nutrition = null, string $contentType = self::contentTypes['parseIngredients'][0])
    {
        list($response) = $this->parseIngredientsWithHttpInfo($ingredient_list, $servings, $language, $include_nutrition, $contentType);
        return $response;
    }

    /**
     * Operation parseIngredientsWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $include_nutrition (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseIngredients'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ParseIngredients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function parseIngredientsWithHttpInfo($ingredient_list, $servings, $language = null, $include_nutrition = null, string $contentType = self::contentTypes['parseIngredients'][0])
    {
        $request = $this->parseIngredientsRequest($ingredient_list, $servings, $language, $include_nutrition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ParseIngredients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ParseIngredients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ParseIngredients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ParseIngredients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ParseIngredients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseIngredientsAsync
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $include_nutrition (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseIngredients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsync($ingredient_list, $servings, $language = null, $include_nutrition = null, string $contentType = self::contentTypes['parseIngredients'][0])
    {
        return $this->parseIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $language, $include_nutrition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseIngredientsAsyncWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $include_nutrition (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseIngredients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $language = null, $include_nutrition = null, string $contentType = self::contentTypes['parseIngredients'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ParseIngredients200ResponseInner[]';
        $request = $this->parseIngredientsRequest($ingredient_list, $servings, $language, $include_nutrition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseIngredients'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $include_nutrition (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseIngredients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseIngredientsRequest($ingredient_list, $servings, $language = null, $include_nutrition = null, string $contentType = self::contentTypes['parseIngredients'][0])
    {

        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling parseIngredients'
            );
        }

        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling parseIngredients'
            );
        }




        $resourcePath = '/recipes/parseIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($include_nutrition !== null) {
            $formParams['includeNutrition'] = ObjectSerializer::toFormValue($include_nutrition);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation priceBreakdownByIDImage
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceBreakdownByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function priceBreakdownByIDImage($id, string $contentType = self::contentTypes['priceBreakdownByIDImage'][0])
    {
        list($response) = $this->priceBreakdownByIDImageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation priceBreakdownByIDImageWithHttpInfo
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceBreakdownByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function priceBreakdownByIDImageWithHttpInfo($id, string $contentType = self::contentTypes['priceBreakdownByIDImage'][0])
    {
        $request = $this->priceBreakdownByIDImageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation priceBreakdownByIDImageAsync
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceBreakdownByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceBreakdownByIDImageAsync($id, string $contentType = self::contentTypes['priceBreakdownByIDImage'][0])
    {
        return $this->priceBreakdownByIDImageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation priceBreakdownByIDImageAsyncWithHttpInfo
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceBreakdownByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceBreakdownByIDImageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['priceBreakdownByIDImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->priceBreakdownByIDImageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'priceBreakdownByIDImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceBreakdownByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function priceBreakdownByIDImageRequest($id, string $contentType = self::contentTypes['priceBreakdownByIDImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling priceBreakdownByIDImage'
            );
        }


        $resourcePath = '/recipes/{id}/priceBreakdownWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickAnswer
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickAnswer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\QuickAnswer200Response
     */
    public function quickAnswer($q, string $contentType = self::contentTypes['quickAnswer'][0])
    {
        list($response) = $this->quickAnswerWithHttpInfo($q, $contentType);
        return $response;
    }

    /**
     * Operation quickAnswerWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickAnswer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\QuickAnswer200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickAnswerWithHttpInfo($q, string $contentType = self::contentTypes['quickAnswer'][0])
    {
        $request = $this->quickAnswerRequest($q, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\QuickAnswer200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\QuickAnswer200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\QuickAnswer200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\QuickAnswer200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\QuickAnswer200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quickAnswerAsync
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickAnswer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsync($q, string $contentType = self::contentTypes['quickAnswer'][0])
    {
        return $this->quickAnswerAsyncWithHttpInfo($q, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickAnswerAsyncWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickAnswer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsyncWithHttpInfo($q, string $contentType = self::contentTypes['quickAnswer'][0])
    {
        $returnType = '\OpenAPI\Client\Model\QuickAnswer200Response';
        $request = $this->quickAnswerRequest($q, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickAnswer'
     *
     * @param  string $q The nutrition related question. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['quickAnswer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function quickAnswerRequest($q, string $contentType = self::contentTypes['quickAnswer'][0])
    {

        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling quickAnswer'
            );
        }


        $resourcePath = '/recipes/quickAnswer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeNutritionByIDImage
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function recipeNutritionByIDImage($id, string $contentType = self::contentTypes['recipeNutritionByIDImage'][0])
    {
        list($response) = $this->recipeNutritionByIDImageWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation recipeNutritionByIDImageWithHttpInfo
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeNutritionByIDImageWithHttpInfo($id, string $contentType = self::contentTypes['recipeNutritionByIDImage'][0])
    {
        $request = $this->recipeNutritionByIDImageRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeNutritionByIDImageAsync
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionByIDImageAsync($id, string $contentType = self::contentTypes['recipeNutritionByIDImage'][0])
    {
        return $this->recipeNutritionByIDImageAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeNutritionByIDImageAsyncWithHttpInfo
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionByIDImageAsyncWithHttpInfo($id, string $contentType = self::contentTypes['recipeNutritionByIDImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->recipeNutritionByIDImageRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeNutritionByIDImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeNutritionByIDImageRequest($id, string $contentType = self::contentTypes['recipeNutritionByIDImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeNutritionByIDImage'
            );
        }


        $resourcePath = '/recipes/{id}/nutritionWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeNutritionLabelImage
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function recipeNutritionLabelImage($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelImage'][0])
    {
        list($response) = $this->recipeNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);
        return $response;
    }

    /**
     * Operation recipeNutritionLabelImageWithHttpInfo
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelImage'][0])
    {
        $request = $this->recipeNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeNutritionLabelImageAsync
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelImageAsync($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelImage'][0])
    {
        return $this->recipeNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeNutritionLabelImageAsyncWithHttpInfo
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->recipeNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeNutritionLabelImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeNutritionLabelImageRequest($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeNutritionLabelImage'
            );
        }





        $resourcePath = '/recipes/{id}/nutritionLabel.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeNutritionLabelWidget
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function recipeNutritionLabelWidget($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelWidget'][0])
    {
        list($response) = $this->recipeNutritionLabelWidgetWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);
        return $response;
    }

    /**
     * Operation recipeNutritionLabelWidgetWithHttpInfo
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeNutritionLabelWidgetWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelWidget'][0])
    {
        $request = $this->recipeNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeNutritionLabelWidgetAsync
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelWidgetAsync($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelWidget'][0])
    {
        return $this->recipeNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeNutritionLabelWidgetAsyncWithHttpInfo
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelWidget'][0])
    {
        $returnType = 'string';
        $request = $this->recipeNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeNutritionLabelWidget'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeNutritionLabelWidget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeNutritionLabelWidgetRequest($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null, string $contentType = self::contentTypes['recipeNutritionLabelWidget'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeNutritionLabelWidget'
            );
        }






        $resourcePath = '/recipes/{id}/nutritionLabel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeTasteByIDImage
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeTasteByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function recipeTasteByIDImage($id, $normalize = null, $rgb = null, string $contentType = self::contentTypes['recipeTasteByIDImage'][0])
    {
        list($response) = $this->recipeTasteByIDImageWithHttpInfo($id, $normalize, $rgb, $contentType);
        return $response;
    }

    /**
     * Operation recipeTasteByIDImageWithHttpInfo
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeTasteByIDImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeTasteByIDImageWithHttpInfo($id, $normalize = null, $rgb = null, string $contentType = self::contentTypes['recipeTasteByIDImage'][0])
    {
        $request = $this->recipeTasteByIDImageRequest($id, $normalize, $rgb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeTasteByIDImageAsync
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeTasteByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeTasteByIDImageAsync($id, $normalize = null, $rgb = null, string $contentType = self::contentTypes['recipeTasteByIDImage'][0])
    {
        return $this->recipeTasteByIDImageAsyncWithHttpInfo($id, $normalize, $rgb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeTasteByIDImageAsyncWithHttpInfo
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeTasteByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeTasteByIDImageAsyncWithHttpInfo($id, $normalize = null, $rgb = null, string $contentType = self::contentTypes['recipeTasteByIDImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->recipeTasteByIDImageRequest($id, $normalize, $rgb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeTasteByIDImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recipeTasteByIDImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeTasteByIDImageRequest($id, $normalize = null, $rgb = null, string $contentType = self::contentTypes['recipeTasteByIDImage'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeTasteByIDImage'
            );
        }




        $resourcePath = '/recipes/{id}/tasteWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $normalize,
            'normalize', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rgb,
            'rgb', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipes
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  float $min_servings The minimum amount of servings the recipe is for. (optional)
     * @param  float $max_servings The maximum amount of servings the recipe is for. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchRecipes200Response
     */
    public function searchRecipes($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $min_servings = null, $max_servings = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true, string $contentType = self::contentTypes['searchRecipes'][0])
    {
        list($response) = $this->searchRecipesWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $min_servings, $max_servings, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license, $contentType);
        return $response;
    }

    /**
     * Operation searchRecipesWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  float $min_servings The minimum amount of servings the recipe is for. (optional)
     * @param  float $max_servings The maximum amount of servings the recipe is for. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchRecipes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesWithHttpInfo($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $min_servings = null, $max_servings = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true, string $contentType = self::contentTypes['searchRecipes'][0])
    {
        $request = $this->searchRecipesRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $min_servings, $max_servings, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchRecipes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchRecipes200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchRecipes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SearchRecipes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchRecipes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesAsync
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  float $min_servings The minimum amount of servings the recipe is for. (optional)
     * @param  float $max_servings The maximum amount of servings the recipe is for. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsync($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $min_servings = null, $max_servings = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true, string $contentType = self::contentTypes['searchRecipes'][0])
    {
        return $this->searchRecipesAsyncWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $min_servings, $max_servings, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesAsyncWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  float $min_servings The minimum amount of servings the recipe is for. (optional)
     * @param  float $max_servings The maximum amount of servings the recipe is for. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsyncWithHttpInfo($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $min_servings = null, $max_servings = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true, string $contentType = self::contentTypes['searchRecipes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchRecipes200Response';
        $request = $this->searchRecipesRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $min_servings, $max_servings, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipes'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  float $min_servings The minimum amount of servings the recipe is for. (optional)
     * @param  float $max_servings The maximum amount of servings the recipe is for. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRecipesRequest($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $min_servings = null, $max_servings = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true, string $contentType = self::contentTypes['searchRecipes'][0])
    {
































































































        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipes, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipes, must be bigger than or equal to 0.');
        }
        
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipes, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipes, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/recipes/complexSearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cuisine,
            'cuisine', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_cuisine,
            'excludeCuisine', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $diet,
            'diet', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $intolerances,
            'intolerances', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $equipment,
            'equipment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_ingredients,
            'includeIngredients', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_ingredients,
            'excludeIngredients', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $instructions_required,
            'instructionsRequired', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_ingredients,
            'fillIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_recipe_information,
            'addRecipeInformation', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_recipe_nutrition,
            'addRecipeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $author,
            'author', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recipe_box_id,
            'recipeBoxId', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title_match,
            'titleMatch', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ready_time,
            'maxReadyTime', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_servings,
            'minServings', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_servings,
            'maxServings', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_pantry,
            'ignorePantry', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sortDirection', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_carbs,
            'minCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_carbs,
            'maxCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_protein,
            'minProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_protein,
            'maxProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calories,
            'minCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calories,
            'maxCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fat,
            'minFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fat,
            'maxFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_alcohol,
            'minAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_alcohol,
            'maxAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_caffeine,
            'minCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_caffeine,
            'maxCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_copper,
            'minCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_copper,
            'maxCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calcium,
            'minCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calcium,
            'maxCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_choline,
            'minCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_choline,
            'maxCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_cholesterol,
            'minCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_cholesterol,
            'maxCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fluoride,
            'minFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fluoride,
            'maxFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_saturated_fat,
            'minSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_saturated_fat,
            'maxSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_a,
            'minVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_a,
            'maxVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_c,
            'minVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_c,
            'maxVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_d,
            'minVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_d,
            'maxVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_e,
            'minVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_e,
            'maxVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_k,
            'minVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_k,
            'maxVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b1,
            'minVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b1,
            'maxVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b2,
            'minVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b2,
            'maxVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b5,
            'minVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b5,
            'maxVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b3,
            'minVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b3,
            'maxVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b6,
            'minVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b6,
            'maxVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b12,
            'minVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b12,
            'maxVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fiber,
            'minFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fiber,
            'maxFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folate,
            'minFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folate,
            'maxFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folic_acid,
            'minFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folic_acid,
            'maxFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iodine,
            'minIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iodine,
            'maxIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iron,
            'minIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iron,
            'maxIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_magnesium,
            'minMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_magnesium,
            'maxMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_manganese,
            'minManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_manganese,
            'maxManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_phosphorus,
            'minPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_phosphorus,
            'maxPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_potassium,
            'minPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_potassium,
            'maxPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_selenium,
            'minSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_selenium,
            'maxSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sodium,
            'minSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sodium,
            'maxSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sugar,
            'minSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sugar,
            'maxSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_zinc,
            'minZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_zinc,
            'maxZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByIngredients
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByIngredients'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[]
     */
    public function searchRecipesByIngredients($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false, string $contentType = self::contentTypes['searchRecipesByIngredients'][0])
    {
        list($response) = $this->searchRecipesByIngredientsWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry, $contentType);
        return $response;
    }

    /**
     * Operation searchRecipesByIngredientsWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByIngredients'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByIngredientsWithHttpInfo($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false, string $contentType = self::contentTypes['searchRecipesByIngredients'][0])
    {
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByIngredientsAsync
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByIngredients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsync($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false, string $contentType = self::contentTypes['searchRecipesByIngredients'][0])
    {
        return $this->searchRecipesByIngredientsAsyncWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByIngredientsAsyncWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByIngredients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsyncWithHttpInfo($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false, string $contentType = self::contentTypes['searchRecipesByIngredients'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchRecipesByIngredients200ResponseInner[]';
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByIngredients'
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByIngredients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRecipesByIngredientsRequest($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false, string $contentType = self::contentTypes['searchRecipesByIngredients'][0])
    {


        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByIngredients, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByIngredients, must be bigger than or equal to 1.');
        }
        




        $resourcePath = '/recipes/findByIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ingredients,
            'ingredients', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ranking,
            'ranking', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_pantry,
            'ignorePantry', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByNutrients
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByNutrients'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[]
     */
    public function searchRecipesByNutrients($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true, string $contentType = self::contentTypes['searchRecipesByNutrients'][0])
    {
        list($response) = $this->searchRecipesByNutrientsWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license, $contentType);
        return $response;
    }

    /**
     * Operation searchRecipesByNutrientsWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByNutrients'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByNutrientsWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true, string $contentType = self::contentTypes['searchRecipesByNutrients'][0])
    {
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByNutrientsAsync
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByNutrients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsync($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true, string $contentType = self::contentTypes['searchRecipesByNutrients'][0])
    {
        return $this->searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByNutrientsAsyncWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByNutrients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true, string $contentType = self::contentTypes['searchRecipesByNutrients'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchRecipesByNutrients200ResponseInner[]';
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByNutrients'
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRecipesByNutrients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRecipesByNutrientsRequest($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true, string $contentType = self::contentTypes['searchRecipesByNutrients'][0])
    {









































































        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipesByNutrients, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipesByNutrients, must be bigger than or equal to 0.');
        }
        
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByNutrients, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByNutrients, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/recipes/findByNutrients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_carbs,
            'minCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_carbs,
            'maxCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_protein,
            'minProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_protein,
            'maxProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calories,
            'minCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calories,
            'maxCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fat,
            'minFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fat,
            'maxFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_alcohol,
            'minAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_alcohol,
            'maxAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_caffeine,
            'minCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_caffeine,
            'maxCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_copper,
            'minCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_copper,
            'maxCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calcium,
            'minCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calcium,
            'maxCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_choline,
            'minCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_choline,
            'maxCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_cholesterol,
            'minCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_cholesterol,
            'maxCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fluoride,
            'minFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fluoride,
            'maxFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_saturated_fat,
            'minSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_saturated_fat,
            'maxSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_a,
            'minVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_a,
            'maxVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_c,
            'minVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_c,
            'maxVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_d,
            'minVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_d,
            'maxVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_e,
            'minVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_e,
            'maxVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_k,
            'minVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_k,
            'maxVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b1,
            'minVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b1,
            'maxVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b2,
            'minVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b2,
            'maxVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b5,
            'minVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b5,
            'maxVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b3,
            'minVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b3,
            'maxVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b6,
            'minVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b6,
            'maxVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b12,
            'minVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b12,
            'maxVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fiber,
            'minFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fiber,
            'maxFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folate,
            'minFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folate,
            'maxFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folic_acid,
            'minFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folic_acid,
            'maxFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iodine,
            'minIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iodine,
            'maxIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iron,
            'minIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iron,
            'maxIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_magnesium,
            'minMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_magnesium,
            'maxMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_manganese,
            'minManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_manganese,
            'maxManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_phosphorus,
            'minPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_phosphorus,
            'maxPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_potassium,
            'minPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_potassium,
            'maxPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_selenium,
            'minSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_selenium,
            'maxSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sodium,
            'minSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sodium,
            'maxSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sugar,
            'minSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sugar,
            'maxSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_zinc,
            'minZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_zinc,
            'maxZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $random,
            'random', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation summarizeRecipe
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeRecipe'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SummarizeRecipe200Response
     */
    public function summarizeRecipe($id, string $contentType = self::contentTypes['summarizeRecipe'][0])
    {
        list($response) = $this->summarizeRecipeWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation summarizeRecipeWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeRecipe'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SummarizeRecipe200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function summarizeRecipeWithHttpInfo($id, string $contentType = self::contentTypes['summarizeRecipe'][0])
    {
        $request = $this->summarizeRecipeRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SummarizeRecipe200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SummarizeRecipe200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SummarizeRecipe200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SummarizeRecipe200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SummarizeRecipe200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation summarizeRecipeAsync
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeRecipe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsync($id, string $contentType = self::contentTypes['summarizeRecipe'][0])
    {
        return $this->summarizeRecipeAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation summarizeRecipeAsyncWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeRecipe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsyncWithHttpInfo($id, string $contentType = self::contentTypes['summarizeRecipe'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SummarizeRecipe200Response';
        $request = $this->summarizeRecipeRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'summarizeRecipe'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeRecipe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function summarizeRecipeRequest($id, string $contentType = self::contentTypes['summarizeRecipe'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling summarizeRecipe'
            );
        }


        $resourcePath = '/recipes/{id}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeEquipment
     *
     * Equipment Widget
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the ingredients, either &#39;grid&#39; or &#39;list&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeEquipment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeEquipment($instructions, $view = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeEquipment'][0])
    {
        list($response) = $this->visualizeEquipmentWithHttpInfo($instructions, $view, $default_css, $show_backlink, $contentType);
        return $response;
    }

    /**
     * Operation visualizeEquipmentWithHttpInfo
     *
     * Equipment Widget
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the ingredients, either &#39;grid&#39; or &#39;list&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeEquipment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeEquipmentWithHttpInfo($instructions, $view = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeEquipment'][0])
    {
        $request = $this->visualizeEquipmentRequest($instructions, $view, $default_css, $show_backlink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeEquipmentAsync
     *
     * Equipment Widget
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the ingredients, either &#39;grid&#39; or &#39;list&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeEquipment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsync($instructions, $view = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeEquipment'][0])
    {
        return $this->visualizeEquipmentAsyncWithHttpInfo($instructions, $view, $default_css, $show_backlink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeEquipmentAsyncWithHttpInfo
     *
     * Equipment Widget
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the ingredients, either &#39;grid&#39; or &#39;list&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeEquipment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsyncWithHttpInfo($instructions, $view = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeEquipment'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeEquipmentRequest($instructions, $view, $default_css, $show_backlink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeEquipment'
     *
     * @param  string $instructions The recipe&#39;s instructions. (required)
     * @param  string $view How to visualize the ingredients, either &#39;grid&#39; or &#39;list&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeEquipment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeEquipmentRequest($instructions, $view = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeEquipment'][0])
    {

        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling visualizeEquipment'
            );
        }





        $resourcePath = '/recipes/visualizeEquipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }
        // form params
        if ($view !== null) {
            $formParams['view'] = ObjectSerializer::toFormValue($view);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizePriceBreakdown
     *
     * Price Breakdown Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizePriceBreakdown'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizePriceBreakdown($ingredient_list, $servings, $language = null, $mode = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizePriceBreakdown'][0])
    {
        list($response) = $this->visualizePriceBreakdownWithHttpInfo($ingredient_list, $servings, $language, $mode, $default_css, $show_backlink, $contentType);
        return $response;
    }

    /**
     * Operation visualizePriceBreakdownWithHttpInfo
     *
     * Price Breakdown Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizePriceBreakdown'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizePriceBreakdownWithHttpInfo($ingredient_list, $servings, $language = null, $mode = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizePriceBreakdown'][0])
    {
        $request = $this->visualizePriceBreakdownRequest($ingredient_list, $servings, $language, $mode, $default_css, $show_backlink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizePriceBreakdownAsync
     *
     * Price Breakdown Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizePriceBreakdown'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsync($ingredient_list, $servings, $language = null, $mode = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizePriceBreakdown'][0])
    {
        return $this->visualizePriceBreakdownAsyncWithHttpInfo($ingredient_list, $servings, $language, $mode, $default_css, $show_backlink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizePriceBreakdownAsyncWithHttpInfo
     *
     * Price Breakdown Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizePriceBreakdown'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsyncWithHttpInfo($ingredient_list, $servings, $language = null, $mode = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizePriceBreakdown'][0])
    {
        $returnType = 'string';
        $request = $this->visualizePriceBreakdownRequest($ingredient_list, $servings, $language, $mode, $default_css, $show_backlink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizePriceBreakdown'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizePriceBreakdown'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizePriceBreakdownRequest($ingredient_list, $servings, $language = null, $mode = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizePriceBreakdown'][0])
    {

        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizePriceBreakdown'
            );
        }

        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizePriceBreakdown'
            );
        }






        $resourcePath = '/recipes/visualizePriceEstimator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($mode !== null) {
            $formParams['mode'] = ObjectSerializer::toFormValue($mode);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeEquipmentByID
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeEquipmentByID($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeEquipmentByID'][0])
    {
        list($response) = $this->visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css, $contentType);
        return $response;
    }

    /**
     * Operation visualizeRecipeEquipmentByIDWithHttpInfo
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeEquipmentByID'][0])
    {
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsync
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsync($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeEquipmentByID'][0])
    {
        return $this->visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeEquipmentByID'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeEquipmentByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeEquipmentByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeEquipmentByIDRequest($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeEquipmentByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeEquipmentByID'
            );
        }



        $resourcePath = '/recipes/{id}/equipmentWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeIngredientsByID
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeIngredientsByID($id, $default_css = true, $measure = null, string $contentType = self::contentTypes['visualizeRecipeIngredientsByID'][0])
    {
        list($response) = $this->visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css, $measure, $contentType);
        return $response;
    }

    /**
     * Operation visualizeRecipeIngredientsByIDWithHttpInfo
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css = true, $measure = null, string $contentType = self::contentTypes['visualizeRecipeIngredientsByID'][0])
    {
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css, $measure, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsync
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsync($id, $default_css = true, $measure = null, string $contentType = self::contentTypes['visualizeRecipeIngredientsByID'][0])
    {
        return $this->visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css, $measure, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css = true, $measure = null, string $contentType = self::contentTypes['visualizeRecipeIngredientsByID'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css, $measure, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeIngredientsByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeIngredientsByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeIngredientsByIDRequest($id, $default_css = true, $measure = null, string $contentType = self::contentTypes['visualizeRecipeIngredientsByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeIngredientsByID'
            );
        }




        $resourcePath = '/recipes/{id}/ingredientWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $measure,
            'measure', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutrition
     *
     * Recipe Nutrition Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutrition'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutrition($ingredient_list, $servings, $language = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeRecipeNutrition'][0])
    {
        list($response) = $this->visualizeRecipeNutritionWithHttpInfo($ingredient_list, $servings, $language, $default_css, $show_backlink, $contentType);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionWithHttpInfo
     *
     * Recipe Nutrition Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutrition'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionWithHttpInfo($ingredient_list, $servings, $language = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeRecipeNutrition'][0])
    {
        $request = $this->visualizeRecipeNutritionRequest($ingredient_list, $servings, $language, $default_css, $show_backlink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionAsync
     *
     * Recipe Nutrition Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutrition'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsync($ingredient_list, $servings, $language = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeRecipeNutrition'][0])
    {
        return $this->visualizeRecipeNutritionAsyncWithHttpInfo($ingredient_list, $servings, $language, $default_css, $show_backlink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionAsyncWithHttpInfo
     *
     * Recipe Nutrition Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutrition'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsyncWithHttpInfo($ingredient_list, $servings, $language = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeRecipeNutrition'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionRequest($ingredient_list, $servings, $language, $default_css, $show_backlink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutrition'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutrition'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeNutritionRequest($ingredient_list, $servings, $language = null, $default_css = null, $show_backlink = null, string $contentType = self::contentTypes['visualizeRecipeNutrition'][0])
    {

        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeRecipeNutrition'
            );
        }

        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizeRecipeNutrition'
            );
        }





        $resourcePath = '/recipes/visualizeNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutritionByID
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutritionByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutritionByID($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeNutritionByID'][0])
    {
        list($response) = $this->visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css, $contentType);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionByIDWithHttpInfo
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutritionByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeNutritionByID'][0])
    {
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsync
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsync($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeNutritionByID'][0])
    {
        return $this->visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsyncWithHttpInfo
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeNutritionByID'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutritionByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeNutritionByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeNutritionByIDRequest($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipeNutritionByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeNutritionByID'
            );
        }



        $resourcePath = '/recipes/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByID
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipePriceBreakdownByID($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipePriceBreakdownByID'][0])
    {
        list($response) = $this->visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css, $contentType);
        return $response;
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDWithHttpInfo
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipePriceBreakdownByID'][0])
    {
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsync
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsync($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipePriceBreakdownByID'][0])
    {
        return $this->visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipePriceBreakdownByID'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipePriceBreakdownByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipePriceBreakdownByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipePriceBreakdownByIDRequest($id, $default_css = true, string $contentType = self::contentTypes['visualizeRecipePriceBreakdownByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipePriceBreakdownByID'
            );
        }



        $resourcePath = '/recipes/{id}/priceBreakdownWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeTaste
     *
     * Recipe Taste Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTaste'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeTaste($ingredient_list, $language = null, $normalize = null, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTaste'][0])
    {
        list($response) = $this->visualizeRecipeTasteWithHttpInfo($ingredient_list, $language, $normalize, $rgb, $contentType);
        return $response;
    }

    /**
     * Operation visualizeRecipeTasteWithHttpInfo
     *
     * Recipe Taste Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTaste'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeTasteWithHttpInfo($ingredient_list, $language = null, $normalize = null, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTaste'][0])
    {
        $request = $this->visualizeRecipeTasteRequest($ingredient_list, $language, $normalize, $rgb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeTasteAsync
     *
     * Recipe Taste Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTaste'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteAsync($ingredient_list, $language = null, $normalize = null, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTaste'][0])
    {
        return $this->visualizeRecipeTasteAsyncWithHttpInfo($ingredient_list, $language, $normalize, $rgb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeTasteAsyncWithHttpInfo
     *
     * Recipe Taste Widget
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTaste'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteAsyncWithHttpInfo($ingredient_list, $language = null, $normalize = null, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTaste'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeTasteRequest($ingredient_list, $language, $normalize, $rgb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeTaste'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTaste'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeTasteRequest($ingredient_list, $language = null, $normalize = null, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTaste'][0])
    {

        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeRecipeTaste'
            );
        }





        $resourcePath = '/recipes/visualizeTaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($normalize !== null) {
            $formParams['normalize'] = ObjectSerializer::toFormValue($normalize);
        }
        // form params
        if ($rgb !== null) {
            $formParams['rgb'] = ObjectSerializer::toFormValue($rgb);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeTasteByID
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeTasteByID($id, $normalize = true, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTasteByID'][0])
    {
        list($response) = $this->visualizeRecipeTasteByIDWithHttpInfo($id, $normalize, $rgb, $contentType);
        return $response;
    }

    /**
     * Operation visualizeRecipeTasteByIDWithHttpInfo
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeTasteByIDWithHttpInfo($id, $normalize = true, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTasteByID'][0])
    {
        $request = $this->visualizeRecipeTasteByIDRequest($id, $normalize, $rgb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeTasteByIDAsync
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteByIDAsync($id, $normalize = true, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTasteByID'][0])
    {
        return $this->visualizeRecipeTasteByIDAsyncWithHttpInfo($id, $normalize, $rgb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeTasteByIDAsyncWithHttpInfo
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteByIDAsyncWithHttpInfo($id, $normalize = true, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTasteByID'][0])
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeTasteByIDRequest($id, $normalize, $rgb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeTasteByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['visualizeRecipeTasteByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeTasteByIDRequest($id, $normalize = true, $rgb = null, string $contentType = self::contentTypes['visualizeRecipeTasteByID'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeTasteByID'
            );
        }




        $resourcePath = '/recipes/{id}/tasteWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $normalize,
            'normalize', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rgb,
            'rgb', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/html', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
