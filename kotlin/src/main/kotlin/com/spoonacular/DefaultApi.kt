/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.spoonacular

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.spoonacular.client.model.AnalyzeRecipeRequest
import com.spoonacular.client.model.SearchRestaurants200Response

import com.squareup.moshi.Json

import spoonacular.infrastructure.ApiClient
import spoonacular.infrastructure.ApiResponse
import spoonacular.infrastructure.ClientException
import spoonacular.infrastructure.ClientError
import spoonacular.infrastructure.ServerException
import spoonacular.infrastructure.ServerError
import spoonacular.infrastructure.MultiValueMap
import spoonacular.infrastructure.PartConfig
import spoonacular.infrastructure.RequestConfig
import spoonacular.infrastructure.RequestMethod
import spoonacular.infrastructure.ResponseType
import spoonacular.infrastructure.Success
import spoonacular.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.spoonacular.com")
        }
    }

    /**
     * Analyze Recipe
     * This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.
     * @param analyzeRecipeRequest Example request body.
     * @param language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param includeNutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param includeTaste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun analyzeRecipe(analyzeRecipeRequest: AnalyzeRecipeRequest, language: kotlin.String? = null, includeNutrition: kotlin.Boolean? = null, includeTaste: kotlin.Boolean? = null) : kotlin.Any {
        val localVarResponse = analyzeRecipeWithHttpInfo(analyzeRecipeRequest = analyzeRecipeRequest, language = language, includeNutrition = includeNutrition, includeTaste = includeTaste)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Analyze Recipe
     * This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.
     * @param analyzeRecipeRequest Example request body.
     * @param language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param includeNutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param includeTaste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun analyzeRecipeWithHttpInfo(analyzeRecipeRequest: AnalyzeRecipeRequest, language: kotlin.String?, includeNutrition: kotlin.Boolean?, includeTaste: kotlin.Boolean?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = analyzeRecipeRequestConfig(analyzeRecipeRequest = analyzeRecipeRequest, language = language, includeNutrition = includeNutrition, includeTaste = includeTaste)

        return request<AnalyzeRecipeRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation analyzeRecipe
     *
     * @param analyzeRecipeRequest Example request body.
     * @param language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param includeNutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param includeTaste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @return RequestConfig
     */
    fun analyzeRecipeRequestConfig(analyzeRecipeRequest: AnalyzeRecipeRequest, language: kotlin.String?, includeNutrition: kotlin.Boolean?, includeTaste: kotlin.Boolean?) : RequestConfig<AnalyzeRecipeRequest> {
        val localVariableBody = analyzeRecipeRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
                if (includeNutrition != null) {
                    put("includeNutrition", listOf(includeNutrition.toString()))
                }
                if (includeTaste != null) {
                    put("includeTaste", listOf(includeTaste.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/recipes/analyze",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Recipe Card
     * Generate a recipe card for a recipe.
     * @param id The recipe id.
     * @param mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param backgroundImage The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param backgroundColor The background color for the recipe card as a hex-string. (optional)
     * @param fontColor The font color for the recipe card as a hex-string. (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRecipeCardGet(id: java.math.BigDecimal, mask: kotlin.String? = null, backgroundImage: kotlin.String? = null, backgroundColor: kotlin.String? = null, fontColor: kotlin.String? = null) : kotlin.Any {
        val localVarResponse = createRecipeCardGetWithHttpInfo(id = id, mask = mask, backgroundImage = backgroundImage, backgroundColor = backgroundColor, fontColor = fontColor)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Recipe Card
     * Generate a recipe card for a recipe.
     * @param id The recipe id.
     * @param mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param backgroundImage The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param backgroundColor The background color for the recipe card as a hex-string. (optional)
     * @param fontColor The font color for the recipe card as a hex-string. (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRecipeCardGetWithHttpInfo(id: java.math.BigDecimal, mask: kotlin.String?, backgroundImage: kotlin.String?, backgroundColor: kotlin.String?, fontColor: kotlin.String?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = createRecipeCardGetRequestConfig(id = id, mask = mask, backgroundImage = backgroundImage, backgroundColor = backgroundColor, fontColor = fontColor)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRecipeCardGet
     *
     * @param id The recipe id.
     * @param mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param backgroundImage The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param backgroundColor The background color for the recipe card as a hex-string. (optional)
     * @param fontColor The font color for the recipe card as a hex-string. (optional)
     * @return RequestConfig
     */
    fun createRecipeCardGetRequestConfig(id: java.math.BigDecimal, mask: kotlin.String?, backgroundImage: kotlin.String?, backgroundColor: kotlin.String?, fontColor: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mask != null) {
                    put("mask", listOf(mask.toString()))
                }
                if (backgroundImage != null) {
                    put("backgroundImage", listOf(backgroundImage.toString()))
                }
                if (backgroundColor != null) {
                    put("backgroundColor", listOf(backgroundColor.toString()))
                }
                if (fontColor != null) {
                    put("fontColor", listOf(fontColor.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/recipes/{id}/card".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Search Restaurants
     * Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.
     * @param query The search query. (optional)
     * @param lat The latitude of the user&#39;s location. (optional)
     * @param lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param distance The distance around the location in miles. (optional)
     * @param budget The user&#39;s budget for a meal in USD. (optional)
     * @param cuisine The cuisine of the restaurant. (optional)
     * @param minRating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param isOpen Whether the restaurant must be open at the time of search. (optional)
     * @param sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param page The page number of results. (optional)
     * @return SearchRestaurants200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRestaurants(query: kotlin.String? = null, lat: java.math.BigDecimal? = null, lng: java.math.BigDecimal? = null, distance: java.math.BigDecimal? = null, budget: java.math.BigDecimal? = null, cuisine: kotlin.String? = null, minRating: java.math.BigDecimal? = null, isOpen: kotlin.Boolean? = null, sort: kotlin.String? = null, page: java.math.BigDecimal? = null) : SearchRestaurants200Response {
        val localVarResponse = searchRestaurantsWithHttpInfo(query = query, lat = lat, lng = lng, distance = distance, budget = budget, cuisine = cuisine, minRating = minRating, isOpen = isOpen, sort = sort, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchRestaurants200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search Restaurants
     * Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.
     * @param query The search query. (optional)
     * @param lat The latitude of the user&#39;s location. (optional)
     * @param lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param distance The distance around the location in miles. (optional)
     * @param budget The user&#39;s budget for a meal in USD. (optional)
     * @param cuisine The cuisine of the restaurant. (optional)
     * @param minRating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param isOpen Whether the restaurant must be open at the time of search. (optional)
     * @param sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param page The page number of results. (optional)
     * @return ApiResponse<SearchRestaurants200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRestaurantsWithHttpInfo(query: kotlin.String?, lat: java.math.BigDecimal?, lng: java.math.BigDecimal?, distance: java.math.BigDecimal?, budget: java.math.BigDecimal?, cuisine: kotlin.String?, minRating: java.math.BigDecimal?, isOpen: kotlin.Boolean?, sort: kotlin.String?, page: java.math.BigDecimal?) : ApiResponse<SearchRestaurants200Response?> {
        val localVariableConfig = searchRestaurantsRequestConfig(query = query, lat = lat, lng = lng, distance = distance, budget = budget, cuisine = cuisine, minRating = minRating, isOpen = isOpen, sort = sort, page = page)

        return request<Unit, SearchRestaurants200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRestaurants
     *
     * @param query The search query. (optional)
     * @param lat The latitude of the user&#39;s location. (optional)
     * @param lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param distance The distance around the location in miles. (optional)
     * @param budget The user&#39;s budget for a meal in USD. (optional)
     * @param cuisine The cuisine of the restaurant. (optional)
     * @param minRating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param isOpen Whether the restaurant must be open at the time of search. (optional)
     * @param sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param page The page number of results. (optional)
     * @return RequestConfig
     */
    fun searchRestaurantsRequestConfig(query: kotlin.String?, lat: java.math.BigDecimal?, lng: java.math.BigDecimal?, distance: java.math.BigDecimal?, budget: java.math.BigDecimal?, cuisine: kotlin.String?, minRating: java.math.BigDecimal?, isOpen: kotlin.Boolean?, sort: kotlin.String?, page: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (lat != null) {
                    put("lat", listOf(lat.toString()))
                }
                if (lng != null) {
                    put("lng", listOf(lng.toString()))
                }
                if (distance != null) {
                    put("distance", listOf(distance.toString()))
                }
                if (budget != null) {
                    put("budget", listOf(budget.toString()))
                }
                if (cuisine != null) {
                    put("cuisine", listOf(cuisine.toString()))
                }
                if (minRating != null) {
                    put("min-rating", listOf(minRating.toString()))
                }
                if (isOpen != null) {
                    put("is-open", listOf(isOpen.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/food/restaurants/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
