{-
   spoonacular API

   The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 800,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

   OpenAPI Version: 3.0.0
   spoonacular API API version: 1.1
   Contact: mail@spoonacular.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Spoonacular.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Spoonacular.Model where

import Spoonacular.Core
import Spoonacular.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AddChildren
newtype AddChildren = AddChildren { unAddChildren :: Bool } deriving (P.Eq, P.Show)

-- ** AddMenuItemInformation
newtype AddMenuItemInformation = AddMenuItemInformation { unAddMenuItemInformation :: E'Normalize } deriving (P.Eq, P.Show)

-- ** AddProductInformation
newtype AddProductInformation = AddProductInformation { unAddProductInformation :: E'Normalize } deriving (P.Eq, P.Show)

-- ** AddRecipeInformation
newtype AddRecipeInformation = AddRecipeInformation { unAddRecipeInformation :: Bool } deriving (P.Eq, P.Show)

-- ** AddRecipeNutrition
newtype AddRecipeNutrition = AddRecipeNutrition { unAddRecipeNutrition :: Bool } deriving (P.Eq, P.Show)

-- ** Amount
newtype Amount = Amount { unAmount :: Double } deriving (P.Eq, P.Show)

-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Author
newtype Author = Author { unAuthor :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ClassifyGroceryProductBulkRequestInner2
newtype ClassifyGroceryProductBulkRequestInner2 = ClassifyGroceryProductBulkRequestInner2 { unClassifyGroceryProductBulkRequestInner2 :: [ClassifyGroceryProductBulkRequestInner] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ContextId
newtype ContextId = ContextId { unContextId :: Text } deriving (P.Eq, P.Show)

-- ** Cuisine
newtype Cuisine = Cuisine { unCuisine :: Text } deriving (P.Eq, P.Show)

-- ** DefaultCss
newtype DefaultCss = DefaultCss { unDefaultCss :: Bool } deriving (P.Eq, P.Show)

-- ** Diet
newtype Diet = Diet { unDiet :: Text } deriving (P.Eq, P.Show)

-- ** EndDate
newtype EndDate = EndDate { unEndDate :: Text } deriving (P.Eq, P.Show)

-- ** Equipment
newtype Equipment = Equipment { unEquipment :: Text } deriving (P.Eq, P.Show)

-- ** Exclude
newtype Exclude = Exclude { unExclude :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeCuisine
newtype ExcludeCuisine = ExcludeCuisine { unExcludeCuisine :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeIngredients
newtype ExcludeIngredients = ExcludeIngredients { unExcludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** FillIngredients
newtype FillIngredients = FillIngredients { unFillIngredients :: Bool } deriving (P.Eq, P.Show)

-- ** Food
newtype Food = Food { unFood :: Text } deriving (P.Eq, P.Show)

-- ** ForceExtraction
newtype ForceExtraction = ForceExtraction { unForceExtraction :: Bool } deriving (P.Eq, P.Show)

-- ** Hash
newtype Hash = Hash { unHash :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IdDouble
newtype IdDouble = IdDouble { unIdDouble :: Double } deriving (P.Eq, P.Show)

-- ** Ids
newtype Ids = Ids { unIds :: Text } deriving (P.Eq, P.Show)

-- ** IgnorePantry
newtype IgnorePantry = IgnorePantry { unIgnorePantry :: Bool } deriving (P.Eq, P.Show)

-- ** ImageUrl
newtype ImageUrl = ImageUrl { unImageUrl :: Text } deriving (P.Eq, P.Show)

-- ** IncludeIngredients
newtype IncludeIngredients = IncludeIngredients { unIncludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** IncludeNutrition
newtype IncludeNutrition = IncludeNutrition { unIncludeNutrition :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeTaste
newtype IncludeTaste = IncludeTaste { unIncludeTaste :: Bool } deriving (P.Eq, P.Show)

-- ** IngredientName
newtype IngredientName = IngredientName { unIngredientName :: Text } deriving (P.Eq, P.Show)

-- ** Ingredients
newtype Ingredients = Ingredients { unIngredients :: Text } deriving (P.Eq, P.Show)

-- ** InstructionsRequired
newtype InstructionsRequired = InstructionsRequired { unInstructionsRequired :: Bool } deriving (P.Eq, P.Show)

-- ** Intolerances
newtype Intolerances = Intolerances { unIntolerances :: Text } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: E'Language } deriving (P.Eq, P.Show)

-- ** LimitLicense
newtype LimitLicense = LimitLicense { unLimitLicense :: Bool } deriving (P.Eq, P.Show)

-- ** Locale
newtype Locale = Locale { unLocale :: E'Locale } deriving (P.Eq, P.Show)

-- ** LocaleText
newtype LocaleText = LocaleText { unLocaleText :: Text } deriving (P.Eq, P.Show)

-- ** MaxAlcohol
newtype MaxAlcohol = MaxAlcohol { unMaxAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MaxCaffeine
newtype MaxCaffeine = MaxCaffeine { unMaxCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalcium
newtype MaxCalcium = MaxCalcium { unMaxCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalories
newtype MaxCalories = MaxCalories { unMaxCalories :: Double } deriving (P.Eq, P.Show)

-- ** MaxCarbs
newtype MaxCarbs = MaxCarbs { unMaxCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MaxCarbsPercent
newtype MaxCarbsPercent = MaxCarbsPercent { unMaxCarbsPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholesterol
newtype MaxCholesterol = MaxCholesterol { unMaxCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholine
newtype MaxCholine = MaxCholine { unMaxCholine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCopper
newtype MaxCopper = MaxCopper { unMaxCopper :: Double } deriving (P.Eq, P.Show)

-- ** MaxFat
newtype MaxFat = MaxFat { unMaxFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxFatPercent
newtype MaxFatPercent = MaxFatPercent { unMaxFatPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxFiber
newtype MaxFiber = MaxFiber { unMaxFiber :: Double } deriving (P.Eq, P.Show)

-- ** MaxFluoride
newtype MaxFluoride = MaxFluoride { unMaxFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolate
newtype MaxFolate = MaxFolate { unMaxFolate :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolicAcid
newtype MaxFolicAcid = MaxFolicAcid { unMaxFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MaxIodine
newtype MaxIodine = MaxIodine { unMaxIodine :: Double } deriving (P.Eq, P.Show)

-- ** MaxIron
newtype MaxIron = MaxIron { unMaxIron :: Double } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Double } deriving (P.Eq, P.Show)

-- ** MaxMagnesium
newtype MaxMagnesium = MaxMagnesium { unMaxMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MaxManganese
newtype MaxManganese = MaxManganese { unMaxManganese :: Double } deriving (P.Eq, P.Show)

-- ** MaxPhosphorus
newtype MaxPhosphorus = MaxPhosphorus { unMaxPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MaxPotassium
newtype MaxPotassium = MaxPotassium { unMaxPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MaxPrice
newtype MaxPrice = MaxPrice { unMaxPrice :: Double } deriving (P.Eq, P.Show)

-- ** MaxProtein
newtype MaxProtein = MaxProtein { unMaxProtein :: Double } deriving (P.Eq, P.Show)

-- ** MaxProteinPercent
newtype MaxProteinPercent = MaxProteinPercent { unMaxProteinPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxReadyTime
newtype MaxReadyTime = MaxReadyTime { unMaxReadyTime :: Double } deriving (P.Eq, P.Show)

-- ** MaxSaturatedFat
newtype MaxSaturatedFat = MaxSaturatedFat { unMaxSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxSelenium
newtype MaxSelenium = MaxSelenium { unMaxSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSodium
newtype MaxSodium = MaxSodium { unMaxSodium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSugar
newtype MaxSugar = MaxSugar { unMaxSugar :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminA
newtype MaxVitaminA = MaxVitaminA { unMaxVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB1
newtype MaxVitaminB1 = MaxVitaminB1 { unMaxVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB12
newtype MaxVitaminB12 = MaxVitaminB12 { unMaxVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB2
newtype MaxVitaminB2 = MaxVitaminB2 { unMaxVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB3
newtype MaxVitaminB3 = MaxVitaminB3 { unMaxVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB5
newtype MaxVitaminB5 = MaxVitaminB5 { unMaxVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB6
newtype MaxVitaminB6 = MaxVitaminB6 { unMaxVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminC
newtype MaxVitaminC = MaxVitaminC { unMaxVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminD
newtype MaxVitaminD = MaxVitaminD { unMaxVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminE
newtype MaxVitaminE = MaxVitaminE { unMaxVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminK
newtype MaxVitaminK = MaxVitaminK { unMaxVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MaxZinc
newtype MaxZinc = MaxZinc { unMaxZinc :: Double } deriving (P.Eq, P.Show)

-- ** Measure
newtype Measure = Measure { unMeasure :: E'Measure } deriving (P.Eq, P.Show)

-- ** MetaInformation
newtype MetaInformation = MetaInformation { unMetaInformation :: Bool } deriving (P.Eq, P.Show)

-- ** MinAlcohol
newtype MinAlcohol = MinAlcohol { unMinAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MinCaffeine
newtype MinCaffeine = MinCaffeine { unMinCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MinCalcium
newtype MinCalcium = MinCalcium { unMinCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MinCalories
newtype MinCalories = MinCalories { unMinCalories :: Double } deriving (P.Eq, P.Show)

-- ** MinCarbs
newtype MinCarbs = MinCarbs { unMinCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MinCarbsPercent
newtype MinCarbsPercent = MinCarbsPercent { unMinCarbsPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinCholesterol
newtype MinCholesterol = MinCholesterol { unMinCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MinCholine
newtype MinCholine = MinCholine { unMinCholine :: Double } deriving (P.Eq, P.Show)

-- ** MinCopper
newtype MinCopper = MinCopper { unMinCopper :: Double } deriving (P.Eq, P.Show)

-- ** MinFat
newtype MinFat = MinFat { unMinFat :: Double } deriving (P.Eq, P.Show)

-- ** MinFatPercent
newtype MinFatPercent = MinFatPercent { unMinFatPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinFiber
newtype MinFiber = MinFiber { unMinFiber :: Double } deriving (P.Eq, P.Show)

-- ** MinFluoride
newtype MinFluoride = MinFluoride { unMinFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MinFolate
newtype MinFolate = MinFolate { unMinFolate :: Double } deriving (P.Eq, P.Show)

-- ** MinFolicAcid
newtype MinFolicAcid = MinFolicAcid { unMinFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MinIodine
newtype MinIodine = MinIodine { unMinIodine :: Double } deriving (P.Eq, P.Show)

-- ** MinIron
newtype MinIron = MinIron { unMinIron :: Double } deriving (P.Eq, P.Show)

-- ** MinLength
newtype MinLength = MinLength { unMinLength :: Double } deriving (P.Eq, P.Show)

-- ** MinMagnesium
newtype MinMagnesium = MinMagnesium { unMinMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MinManganese
newtype MinManganese = MinManganese { unMinManganese :: Double } deriving (P.Eq, P.Show)

-- ** MinPhosphorus
newtype MinPhosphorus = MinPhosphorus { unMinPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MinPotassium
newtype MinPotassium = MinPotassium { unMinPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MinProtein
newtype MinProtein = MinProtein { unMinProtein :: Double } deriving (P.Eq, P.Show)

-- ** MinProteinPercent
newtype MinProteinPercent = MinProteinPercent { unMinProteinPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Double } deriving (P.Eq, P.Show)

-- ** MinSaturatedFat
newtype MinSaturatedFat = MinSaturatedFat { unMinSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MinSelenium
newtype MinSelenium = MinSelenium { unMinSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MinSodium
newtype MinSodium = MinSodium { unMinSodium :: Double } deriving (P.Eq, P.Show)

-- ** MinSugar
newtype MinSugar = MinSugar { unMinSugar :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminA
newtype MinVitaminA = MinVitaminA { unMinVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB1
newtype MinVitaminB1 = MinVitaminB1 { unMinVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB12
newtype MinVitaminB12 = MinVitaminB12 { unMinVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB2
newtype MinVitaminB2 = MinVitaminB2 { unMinVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB3
newtype MinVitaminB3 = MinVitaminB3 { unMinVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB5
newtype MinVitaminB5 = MinVitaminB5 { unMinVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB6
newtype MinVitaminB6 = MinVitaminB6 { unMinVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminC
newtype MinVitaminC = MinVitaminC { unMinVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminD
newtype MinVitaminD = MinVitaminD { unMinVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminE
newtype MinVitaminE = MinVitaminE { unMinVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminK
newtype MinVitaminK = MinVitaminK { unMinVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MinZinc
newtype MinZinc = MinZinc { unMinZinc :: Double } deriving (P.Eq, P.Show)

-- ** Normalize
newtype Normalize = Normalize { unNormalize :: E'Normalize } deriving (P.Eq, P.Show)

-- ** Normalize2
newtype Normalize2 = Normalize2 { unNormalize2 :: E'Normalize2 } deriving (P.Eq, P.Show)

-- ** NormalizeBool
newtype NormalizeBool = NormalizeBool { unNormalizeBool :: Bool } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** NumberDouble
newtype NumberDouble = NumberDouble { unNumberDouble :: Double } deriving (P.Eq, P.Show)

-- ** Nutrient
newtype Nutrient = Nutrient { unNutrient :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** ParamAccept
newtype ParamAccept = ParamAccept { unParamAccept :: E'Accept } deriving (P.Eq, P.Show)

-- ** ParamContentType
newtype ParamContentType = ParamContentType { unParamContentType :: E'ContentType } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Random
newtype Random = Random { unRandom :: Bool } deriving (P.Eq, P.Show)

-- ** Ranking
newtype Ranking = Ranking { unRanking :: Double } deriving (P.Eq, P.Show)

-- ** RecipeBoxId
newtype RecipeBoxId = RecipeBoxId { unRecipeBoxId :: Double } deriving (P.Eq, P.Show)

-- ** Rgb
newtype Rgb = Rgb { unRgb :: Text } deriving (P.Eq, P.Show)

-- ** ShowIngredients
newtype ShowIngredients = ShowIngredients { unShowIngredients :: Bool } deriving (P.Eq, P.Show)

-- ** ShowOptionalNutrients
newtype ShowOptionalNutrients = ShowOptionalNutrients { unShowOptionalNutrients :: Bool } deriving (P.Eq, P.Show)

-- ** ShowZeroValues
newtype ShowZeroValues = ShowZeroValues { unShowZeroValues :: Bool } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** SourceAmount
newtype SourceAmount = SourceAmount { unSourceAmount :: Double } deriving (P.Eq, P.Show)

-- ** SourceUnit
newtype SourceUnit = SourceUnit { unSourceUnit :: Text } deriving (P.Eq, P.Show)

-- ** StartDate
newtype StartDate = StartDate { unStartDate :: Text } deriving (P.Eq, P.Show)

-- ** StepBreakdown
newtype StepBreakdown = StepBreakdown { unStepBreakdown :: Bool } deriving (P.Eq, P.Show)

-- ** Tags
newtype Tags = Tags { unTags :: Text } deriving (P.Eq, P.Show)

-- ** Target
newtype Target = Target { unTarget :: Double } deriving (P.Eq, P.Show)

-- ** TargetCalories
newtype TargetCalories = TargetCalories { unTargetCalories :: Double } deriving (P.Eq, P.Show)

-- ** TargetUnit
newtype TargetUnit = TargetUnit { unTargetUnit :: Text } deriving (P.Eq, P.Show)

-- ** TimeFrame
newtype TimeFrame = TimeFrame { unTimeFrame :: Text } deriving (P.Eq, P.Show)

-- ** Title
newtype Title = Title { unTitle :: Text } deriving (P.Eq, P.Show)

-- ** TitleMatch
newtype TitleMatch = TitleMatch { unTitleMatch :: Text } deriving (P.Eq, P.Show)

-- ** Unit
newtype Unit = Unit { unUnit :: Text } deriving (P.Eq, P.Show)

-- ** Upc
newtype Upc = Upc { unUpc :: Double } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- ** Wine
newtype Wine = Wine { unWine :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AddMealPlanTemplate200Response
-- | AddMealPlanTemplate200Response
-- 
data AddMealPlanTemplate200Response = AddMealPlanTemplate200Response
  { addMealPlanTemplate200ResponseName :: !(Text) -- ^ /Required/ "name"
  , addMealPlanTemplate200ResponseItems :: !([AddMealPlanTemplate200ResponseItemsInner]) -- ^ /Required/ "items"
  , addMealPlanTemplate200ResponsePublishAsPublic :: !(Bool) -- ^ /Required/ "publishAsPublic"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddMealPlanTemplate200Response
instance A.FromJSON AddMealPlanTemplate200Response where
  parseJSON = A.withObject "AddMealPlanTemplate200Response" $ \o ->
    AddMealPlanTemplate200Response
      <$> (o .:  "name")
      <*> (o .:  "items")
      <*> (o .:  "publishAsPublic")

-- | ToJSON AddMealPlanTemplate200Response
instance A.ToJSON AddMealPlanTemplate200Response where
  toJSON AddMealPlanTemplate200Response {..} =
   _omitNulls
      [ "name" .= addMealPlanTemplate200ResponseName
      , "items" .= addMealPlanTemplate200ResponseItems
      , "publishAsPublic" .= addMealPlanTemplate200ResponsePublishAsPublic
      ]


-- | Construct a value of type 'AddMealPlanTemplate200Response' (by applying it's required fields, if any)
mkAddMealPlanTemplate200Response
  :: Text -- ^ 'addMealPlanTemplate200ResponseName' 
  -> [AddMealPlanTemplate200ResponseItemsInner] -- ^ 'addMealPlanTemplate200ResponseItems' 
  -> Bool -- ^ 'addMealPlanTemplate200ResponsePublishAsPublic' 
  -> AddMealPlanTemplate200Response
mkAddMealPlanTemplate200Response addMealPlanTemplate200ResponseName addMealPlanTemplate200ResponseItems addMealPlanTemplate200ResponsePublishAsPublic =
  AddMealPlanTemplate200Response
  { addMealPlanTemplate200ResponseName
  , addMealPlanTemplate200ResponseItems
  , addMealPlanTemplate200ResponsePublishAsPublic
  }

-- ** AddMealPlanTemplate200ResponseItemsInner
-- | AddMealPlanTemplate200ResponseItemsInner
data AddMealPlanTemplate200ResponseItemsInner = AddMealPlanTemplate200ResponseItemsInner
  { addMealPlanTemplate200ResponseItemsInnerDay :: !(Int) -- ^ /Required/ "day"
  , addMealPlanTemplate200ResponseItemsInnerSlot :: !(Int) -- ^ /Required/ "slot"
  , addMealPlanTemplate200ResponseItemsInnerPosition :: !(Int) -- ^ /Required/ "position"
  , addMealPlanTemplate200ResponseItemsInnerType :: !(Text) -- ^ /Required/ "type"
  , addMealPlanTemplate200ResponseItemsInnerValue :: !(Maybe AddMealPlanTemplate200ResponseItemsInnerValue) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddMealPlanTemplate200ResponseItemsInner
instance A.FromJSON AddMealPlanTemplate200ResponseItemsInner where
  parseJSON = A.withObject "AddMealPlanTemplate200ResponseItemsInner" $ \o ->
    AddMealPlanTemplate200ResponseItemsInner
      <$> (o .:  "day")
      <*> (o .:  "slot")
      <*> (o .:  "position")
      <*> (o .:  "type")
      <*> (o .:? "value")

-- | ToJSON AddMealPlanTemplate200ResponseItemsInner
instance A.ToJSON AddMealPlanTemplate200ResponseItemsInner where
  toJSON AddMealPlanTemplate200ResponseItemsInner {..} =
   _omitNulls
      [ "day" .= addMealPlanTemplate200ResponseItemsInnerDay
      , "slot" .= addMealPlanTemplate200ResponseItemsInnerSlot
      , "position" .= addMealPlanTemplate200ResponseItemsInnerPosition
      , "type" .= addMealPlanTemplate200ResponseItemsInnerType
      , "value" .= addMealPlanTemplate200ResponseItemsInnerValue
      ]


-- | Construct a value of type 'AddMealPlanTemplate200ResponseItemsInner' (by applying it's required fields, if any)
mkAddMealPlanTemplate200ResponseItemsInner
  :: Int -- ^ 'addMealPlanTemplate200ResponseItemsInnerDay' 
  -> Int -- ^ 'addMealPlanTemplate200ResponseItemsInnerSlot' 
  -> Int -- ^ 'addMealPlanTemplate200ResponseItemsInnerPosition' 
  -> Text -- ^ 'addMealPlanTemplate200ResponseItemsInnerType' 
  -> AddMealPlanTemplate200ResponseItemsInner
mkAddMealPlanTemplate200ResponseItemsInner addMealPlanTemplate200ResponseItemsInnerDay addMealPlanTemplate200ResponseItemsInnerSlot addMealPlanTemplate200ResponseItemsInnerPosition addMealPlanTemplate200ResponseItemsInnerType =
  AddMealPlanTemplate200ResponseItemsInner
  { addMealPlanTemplate200ResponseItemsInnerDay
  , addMealPlanTemplate200ResponseItemsInnerSlot
  , addMealPlanTemplate200ResponseItemsInnerPosition
  , addMealPlanTemplate200ResponseItemsInnerType
  , addMealPlanTemplate200ResponseItemsInnerValue = Nothing
  }

-- ** AddMealPlanTemplate200ResponseItemsInnerValue
-- | AddMealPlanTemplate200ResponseItemsInnerValue
data AddMealPlanTemplate200ResponseItemsInnerValue = AddMealPlanTemplate200ResponseItemsInnerValue
  { addMealPlanTemplate200ResponseItemsInnerValueId :: !(Maybe Int) -- ^ "id"
  , addMealPlanTemplate200ResponseItemsInnerValueServings :: !(Maybe Double) -- ^ "servings"
  , addMealPlanTemplate200ResponseItemsInnerValueTitle :: !(Maybe Text) -- ^ "title"
  , addMealPlanTemplate200ResponseItemsInnerValueImageType :: !(Maybe Text) -- ^ "imageType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddMealPlanTemplate200ResponseItemsInnerValue
instance A.FromJSON AddMealPlanTemplate200ResponseItemsInnerValue where
  parseJSON = A.withObject "AddMealPlanTemplate200ResponseItemsInnerValue" $ \o ->
    AddMealPlanTemplate200ResponseItemsInnerValue
      <$> (o .:? "id")
      <*> (o .:? "servings")
      <*> (o .:? "title")
      <*> (o .:? "imageType")

-- | ToJSON AddMealPlanTemplate200ResponseItemsInnerValue
instance A.ToJSON AddMealPlanTemplate200ResponseItemsInnerValue where
  toJSON AddMealPlanTemplate200ResponseItemsInnerValue {..} =
   _omitNulls
      [ "id" .= addMealPlanTemplate200ResponseItemsInnerValueId
      , "servings" .= addMealPlanTemplate200ResponseItemsInnerValueServings
      , "title" .= addMealPlanTemplate200ResponseItemsInnerValueTitle
      , "imageType" .= addMealPlanTemplate200ResponseItemsInnerValueImageType
      ]


-- | Construct a value of type 'AddMealPlanTemplate200ResponseItemsInnerValue' (by applying it's required fields, if any)
mkAddMealPlanTemplate200ResponseItemsInnerValue
  :: AddMealPlanTemplate200ResponseItemsInnerValue
mkAddMealPlanTemplate200ResponseItemsInnerValue =
  AddMealPlanTemplate200ResponseItemsInnerValue
  { addMealPlanTemplate200ResponseItemsInnerValueId = Nothing
  , addMealPlanTemplate200ResponseItemsInnerValueServings = Nothing
  , addMealPlanTemplate200ResponseItemsInnerValueTitle = Nothing
  , addMealPlanTemplate200ResponseItemsInnerValueImageType = Nothing
  }

-- ** AddToMealPlanRequest
-- | AddToMealPlanRequest
data AddToMealPlanRequest = AddToMealPlanRequest
  { addToMealPlanRequestUsername :: !(Text) -- ^ /Required/ "username" - The username.
  , addToMealPlanRequestHash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddToMealPlanRequest
instance A.FromJSON AddToMealPlanRequest where
  parseJSON = A.withObject "AddToMealPlanRequest" $ \o ->
    AddToMealPlanRequest
      <$> (o .:  "username")
      <*> (o .:  "hash")

-- | ToJSON AddToMealPlanRequest
instance A.ToJSON AddToMealPlanRequest where
  toJSON AddToMealPlanRequest {..} =
   _omitNulls
      [ "username" .= addToMealPlanRequestUsername
      , "hash" .= addToMealPlanRequestHash
      ]


-- | Construct a value of type 'AddToMealPlanRequest' (by applying it's required fields, if any)
mkAddToMealPlanRequest
  :: Text -- ^ 'addToMealPlanRequestUsername': The username.
  -> Text -- ^ 'addToMealPlanRequestHash': The private hash for the username.
  -> AddToMealPlanRequest
mkAddToMealPlanRequest addToMealPlanRequestUsername addToMealPlanRequestHash =
  AddToMealPlanRequest
  { addToMealPlanRequestUsername
  , addToMealPlanRequestHash
  }

-- ** AddToMealPlanRequest1
-- | AddToMealPlanRequest1
-- 
data AddToMealPlanRequest1 = AddToMealPlanRequest1
  { addToMealPlanRequest1Date :: !(Double) -- ^ /Required/ "date"
  , addToMealPlanRequest1Slot :: !(Int) -- ^ /Required/ "slot"
  , addToMealPlanRequest1Position :: !(Int) -- ^ /Required/ "position"
  , addToMealPlanRequest1Type :: !(Text) -- ^ /Required/ "type"
  , addToMealPlanRequest1Value :: !(AddToMealPlanRequest1Value) -- ^ /Required/ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddToMealPlanRequest1
instance A.FromJSON AddToMealPlanRequest1 where
  parseJSON = A.withObject "AddToMealPlanRequest1" $ \o ->
    AddToMealPlanRequest1
      <$> (o .:  "date")
      <*> (o .:  "slot")
      <*> (o .:  "position")
      <*> (o .:  "type")
      <*> (o .:  "value")

-- | ToJSON AddToMealPlanRequest1
instance A.ToJSON AddToMealPlanRequest1 where
  toJSON AddToMealPlanRequest1 {..} =
   _omitNulls
      [ "date" .= addToMealPlanRequest1Date
      , "slot" .= addToMealPlanRequest1Slot
      , "position" .= addToMealPlanRequest1Position
      , "type" .= addToMealPlanRequest1Type
      , "value" .= addToMealPlanRequest1Value
      ]


-- | Construct a value of type 'AddToMealPlanRequest1' (by applying it's required fields, if any)
mkAddToMealPlanRequest1
  :: Double -- ^ 'addToMealPlanRequest1Date' 
  -> Int -- ^ 'addToMealPlanRequest1Slot' 
  -> Int -- ^ 'addToMealPlanRequest1Position' 
  -> Text -- ^ 'addToMealPlanRequest1Type' 
  -> AddToMealPlanRequest1Value -- ^ 'addToMealPlanRequest1Value' 
  -> AddToMealPlanRequest1
mkAddToMealPlanRequest1 addToMealPlanRequest1Date addToMealPlanRequest1Slot addToMealPlanRequest1Position addToMealPlanRequest1Type addToMealPlanRequest1Value =
  AddToMealPlanRequest1
  { addToMealPlanRequest1Date
  , addToMealPlanRequest1Slot
  , addToMealPlanRequest1Position
  , addToMealPlanRequest1Type
  , addToMealPlanRequest1Value
  }

-- ** AddToMealPlanRequest1Value
-- | AddToMealPlanRequest1Value
data AddToMealPlanRequest1Value = AddToMealPlanRequest1Value
  { addToMealPlanRequest1ValueIngredients :: !([AddToMealPlanRequest1ValueIngredientsInner]) -- ^ /Required/ "ingredients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddToMealPlanRequest1Value
instance A.FromJSON AddToMealPlanRequest1Value where
  parseJSON = A.withObject "AddToMealPlanRequest1Value" $ \o ->
    AddToMealPlanRequest1Value
      <$> (o .:  "ingredients")

-- | ToJSON AddToMealPlanRequest1Value
instance A.ToJSON AddToMealPlanRequest1Value where
  toJSON AddToMealPlanRequest1Value {..} =
   _omitNulls
      [ "ingredients" .= addToMealPlanRequest1ValueIngredients
      ]


-- | Construct a value of type 'AddToMealPlanRequest1Value' (by applying it's required fields, if any)
mkAddToMealPlanRequest1Value
  :: [AddToMealPlanRequest1ValueIngredientsInner] -- ^ 'addToMealPlanRequest1ValueIngredients' 
  -> AddToMealPlanRequest1Value
mkAddToMealPlanRequest1Value addToMealPlanRequest1ValueIngredients =
  AddToMealPlanRequest1Value
  { addToMealPlanRequest1ValueIngredients
  }

-- ** AddToMealPlanRequest1ValueIngredientsInner
-- | AddToMealPlanRequest1ValueIngredientsInner
data AddToMealPlanRequest1ValueIngredientsInner = AddToMealPlanRequest1ValueIngredientsInner
  { addToMealPlanRequest1ValueIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddToMealPlanRequest1ValueIngredientsInner
instance A.FromJSON AddToMealPlanRequest1ValueIngredientsInner where
  parseJSON = A.withObject "AddToMealPlanRequest1ValueIngredientsInner" $ \o ->
    AddToMealPlanRequest1ValueIngredientsInner
      <$> (o .:  "name")

-- | ToJSON AddToMealPlanRequest1ValueIngredientsInner
instance A.ToJSON AddToMealPlanRequest1ValueIngredientsInner where
  toJSON AddToMealPlanRequest1ValueIngredientsInner {..} =
   _omitNulls
      [ "name" .= addToMealPlanRequest1ValueIngredientsInnerName
      ]


-- | Construct a value of type 'AddToMealPlanRequest1ValueIngredientsInner' (by applying it's required fields, if any)
mkAddToMealPlanRequest1ValueIngredientsInner
  :: Text -- ^ 'addToMealPlanRequest1ValueIngredientsInnerName' 
  -> AddToMealPlanRequest1ValueIngredientsInner
mkAddToMealPlanRequest1ValueIngredientsInner addToMealPlanRequest1ValueIngredientsInnerName =
  AddToMealPlanRequest1ValueIngredientsInner
  { addToMealPlanRequest1ValueIngredientsInnerName
  }

-- ** AddToShoppingListRequest
-- | AddToShoppingListRequest
-- 
data AddToShoppingListRequest = AddToShoppingListRequest
  { addToShoppingListRequestItem :: !(Text) -- ^ /Required/ "item"
  , addToShoppingListRequestAisle :: !(Text) -- ^ /Required/ "aisle"
  , addToShoppingListRequestParse :: !(Bool) -- ^ /Required/ "parse"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddToShoppingListRequest
instance A.FromJSON AddToShoppingListRequest where
  parseJSON = A.withObject "AddToShoppingListRequest" $ \o ->
    AddToShoppingListRequest
      <$> (o .:  "item")
      <*> (o .:  "aisle")
      <*> (o .:  "parse")

-- | ToJSON AddToShoppingListRequest
instance A.ToJSON AddToShoppingListRequest where
  toJSON AddToShoppingListRequest {..} =
   _omitNulls
      [ "item" .= addToShoppingListRequestItem
      , "aisle" .= addToShoppingListRequestAisle
      , "parse" .= addToShoppingListRequestParse
      ]


-- | Construct a value of type 'AddToShoppingListRequest' (by applying it's required fields, if any)
mkAddToShoppingListRequest
  :: Text -- ^ 'addToShoppingListRequestItem' 
  -> Text -- ^ 'addToShoppingListRequestAisle' 
  -> Bool -- ^ 'addToShoppingListRequestParse' 
  -> AddToShoppingListRequest
mkAddToShoppingListRequest addToShoppingListRequestItem addToShoppingListRequestAisle addToShoppingListRequestParse =
  AddToShoppingListRequest
  { addToShoppingListRequestItem
  , addToShoppingListRequestAisle
  , addToShoppingListRequestParse
  }

-- ** AnalyzeARecipeSearchQuery200Response
-- | AnalyzeARecipeSearchQuery200Response
-- 
data AnalyzeARecipeSearchQuery200Response = AnalyzeARecipeSearchQuery200Response
  { analyzeARecipeSearchQuery200ResponseDishes :: !([AnalyzeARecipeSearchQuery200ResponseDishesInner]) -- ^ /Required/ "dishes"
  , analyzeARecipeSearchQuery200ResponseIngredients :: !([AnalyzeARecipeSearchQuery200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  , analyzeARecipeSearchQuery200ResponseCuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , analyzeARecipeSearchQuery200ResponseModifiers :: !([Text]) -- ^ /Required/ "modifiers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeARecipeSearchQuery200Response
instance A.FromJSON AnalyzeARecipeSearchQuery200Response where
  parseJSON = A.withObject "AnalyzeARecipeSearchQuery200Response" $ \o ->
    AnalyzeARecipeSearchQuery200Response
      <$> (o .:  "dishes")
      <*> (o .:  "ingredients")
      <*> (o .:  "cuisines")
      <*> (o .:  "modifiers")

-- | ToJSON AnalyzeARecipeSearchQuery200Response
instance A.ToJSON AnalyzeARecipeSearchQuery200Response where
  toJSON AnalyzeARecipeSearchQuery200Response {..} =
   _omitNulls
      [ "dishes" .= analyzeARecipeSearchQuery200ResponseDishes
      , "ingredients" .= analyzeARecipeSearchQuery200ResponseIngredients
      , "cuisines" .= analyzeARecipeSearchQuery200ResponseCuisines
      , "modifiers" .= analyzeARecipeSearchQuery200ResponseModifiers
      ]


-- | Construct a value of type 'AnalyzeARecipeSearchQuery200Response' (by applying it's required fields, if any)
mkAnalyzeARecipeSearchQuery200Response
  :: [AnalyzeARecipeSearchQuery200ResponseDishesInner] -- ^ 'analyzeARecipeSearchQuery200ResponseDishes' 
  -> [AnalyzeARecipeSearchQuery200ResponseIngredientsInner] -- ^ 'analyzeARecipeSearchQuery200ResponseIngredients' 
  -> [Text] -- ^ 'analyzeARecipeSearchQuery200ResponseCuisines' 
  -> [Text] -- ^ 'analyzeARecipeSearchQuery200ResponseModifiers' 
  -> AnalyzeARecipeSearchQuery200Response
mkAnalyzeARecipeSearchQuery200Response analyzeARecipeSearchQuery200ResponseDishes analyzeARecipeSearchQuery200ResponseIngredients analyzeARecipeSearchQuery200ResponseCuisines analyzeARecipeSearchQuery200ResponseModifiers =
  AnalyzeARecipeSearchQuery200Response
  { analyzeARecipeSearchQuery200ResponseDishes
  , analyzeARecipeSearchQuery200ResponseIngredients
  , analyzeARecipeSearchQuery200ResponseCuisines
  , analyzeARecipeSearchQuery200ResponseModifiers
  }

-- ** AnalyzeARecipeSearchQuery200ResponseDishesInner
-- | AnalyzeARecipeSearchQuery200ResponseDishesInner
data AnalyzeARecipeSearchQuery200ResponseDishesInner = AnalyzeARecipeSearchQuery200ResponseDishesInner
  { analyzeARecipeSearchQuery200ResponseDishesInnerImage :: !(Text) -- ^ /Required/ "image"
  , analyzeARecipeSearchQuery200ResponseDishesInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeARecipeSearchQuery200ResponseDishesInner
instance A.FromJSON AnalyzeARecipeSearchQuery200ResponseDishesInner where
  parseJSON = A.withObject "AnalyzeARecipeSearchQuery200ResponseDishesInner" $ \o ->
    AnalyzeARecipeSearchQuery200ResponseDishesInner
      <$> (o .:  "image")
      <*> (o .:  "name")

-- | ToJSON AnalyzeARecipeSearchQuery200ResponseDishesInner
instance A.ToJSON AnalyzeARecipeSearchQuery200ResponseDishesInner where
  toJSON AnalyzeARecipeSearchQuery200ResponseDishesInner {..} =
   _omitNulls
      [ "image" .= analyzeARecipeSearchQuery200ResponseDishesInnerImage
      , "name" .= analyzeARecipeSearchQuery200ResponseDishesInnerName
      ]


-- | Construct a value of type 'AnalyzeARecipeSearchQuery200ResponseDishesInner' (by applying it's required fields, if any)
mkAnalyzeARecipeSearchQuery200ResponseDishesInner
  :: Text -- ^ 'analyzeARecipeSearchQuery200ResponseDishesInnerImage' 
  -> Text -- ^ 'analyzeARecipeSearchQuery200ResponseDishesInnerName' 
  -> AnalyzeARecipeSearchQuery200ResponseDishesInner
mkAnalyzeARecipeSearchQuery200ResponseDishesInner analyzeARecipeSearchQuery200ResponseDishesInnerImage analyzeARecipeSearchQuery200ResponseDishesInnerName =
  AnalyzeARecipeSearchQuery200ResponseDishesInner
  { analyzeARecipeSearchQuery200ResponseDishesInnerImage
  , analyzeARecipeSearchQuery200ResponseDishesInnerName
  }

-- ** AnalyzeARecipeSearchQuery200ResponseIngredientsInner
-- | AnalyzeARecipeSearchQuery200ResponseIngredientsInner
data AnalyzeARecipeSearchQuery200ResponseIngredientsInner = AnalyzeARecipeSearchQuery200ResponseIngredientsInner
  { analyzeARecipeSearchQuery200ResponseIngredientsInnerImage :: !(Text) -- ^ /Required/ "image"
  , analyzeARecipeSearchQuery200ResponseIngredientsInnerInclude :: !(Bool) -- ^ /Required/ "include"
  , analyzeARecipeSearchQuery200ResponseIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeARecipeSearchQuery200ResponseIngredientsInner
instance A.FromJSON AnalyzeARecipeSearchQuery200ResponseIngredientsInner where
  parseJSON = A.withObject "AnalyzeARecipeSearchQuery200ResponseIngredientsInner" $ \o ->
    AnalyzeARecipeSearchQuery200ResponseIngredientsInner
      <$> (o .:  "image")
      <*> (o .:  "include")
      <*> (o .:  "name")

-- | ToJSON AnalyzeARecipeSearchQuery200ResponseIngredientsInner
instance A.ToJSON AnalyzeARecipeSearchQuery200ResponseIngredientsInner where
  toJSON AnalyzeARecipeSearchQuery200ResponseIngredientsInner {..} =
   _omitNulls
      [ "image" .= analyzeARecipeSearchQuery200ResponseIngredientsInnerImage
      , "include" .= analyzeARecipeSearchQuery200ResponseIngredientsInnerInclude
      , "name" .= analyzeARecipeSearchQuery200ResponseIngredientsInnerName
      ]


-- | Construct a value of type 'AnalyzeARecipeSearchQuery200ResponseIngredientsInner' (by applying it's required fields, if any)
mkAnalyzeARecipeSearchQuery200ResponseIngredientsInner
  :: Text -- ^ 'analyzeARecipeSearchQuery200ResponseIngredientsInnerImage' 
  -> Bool -- ^ 'analyzeARecipeSearchQuery200ResponseIngredientsInnerInclude' 
  -> Text -- ^ 'analyzeARecipeSearchQuery200ResponseIngredientsInnerName' 
  -> AnalyzeARecipeSearchQuery200ResponseIngredientsInner
mkAnalyzeARecipeSearchQuery200ResponseIngredientsInner analyzeARecipeSearchQuery200ResponseIngredientsInnerImage analyzeARecipeSearchQuery200ResponseIngredientsInnerInclude analyzeARecipeSearchQuery200ResponseIngredientsInnerName =
  AnalyzeARecipeSearchQuery200ResponseIngredientsInner
  { analyzeARecipeSearchQuery200ResponseIngredientsInnerImage
  , analyzeARecipeSearchQuery200ResponseIngredientsInnerInclude
  , analyzeARecipeSearchQuery200ResponseIngredientsInnerName
  }

-- ** AnalyzeRecipeInstructions200Response
-- | AnalyzeRecipeInstructions200Response
-- 
data AnalyzeRecipeInstructions200Response = AnalyzeRecipeInstructions200Response
  { analyzeRecipeInstructions200ResponseParsedInstructions :: !([AnalyzeRecipeInstructions200ResponseParsedInstructionsInner]) -- ^ /Required/ "parsedInstructions"
  , analyzeRecipeInstructions200ResponseIngredients :: !([AnalyzeRecipeInstructions200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  , analyzeRecipeInstructions200ResponseEquipment :: !([AnalyzeRecipeInstructions200ResponseIngredientsInner]) -- ^ /Required/ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeRecipeInstructions200Response
instance A.FromJSON AnalyzeRecipeInstructions200Response where
  parseJSON = A.withObject "AnalyzeRecipeInstructions200Response" $ \o ->
    AnalyzeRecipeInstructions200Response
      <$> (o .:  "parsedInstructions")
      <*> (o .:  "ingredients")
      <*> (o .:  "equipment")

-- | ToJSON AnalyzeRecipeInstructions200Response
instance A.ToJSON AnalyzeRecipeInstructions200Response where
  toJSON AnalyzeRecipeInstructions200Response {..} =
   _omitNulls
      [ "parsedInstructions" .= analyzeRecipeInstructions200ResponseParsedInstructions
      , "ingredients" .= analyzeRecipeInstructions200ResponseIngredients
      , "equipment" .= analyzeRecipeInstructions200ResponseEquipment
      ]


-- | Construct a value of type 'AnalyzeRecipeInstructions200Response' (by applying it's required fields, if any)
mkAnalyzeRecipeInstructions200Response
  :: [AnalyzeRecipeInstructions200ResponseParsedInstructionsInner] -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructions' 
  -> [AnalyzeRecipeInstructions200ResponseIngredientsInner] -- ^ 'analyzeRecipeInstructions200ResponseIngredients' 
  -> [AnalyzeRecipeInstructions200ResponseIngredientsInner] -- ^ 'analyzeRecipeInstructions200ResponseEquipment' 
  -> AnalyzeRecipeInstructions200Response
mkAnalyzeRecipeInstructions200Response analyzeRecipeInstructions200ResponseParsedInstructions analyzeRecipeInstructions200ResponseIngredients analyzeRecipeInstructions200ResponseEquipment =
  AnalyzeRecipeInstructions200Response
  { analyzeRecipeInstructions200ResponseParsedInstructions
  , analyzeRecipeInstructions200ResponseIngredients
  , analyzeRecipeInstructions200ResponseEquipment
  }

-- ** AnalyzeRecipeInstructions200ResponseIngredientsInner
-- | AnalyzeRecipeInstructions200ResponseIngredientsInner
data AnalyzeRecipeInstructions200ResponseIngredientsInner = AnalyzeRecipeInstructions200ResponseIngredientsInner
  { analyzeRecipeInstructions200ResponseIngredientsInnerId :: !(Double) -- ^ /Required/ "id"
  , analyzeRecipeInstructions200ResponseIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeRecipeInstructions200ResponseIngredientsInner
instance A.FromJSON AnalyzeRecipeInstructions200ResponseIngredientsInner where
  parseJSON = A.withObject "AnalyzeRecipeInstructions200ResponseIngredientsInner" $ \o ->
    AnalyzeRecipeInstructions200ResponseIngredientsInner
      <$> (o .:  "id")
      <*> (o .:  "name")

-- | ToJSON AnalyzeRecipeInstructions200ResponseIngredientsInner
instance A.ToJSON AnalyzeRecipeInstructions200ResponseIngredientsInner where
  toJSON AnalyzeRecipeInstructions200ResponseIngredientsInner {..} =
   _omitNulls
      [ "id" .= analyzeRecipeInstructions200ResponseIngredientsInnerId
      , "name" .= analyzeRecipeInstructions200ResponseIngredientsInnerName
      ]


-- | Construct a value of type 'AnalyzeRecipeInstructions200ResponseIngredientsInner' (by applying it's required fields, if any)
mkAnalyzeRecipeInstructions200ResponseIngredientsInner
  :: Double -- ^ 'analyzeRecipeInstructions200ResponseIngredientsInnerId' 
  -> Text -- ^ 'analyzeRecipeInstructions200ResponseIngredientsInnerName' 
  -> AnalyzeRecipeInstructions200ResponseIngredientsInner
mkAnalyzeRecipeInstructions200ResponseIngredientsInner analyzeRecipeInstructions200ResponseIngredientsInnerId analyzeRecipeInstructions200ResponseIngredientsInnerName =
  AnalyzeRecipeInstructions200ResponseIngredientsInner
  { analyzeRecipeInstructions200ResponseIngredientsInnerId
  , analyzeRecipeInstructions200ResponseIngredientsInnerName
  }

-- ** AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
-- | AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
data AnalyzeRecipeInstructions200ResponseParsedInstructionsInner = AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
  { analyzeRecipeInstructions200ResponseParsedInstructionsInnerName :: !(Text) -- ^ /Required/ "name"
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerSteps :: !(Maybe [AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner]) -- ^ "steps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
instance A.FromJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInner where
  parseJSON = A.withObject "AnalyzeRecipeInstructions200ResponseParsedInstructionsInner" $ \o ->
    AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
      <$> (o .:  "name")
      <*> (o .:? "steps")

-- | ToJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
instance A.ToJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInner where
  toJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInner {..} =
   _omitNulls
      [ "name" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerName
      , "steps" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerSteps
      ]


-- | Construct a value of type 'AnalyzeRecipeInstructions200ResponseParsedInstructionsInner' (by applying it's required fields, if any)
mkAnalyzeRecipeInstructions200ResponseParsedInstructionsInner
  :: Text -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructionsInnerName' 
  -> AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
mkAnalyzeRecipeInstructions200ResponseParsedInstructionsInner analyzeRecipeInstructions200ResponseParsedInstructionsInnerName =
  AnalyzeRecipeInstructions200ResponseParsedInstructionsInner
  { analyzeRecipeInstructions200ResponseParsedInstructionsInnerName
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerSteps = Nothing
  }

-- ** AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
-- | AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
data AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner = AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
  { analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber :: !(Double) -- ^ /Required/ "number"
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep :: !(Text) -- ^ /Required/ "step"
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredients :: !(Maybe [AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner]) -- ^ "ingredients"
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerEquipment :: !(Maybe [AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner]) -- ^ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
instance A.FromJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner where
  parseJSON = A.withObject "AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner" $ \o ->
    AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
      <$> (o .:  "number")
      <*> (o .:  "step")
      <*> (o .:? "ingredients")
      <*> (o .:? "equipment")

-- | ToJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
instance A.ToJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner where
  toJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner {..} =
   _omitNulls
      [ "number" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber
      , "step" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep
      , "ingredients" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredients
      , "equipment" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerEquipment
      ]


-- | Construct a value of type 'AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner' (by applying it's required fields, if any)
mkAnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
  :: Double -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber' 
  -> Text -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep' 
  -> AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
mkAnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep =
  AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
  { analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredients = Nothing
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerEquipment = Nothing
  }

-- ** AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
-- | AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
data AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner = AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
  { analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId :: !(Double) -- ^ /Required/ "id"
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName :: !(Text) -- ^ /Required/ "localizedName"
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage :: !(Text) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
instance A.FromJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner where
  parseJSON = A.withObject "AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner" $ \o ->
    AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "localizedName")
      <*> (o .:  "image")

-- | ToJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
instance A.ToJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner where
  toJSON AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner {..} =
   _omitNulls
      [ "id" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId
      , "name" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName
      , "localizedName" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName
      , "image" .= analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage
      ]


-- | Construct a value of type 'AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner' (by applying it's required fields, if any)
mkAnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
  :: Double -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId' 
  -> Text -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName' 
  -> Text -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName' 
  -> Text -- ^ 'analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage' 
  -> AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
mkAnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage =
  AnalyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
  { analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName
  , analyzeRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage
  }

-- ** AutocompleteIngredientSearch200ResponseInner
-- | AutocompleteIngredientSearch200ResponseInner
data AutocompleteIngredientSearch200ResponseInner = AutocompleteIngredientSearch200ResponseInner
  { autocompleteIngredientSearch200ResponseInnerName :: !(Text) -- ^ /Required/ "name"
  , autocompleteIngredientSearch200ResponseInnerImage :: !(Text) -- ^ /Required/ "image"
  , autocompleteIngredientSearch200ResponseInnerId :: !(Maybe Int) -- ^ "id"
  , autocompleteIngredientSearch200ResponseInnerAisle :: !(Maybe Text) -- ^ "aisle"
  , autocompleteIngredientSearch200ResponseInnerPossibleUnits :: !(Maybe [Text]) -- ^ "possibleUnits"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutocompleteIngredientSearch200ResponseInner
instance A.FromJSON AutocompleteIngredientSearch200ResponseInner where
  parseJSON = A.withObject "AutocompleteIngredientSearch200ResponseInner" $ \o ->
    AutocompleteIngredientSearch200ResponseInner
      <$> (o .:  "name")
      <*> (o .:  "image")
      <*> (o .:? "id")
      <*> (o .:? "aisle")
      <*> (o .:? "possibleUnits")

-- | ToJSON AutocompleteIngredientSearch200ResponseInner
instance A.ToJSON AutocompleteIngredientSearch200ResponseInner where
  toJSON AutocompleteIngredientSearch200ResponseInner {..} =
   _omitNulls
      [ "name" .= autocompleteIngredientSearch200ResponseInnerName
      , "image" .= autocompleteIngredientSearch200ResponseInnerImage
      , "id" .= autocompleteIngredientSearch200ResponseInnerId
      , "aisle" .= autocompleteIngredientSearch200ResponseInnerAisle
      , "possibleUnits" .= autocompleteIngredientSearch200ResponseInnerPossibleUnits
      ]


-- | Construct a value of type 'AutocompleteIngredientSearch200ResponseInner' (by applying it's required fields, if any)
mkAutocompleteIngredientSearch200ResponseInner
  :: Text -- ^ 'autocompleteIngredientSearch200ResponseInnerName' 
  -> Text -- ^ 'autocompleteIngredientSearch200ResponseInnerImage' 
  -> AutocompleteIngredientSearch200ResponseInner
mkAutocompleteIngredientSearch200ResponseInner autocompleteIngredientSearch200ResponseInnerName autocompleteIngredientSearch200ResponseInnerImage =
  AutocompleteIngredientSearch200ResponseInner
  { autocompleteIngredientSearch200ResponseInnerName
  , autocompleteIngredientSearch200ResponseInnerImage
  , autocompleteIngredientSearch200ResponseInnerId = Nothing
  , autocompleteIngredientSearch200ResponseInnerAisle = Nothing
  , autocompleteIngredientSearch200ResponseInnerPossibleUnits = Nothing
  }

-- ** AutocompleteMenuItemSearch200Response
-- | AutocompleteMenuItemSearch200Response
-- 
data AutocompleteMenuItemSearch200Response = AutocompleteMenuItemSearch200Response
  { autocompleteMenuItemSearch200ResponseResults :: !([AutocompleteProductSearch200ResponseResultsInner]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutocompleteMenuItemSearch200Response
instance A.FromJSON AutocompleteMenuItemSearch200Response where
  parseJSON = A.withObject "AutocompleteMenuItemSearch200Response" $ \o ->
    AutocompleteMenuItemSearch200Response
      <$> (o .:  "results")

-- | ToJSON AutocompleteMenuItemSearch200Response
instance A.ToJSON AutocompleteMenuItemSearch200Response where
  toJSON AutocompleteMenuItemSearch200Response {..} =
   _omitNulls
      [ "results" .= autocompleteMenuItemSearch200ResponseResults
      ]


-- | Construct a value of type 'AutocompleteMenuItemSearch200Response' (by applying it's required fields, if any)
mkAutocompleteMenuItemSearch200Response
  :: [AutocompleteProductSearch200ResponseResultsInner] -- ^ 'autocompleteMenuItemSearch200ResponseResults' 
  -> AutocompleteMenuItemSearch200Response
mkAutocompleteMenuItemSearch200Response autocompleteMenuItemSearch200ResponseResults =
  AutocompleteMenuItemSearch200Response
  { autocompleteMenuItemSearch200ResponseResults
  }

-- ** AutocompleteProductSearch200Response
-- | AutocompleteProductSearch200Response
-- 
data AutocompleteProductSearch200Response = AutocompleteProductSearch200Response
  { autocompleteProductSearch200ResponseResults :: !([AutocompleteProductSearch200ResponseResultsInner]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutocompleteProductSearch200Response
instance A.FromJSON AutocompleteProductSearch200Response where
  parseJSON = A.withObject "AutocompleteProductSearch200Response" $ \o ->
    AutocompleteProductSearch200Response
      <$> (o .:  "results")

-- | ToJSON AutocompleteProductSearch200Response
instance A.ToJSON AutocompleteProductSearch200Response where
  toJSON AutocompleteProductSearch200Response {..} =
   _omitNulls
      [ "results" .= autocompleteProductSearch200ResponseResults
      ]


-- | Construct a value of type 'AutocompleteProductSearch200Response' (by applying it's required fields, if any)
mkAutocompleteProductSearch200Response
  :: [AutocompleteProductSearch200ResponseResultsInner] -- ^ 'autocompleteProductSearch200ResponseResults' 
  -> AutocompleteProductSearch200Response
mkAutocompleteProductSearch200Response autocompleteProductSearch200ResponseResults =
  AutocompleteProductSearch200Response
  { autocompleteProductSearch200ResponseResults
  }

-- ** AutocompleteProductSearch200ResponseResultsInner
-- | AutocompleteProductSearch200ResponseResultsInner
data AutocompleteProductSearch200ResponseResultsInner = AutocompleteProductSearch200ResponseResultsInner
  { autocompleteProductSearch200ResponseResultsInnerId :: !(Int) -- ^ /Required/ "id"
  , autocompleteProductSearch200ResponseResultsInnerTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutocompleteProductSearch200ResponseResultsInner
instance A.FromJSON AutocompleteProductSearch200ResponseResultsInner where
  parseJSON = A.withObject "AutocompleteProductSearch200ResponseResultsInner" $ \o ->
    AutocompleteProductSearch200ResponseResultsInner
      <$> (o .:  "id")
      <*> (o .:  "title")

-- | ToJSON AutocompleteProductSearch200ResponseResultsInner
instance A.ToJSON AutocompleteProductSearch200ResponseResultsInner where
  toJSON AutocompleteProductSearch200ResponseResultsInner {..} =
   _omitNulls
      [ "id" .= autocompleteProductSearch200ResponseResultsInnerId
      , "title" .= autocompleteProductSearch200ResponseResultsInnerTitle
      ]


-- | Construct a value of type 'AutocompleteProductSearch200ResponseResultsInner' (by applying it's required fields, if any)
mkAutocompleteProductSearch200ResponseResultsInner
  :: Int -- ^ 'autocompleteProductSearch200ResponseResultsInnerId' 
  -> Text -- ^ 'autocompleteProductSearch200ResponseResultsInnerTitle' 
  -> AutocompleteProductSearch200ResponseResultsInner
mkAutocompleteProductSearch200ResponseResultsInner autocompleteProductSearch200ResponseResultsInnerId autocompleteProductSearch200ResponseResultsInnerTitle =
  AutocompleteProductSearch200ResponseResultsInner
  { autocompleteProductSearch200ResponseResultsInnerId
  , autocompleteProductSearch200ResponseResultsInnerTitle
  }

-- ** AutocompleteRecipeSearch200ResponseInner
-- | AutocompleteRecipeSearch200ResponseInner
data AutocompleteRecipeSearch200ResponseInner = AutocompleteRecipeSearch200ResponseInner
  { autocompleteRecipeSearch200ResponseInnerId :: !(Int) -- ^ /Required/ "id"
  , autocompleteRecipeSearch200ResponseInnerTitle :: !(Text) -- ^ /Required/ "title"
  , autocompleteRecipeSearch200ResponseInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutocompleteRecipeSearch200ResponseInner
instance A.FromJSON AutocompleteRecipeSearch200ResponseInner where
  parseJSON = A.withObject "AutocompleteRecipeSearch200ResponseInner" $ \o ->
    AutocompleteRecipeSearch200ResponseInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")

-- | ToJSON AutocompleteRecipeSearch200ResponseInner
instance A.ToJSON AutocompleteRecipeSearch200ResponseInner where
  toJSON AutocompleteRecipeSearch200ResponseInner {..} =
   _omitNulls
      [ "id" .= autocompleteRecipeSearch200ResponseInnerId
      , "title" .= autocompleteRecipeSearch200ResponseInnerTitle
      , "imageType" .= autocompleteRecipeSearch200ResponseInnerImageType
      ]


-- | Construct a value of type 'AutocompleteRecipeSearch200ResponseInner' (by applying it's required fields, if any)
mkAutocompleteRecipeSearch200ResponseInner
  :: Int -- ^ 'autocompleteRecipeSearch200ResponseInnerId' 
  -> Text -- ^ 'autocompleteRecipeSearch200ResponseInnerTitle' 
  -> Text -- ^ 'autocompleteRecipeSearch200ResponseInnerImageType' 
  -> AutocompleteRecipeSearch200ResponseInner
mkAutocompleteRecipeSearch200ResponseInner autocompleteRecipeSearch200ResponseInnerId autocompleteRecipeSearch200ResponseInnerTitle autocompleteRecipeSearch200ResponseInnerImageType =
  AutocompleteRecipeSearch200ResponseInner
  { autocompleteRecipeSearch200ResponseInnerId
  , autocompleteRecipeSearch200ResponseInnerTitle
  , autocompleteRecipeSearch200ResponseInnerImageType
  }

-- ** ClassifyCuisine200Response
-- | ClassifyCuisine200Response
-- 
data ClassifyCuisine200Response = ClassifyCuisine200Response
  { classifyCuisine200ResponseCuisine :: !(Text) -- ^ /Required/ "cuisine"
  , classifyCuisine200ResponseCuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , classifyCuisine200ResponseConfidence :: !(Double) -- ^ /Required/ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClassifyCuisine200Response
instance A.FromJSON ClassifyCuisine200Response where
  parseJSON = A.withObject "ClassifyCuisine200Response" $ \o ->
    ClassifyCuisine200Response
      <$> (o .:  "cuisine")
      <*> (o .:  "cuisines")
      <*> (o .:  "confidence")

-- | ToJSON ClassifyCuisine200Response
instance A.ToJSON ClassifyCuisine200Response where
  toJSON ClassifyCuisine200Response {..} =
   _omitNulls
      [ "cuisine" .= classifyCuisine200ResponseCuisine
      , "cuisines" .= classifyCuisine200ResponseCuisines
      , "confidence" .= classifyCuisine200ResponseConfidence
      ]


-- | Construct a value of type 'ClassifyCuisine200Response' (by applying it's required fields, if any)
mkClassifyCuisine200Response
  :: Text -- ^ 'classifyCuisine200ResponseCuisine' 
  -> [Text] -- ^ 'classifyCuisine200ResponseCuisines' 
  -> Double -- ^ 'classifyCuisine200ResponseConfidence' 
  -> ClassifyCuisine200Response
mkClassifyCuisine200Response classifyCuisine200ResponseCuisine classifyCuisine200ResponseCuisines classifyCuisine200ResponseConfidence =
  ClassifyCuisine200Response
  { classifyCuisine200ResponseCuisine
  , classifyCuisine200ResponseCuisines
  , classifyCuisine200ResponseConfidence
  }

-- ** ClassifyGroceryProduct200Response
-- | ClassifyGroceryProduct200Response
-- 
data ClassifyGroceryProduct200Response = ClassifyGroceryProduct200Response
  { classifyGroceryProduct200ResponseCleanTitle :: !(Text) -- ^ /Required/ "cleanTitle"
  , classifyGroceryProduct200ResponseImage :: !(Text) -- ^ /Required/ "image"
  , classifyGroceryProduct200ResponseCategory :: !(Text) -- ^ /Required/ "category"
  , classifyGroceryProduct200ResponseBreadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , classifyGroceryProduct200ResponseUsdaCode :: !(Int) -- ^ /Required/ "usdaCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClassifyGroceryProduct200Response
instance A.FromJSON ClassifyGroceryProduct200Response where
  parseJSON = A.withObject "ClassifyGroceryProduct200Response" $ \o ->
    ClassifyGroceryProduct200Response
      <$> (o .:  "cleanTitle")
      <*> (o .:  "image")
      <*> (o .:  "category")
      <*> (o .:  "breadcrumbs")
      <*> (o .:  "usdaCode")

-- | ToJSON ClassifyGroceryProduct200Response
instance A.ToJSON ClassifyGroceryProduct200Response where
  toJSON ClassifyGroceryProduct200Response {..} =
   _omitNulls
      [ "cleanTitle" .= classifyGroceryProduct200ResponseCleanTitle
      , "image" .= classifyGroceryProduct200ResponseImage
      , "category" .= classifyGroceryProduct200ResponseCategory
      , "breadcrumbs" .= classifyGroceryProduct200ResponseBreadcrumbs
      , "usdaCode" .= classifyGroceryProduct200ResponseUsdaCode
      ]


-- | Construct a value of type 'ClassifyGroceryProduct200Response' (by applying it's required fields, if any)
mkClassifyGroceryProduct200Response
  :: Text -- ^ 'classifyGroceryProduct200ResponseCleanTitle' 
  -> Text -- ^ 'classifyGroceryProduct200ResponseImage' 
  -> Text -- ^ 'classifyGroceryProduct200ResponseCategory' 
  -> [Text] -- ^ 'classifyGroceryProduct200ResponseBreadcrumbs' 
  -> Int -- ^ 'classifyGroceryProduct200ResponseUsdaCode' 
  -> ClassifyGroceryProduct200Response
mkClassifyGroceryProduct200Response classifyGroceryProduct200ResponseCleanTitle classifyGroceryProduct200ResponseImage classifyGroceryProduct200ResponseCategory classifyGroceryProduct200ResponseBreadcrumbs classifyGroceryProduct200ResponseUsdaCode =
  ClassifyGroceryProduct200Response
  { classifyGroceryProduct200ResponseCleanTitle
  , classifyGroceryProduct200ResponseImage
  , classifyGroceryProduct200ResponseCategory
  , classifyGroceryProduct200ResponseBreadcrumbs
  , classifyGroceryProduct200ResponseUsdaCode
  }

-- ** ClassifyGroceryProductBulk200ResponseInner
-- | ClassifyGroceryProductBulk200ResponseInner
data ClassifyGroceryProductBulk200ResponseInner = ClassifyGroceryProductBulk200ResponseInner
  { classifyGroceryProductBulk200ResponseInnerCleanTitle :: !(Text) -- ^ /Required/ "cleanTitle"
  , classifyGroceryProductBulk200ResponseInnerImage :: !(Text) -- ^ /Required/ "image"
  , classifyGroceryProductBulk200ResponseInnerCategory :: !(Text) -- ^ /Required/ "category"
  , classifyGroceryProductBulk200ResponseInnerBreadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , classifyGroceryProductBulk200ResponseInnerUsdaCode :: !(Int) -- ^ /Required/ "usdaCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClassifyGroceryProductBulk200ResponseInner
instance A.FromJSON ClassifyGroceryProductBulk200ResponseInner where
  parseJSON = A.withObject "ClassifyGroceryProductBulk200ResponseInner" $ \o ->
    ClassifyGroceryProductBulk200ResponseInner
      <$> (o .:  "cleanTitle")
      <*> (o .:  "image")
      <*> (o .:  "category")
      <*> (o .:  "breadcrumbs")
      <*> (o .:  "usdaCode")

-- | ToJSON ClassifyGroceryProductBulk200ResponseInner
instance A.ToJSON ClassifyGroceryProductBulk200ResponseInner where
  toJSON ClassifyGroceryProductBulk200ResponseInner {..} =
   _omitNulls
      [ "cleanTitle" .= classifyGroceryProductBulk200ResponseInnerCleanTitle
      , "image" .= classifyGroceryProductBulk200ResponseInnerImage
      , "category" .= classifyGroceryProductBulk200ResponseInnerCategory
      , "breadcrumbs" .= classifyGroceryProductBulk200ResponseInnerBreadcrumbs
      , "usdaCode" .= classifyGroceryProductBulk200ResponseInnerUsdaCode
      ]


-- | Construct a value of type 'ClassifyGroceryProductBulk200ResponseInner' (by applying it's required fields, if any)
mkClassifyGroceryProductBulk200ResponseInner
  :: Text -- ^ 'classifyGroceryProductBulk200ResponseInnerCleanTitle' 
  -> Text -- ^ 'classifyGroceryProductBulk200ResponseInnerImage' 
  -> Text -- ^ 'classifyGroceryProductBulk200ResponseInnerCategory' 
  -> [Text] -- ^ 'classifyGroceryProductBulk200ResponseInnerBreadcrumbs' 
  -> Int -- ^ 'classifyGroceryProductBulk200ResponseInnerUsdaCode' 
  -> ClassifyGroceryProductBulk200ResponseInner
mkClassifyGroceryProductBulk200ResponseInner classifyGroceryProductBulk200ResponseInnerCleanTitle classifyGroceryProductBulk200ResponseInnerImage classifyGroceryProductBulk200ResponseInnerCategory classifyGroceryProductBulk200ResponseInnerBreadcrumbs classifyGroceryProductBulk200ResponseInnerUsdaCode =
  ClassifyGroceryProductBulk200ResponseInner
  { classifyGroceryProductBulk200ResponseInnerCleanTitle
  , classifyGroceryProductBulk200ResponseInnerImage
  , classifyGroceryProductBulk200ResponseInnerCategory
  , classifyGroceryProductBulk200ResponseInnerBreadcrumbs
  , classifyGroceryProductBulk200ResponseInnerUsdaCode
  }

-- ** ClassifyGroceryProductBulkRequestInner
-- | ClassifyGroceryProductBulkRequestInner
data ClassifyGroceryProductBulkRequestInner = ClassifyGroceryProductBulkRequestInner
  { classifyGroceryProductBulkRequestInnerTitle :: !(Text) -- ^ /Required/ "title"
  , classifyGroceryProductBulkRequestInnerUpc :: !(Text) -- ^ /Required/ "upc"
  , classifyGroceryProductBulkRequestInnerPluCode :: !(Text) -- ^ /Required/ "plu_code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClassifyGroceryProductBulkRequestInner
instance A.FromJSON ClassifyGroceryProductBulkRequestInner where
  parseJSON = A.withObject "ClassifyGroceryProductBulkRequestInner" $ \o ->
    ClassifyGroceryProductBulkRequestInner
      <$> (o .:  "title")
      <*> (o .:  "upc")
      <*> (o .:  "plu_code")

-- | ToJSON ClassifyGroceryProductBulkRequestInner
instance A.ToJSON ClassifyGroceryProductBulkRequestInner where
  toJSON ClassifyGroceryProductBulkRequestInner {..} =
   _omitNulls
      [ "title" .= classifyGroceryProductBulkRequestInnerTitle
      , "upc" .= classifyGroceryProductBulkRequestInnerUpc
      , "plu_code" .= classifyGroceryProductBulkRequestInnerPluCode
      ]


-- | Construct a value of type 'ClassifyGroceryProductBulkRequestInner' (by applying it's required fields, if any)
mkClassifyGroceryProductBulkRequestInner
  :: Text -- ^ 'classifyGroceryProductBulkRequestInnerTitle' 
  -> Text -- ^ 'classifyGroceryProductBulkRequestInnerUpc' 
  -> Text -- ^ 'classifyGroceryProductBulkRequestInnerPluCode' 
  -> ClassifyGroceryProductBulkRequestInner
mkClassifyGroceryProductBulkRequestInner classifyGroceryProductBulkRequestInnerTitle classifyGroceryProductBulkRequestInnerUpc classifyGroceryProductBulkRequestInnerPluCode =
  ClassifyGroceryProductBulkRequestInner
  { classifyGroceryProductBulkRequestInnerTitle
  , classifyGroceryProductBulkRequestInnerUpc
  , classifyGroceryProductBulkRequestInnerPluCode
  }

-- ** ClassifyGroceryProductRequest
-- | ClassifyGroceryProductRequest
-- 
data ClassifyGroceryProductRequest = ClassifyGroceryProductRequest
  { classifyGroceryProductRequestTitle :: !(Text) -- ^ /Required/ "title"
  , classifyGroceryProductRequestUpc :: !(Text) -- ^ /Required/ "upc"
  , classifyGroceryProductRequestPluCode :: !(Text) -- ^ /Required/ "plu_code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClassifyGroceryProductRequest
instance A.FromJSON ClassifyGroceryProductRequest where
  parseJSON = A.withObject "ClassifyGroceryProductRequest" $ \o ->
    ClassifyGroceryProductRequest
      <$> (o .:  "title")
      <*> (o .:  "upc")
      <*> (o .:  "plu_code")

-- | ToJSON ClassifyGroceryProductRequest
instance A.ToJSON ClassifyGroceryProductRequest where
  toJSON ClassifyGroceryProductRequest {..} =
   _omitNulls
      [ "title" .= classifyGroceryProductRequestTitle
      , "upc" .= classifyGroceryProductRequestUpc
      , "plu_code" .= classifyGroceryProductRequestPluCode
      ]


-- | Construct a value of type 'ClassifyGroceryProductRequest' (by applying it's required fields, if any)
mkClassifyGroceryProductRequest
  :: Text -- ^ 'classifyGroceryProductRequestTitle' 
  -> Text -- ^ 'classifyGroceryProductRequestUpc' 
  -> Text -- ^ 'classifyGroceryProductRequestPluCode' 
  -> ClassifyGroceryProductRequest
mkClassifyGroceryProductRequest classifyGroceryProductRequestTitle classifyGroceryProductRequestUpc classifyGroceryProductRequestPluCode =
  ClassifyGroceryProductRequest
  { classifyGroceryProductRequestTitle
  , classifyGroceryProductRequestUpc
  , classifyGroceryProductRequestPluCode
  }

-- ** ClearMealPlanDayRequest
-- | ClearMealPlanDayRequest
data ClearMealPlanDayRequest = ClearMealPlanDayRequest
  { clearMealPlanDayRequestUsername :: !(Text) -- ^ /Required/ "username" - The username.
  , clearMealPlanDayRequestDate :: !(Text) -- ^ /Required/ "date" - The date in the format yyyy-mm-dd.
  , clearMealPlanDayRequestHash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClearMealPlanDayRequest
instance A.FromJSON ClearMealPlanDayRequest where
  parseJSON = A.withObject "ClearMealPlanDayRequest" $ \o ->
    ClearMealPlanDayRequest
      <$> (o .:  "username")
      <*> (o .:  "date")
      <*> (o .:  "hash")

-- | ToJSON ClearMealPlanDayRequest
instance A.ToJSON ClearMealPlanDayRequest where
  toJSON ClearMealPlanDayRequest {..} =
   _omitNulls
      [ "username" .= clearMealPlanDayRequestUsername
      , "date" .= clearMealPlanDayRequestDate
      , "hash" .= clearMealPlanDayRequestHash
      ]


-- | Construct a value of type 'ClearMealPlanDayRequest' (by applying it's required fields, if any)
mkClearMealPlanDayRequest
  :: Text -- ^ 'clearMealPlanDayRequestUsername': The username.
  -> Text -- ^ 'clearMealPlanDayRequestDate': The date in the format yyyy-mm-dd.
  -> Text -- ^ 'clearMealPlanDayRequestHash': The private hash for the username.
  -> ClearMealPlanDayRequest
mkClearMealPlanDayRequest clearMealPlanDayRequestUsername clearMealPlanDayRequestDate clearMealPlanDayRequestHash =
  ClearMealPlanDayRequest
  { clearMealPlanDayRequestUsername
  , clearMealPlanDayRequestDate
  , clearMealPlanDayRequestHash
  }

-- ** ComputeGlycemicLoad200Response
-- | ComputeGlycemicLoad200Response
-- 
data ComputeGlycemicLoad200Response = ComputeGlycemicLoad200Response
  { computeGlycemicLoad200ResponseTotalGlycemicLoad :: !(Double) -- ^ /Required/ "totalGlycemicLoad"
  , computeGlycemicLoad200ResponseIngredients :: !([ComputeGlycemicLoad200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputeGlycemicLoad200Response
instance A.FromJSON ComputeGlycemicLoad200Response where
  parseJSON = A.withObject "ComputeGlycemicLoad200Response" $ \o ->
    ComputeGlycemicLoad200Response
      <$> (o .:  "totalGlycemicLoad")
      <*> (o .:  "ingredients")

-- | ToJSON ComputeGlycemicLoad200Response
instance A.ToJSON ComputeGlycemicLoad200Response where
  toJSON ComputeGlycemicLoad200Response {..} =
   _omitNulls
      [ "totalGlycemicLoad" .= computeGlycemicLoad200ResponseTotalGlycemicLoad
      , "ingredients" .= computeGlycemicLoad200ResponseIngredients
      ]


-- | Construct a value of type 'ComputeGlycemicLoad200Response' (by applying it's required fields, if any)
mkComputeGlycemicLoad200Response
  :: Double -- ^ 'computeGlycemicLoad200ResponseTotalGlycemicLoad' 
  -> [ComputeGlycemicLoad200ResponseIngredientsInner] -- ^ 'computeGlycemicLoad200ResponseIngredients' 
  -> ComputeGlycemicLoad200Response
mkComputeGlycemicLoad200Response computeGlycemicLoad200ResponseTotalGlycemicLoad computeGlycemicLoad200ResponseIngredients =
  ComputeGlycemicLoad200Response
  { computeGlycemicLoad200ResponseTotalGlycemicLoad
  , computeGlycemicLoad200ResponseIngredients
  }

-- ** ComputeGlycemicLoad200ResponseIngredientsInner
-- | ComputeGlycemicLoad200ResponseIngredientsInner
data ComputeGlycemicLoad200ResponseIngredientsInner = ComputeGlycemicLoad200ResponseIngredientsInner
  { computeGlycemicLoad200ResponseIngredientsInnerId :: !(Int) -- ^ /Required/ "id"
  , computeGlycemicLoad200ResponseIngredientsInnerOriginal :: !(Text) -- ^ /Required/ "original"
  , computeGlycemicLoad200ResponseIngredientsInnerGlycemicIndex :: !(Double) -- ^ /Required/ "glycemicIndex"
  , computeGlycemicLoad200ResponseIngredientsInnerGlycemicLoad :: !(Double) -- ^ /Required/ "glycemicLoad"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputeGlycemicLoad200ResponseIngredientsInner
instance A.FromJSON ComputeGlycemicLoad200ResponseIngredientsInner where
  parseJSON = A.withObject "ComputeGlycemicLoad200ResponseIngredientsInner" $ \o ->
    ComputeGlycemicLoad200ResponseIngredientsInner
      <$> (o .:  "id")
      <*> (o .:  "original")
      <*> (o .:  "glycemicIndex")
      <*> (o .:  "glycemicLoad")

-- | ToJSON ComputeGlycemicLoad200ResponseIngredientsInner
instance A.ToJSON ComputeGlycemicLoad200ResponseIngredientsInner where
  toJSON ComputeGlycemicLoad200ResponseIngredientsInner {..} =
   _omitNulls
      [ "id" .= computeGlycemicLoad200ResponseIngredientsInnerId
      , "original" .= computeGlycemicLoad200ResponseIngredientsInnerOriginal
      , "glycemicIndex" .= computeGlycemicLoad200ResponseIngredientsInnerGlycemicIndex
      , "glycemicLoad" .= computeGlycemicLoad200ResponseIngredientsInnerGlycemicLoad
      ]


-- | Construct a value of type 'ComputeGlycemicLoad200ResponseIngredientsInner' (by applying it's required fields, if any)
mkComputeGlycemicLoad200ResponseIngredientsInner
  :: Int -- ^ 'computeGlycemicLoad200ResponseIngredientsInnerId' 
  -> Text -- ^ 'computeGlycemicLoad200ResponseIngredientsInnerOriginal' 
  -> Double -- ^ 'computeGlycemicLoad200ResponseIngredientsInnerGlycemicIndex' 
  -> Double -- ^ 'computeGlycemicLoad200ResponseIngredientsInnerGlycemicLoad' 
  -> ComputeGlycemicLoad200ResponseIngredientsInner
mkComputeGlycemicLoad200ResponseIngredientsInner computeGlycemicLoad200ResponseIngredientsInnerId computeGlycemicLoad200ResponseIngredientsInnerOriginal computeGlycemicLoad200ResponseIngredientsInnerGlycemicIndex computeGlycemicLoad200ResponseIngredientsInnerGlycemicLoad =
  ComputeGlycemicLoad200ResponseIngredientsInner
  { computeGlycemicLoad200ResponseIngredientsInnerId
  , computeGlycemicLoad200ResponseIngredientsInnerOriginal
  , computeGlycemicLoad200ResponseIngredientsInnerGlycemicIndex
  , computeGlycemicLoad200ResponseIngredientsInnerGlycemicLoad
  }

-- ** ComputeGlycemicLoadRequest
-- | ComputeGlycemicLoadRequest
-- 
data ComputeGlycemicLoadRequest = ComputeGlycemicLoadRequest
  { computeGlycemicLoadRequestIngredients :: !([Text]) -- ^ /Required/ "ingredients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputeGlycemicLoadRequest
instance A.FromJSON ComputeGlycemicLoadRequest where
  parseJSON = A.withObject "ComputeGlycemicLoadRequest" $ \o ->
    ComputeGlycemicLoadRequest
      <$> (o .:  "ingredients")

-- | ToJSON ComputeGlycemicLoadRequest
instance A.ToJSON ComputeGlycemicLoadRequest where
  toJSON ComputeGlycemicLoadRequest {..} =
   _omitNulls
      [ "ingredients" .= computeGlycemicLoadRequestIngredients
      ]


-- | Construct a value of type 'ComputeGlycemicLoadRequest' (by applying it's required fields, if any)
mkComputeGlycemicLoadRequest
  :: [Text] -- ^ 'computeGlycemicLoadRequestIngredients' 
  -> ComputeGlycemicLoadRequest
mkComputeGlycemicLoadRequest computeGlycemicLoadRequestIngredients =
  ComputeGlycemicLoadRequest
  { computeGlycemicLoadRequestIngredients
  }

-- ** ComputeIngredientAmount200Response
-- | ComputeIngredientAmount200Response
-- 
data ComputeIngredientAmount200Response = ComputeIngredientAmount200Response
  { computeIngredientAmount200ResponseAmount :: !(Double) -- ^ /Required/ "amount"
  , computeIngredientAmount200ResponseUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputeIngredientAmount200Response
instance A.FromJSON ComputeIngredientAmount200Response where
  parseJSON = A.withObject "ComputeIngredientAmount200Response" $ \o ->
    ComputeIngredientAmount200Response
      <$> (o .:  "amount")
      <*> (o .:  "unit")

-- | ToJSON ComputeIngredientAmount200Response
instance A.ToJSON ComputeIngredientAmount200Response where
  toJSON ComputeIngredientAmount200Response {..} =
   _omitNulls
      [ "amount" .= computeIngredientAmount200ResponseAmount
      , "unit" .= computeIngredientAmount200ResponseUnit
      ]


-- | Construct a value of type 'ComputeIngredientAmount200Response' (by applying it's required fields, if any)
mkComputeIngredientAmount200Response
  :: Double -- ^ 'computeIngredientAmount200ResponseAmount' 
  -> Text -- ^ 'computeIngredientAmount200ResponseUnit' 
  -> ComputeIngredientAmount200Response
mkComputeIngredientAmount200Response computeIngredientAmount200ResponseAmount computeIngredientAmount200ResponseUnit =
  ComputeIngredientAmount200Response
  { computeIngredientAmount200ResponseAmount
  , computeIngredientAmount200ResponseUnit
  }

-- ** ConnectUser200Response
-- | ConnectUser200Response
-- 
data ConnectUser200Response = ConnectUser200Response
  { connectUser200ResponseUsername :: !(Text) -- ^ /Required/ "username"
  , connectUser200ResponseHash :: !(Text) -- ^ /Required/ "hash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConnectUser200Response
instance A.FromJSON ConnectUser200Response where
  parseJSON = A.withObject "ConnectUser200Response" $ \o ->
    ConnectUser200Response
      <$> (o .:  "username")
      <*> (o .:  "hash")

-- | ToJSON ConnectUser200Response
instance A.ToJSON ConnectUser200Response where
  toJSON ConnectUser200Response {..} =
   _omitNulls
      [ "username" .= connectUser200ResponseUsername
      , "hash" .= connectUser200ResponseHash
      ]


-- | Construct a value of type 'ConnectUser200Response' (by applying it's required fields, if any)
mkConnectUser200Response
  :: Text -- ^ 'connectUser200ResponseUsername' 
  -> Text -- ^ 'connectUser200ResponseHash' 
  -> ConnectUser200Response
mkConnectUser200Response connectUser200ResponseUsername connectUser200ResponseHash =
  ConnectUser200Response
  { connectUser200ResponseUsername
  , connectUser200ResponseHash
  }

-- ** ConnectUserRequest
-- | ConnectUserRequest
-- 
data ConnectUserRequest = ConnectUserRequest
  { connectUserRequestUsername :: !(Text) -- ^ /Required/ "username"
  , connectUserRequestFirstName :: !(Text) -- ^ /Required/ "firstName"
  , connectUserRequestLastName :: !(Text) -- ^ /Required/ "lastName"
  , connectUserRequestEmail :: !(Text) -- ^ /Required/ "email"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConnectUserRequest
instance A.FromJSON ConnectUserRequest where
  parseJSON = A.withObject "ConnectUserRequest" $ \o ->
    ConnectUserRequest
      <$> (o .:  "username")
      <*> (o .:  "firstName")
      <*> (o .:  "lastName")
      <*> (o .:  "email")

-- | ToJSON ConnectUserRequest
instance A.ToJSON ConnectUserRequest where
  toJSON ConnectUserRequest {..} =
   _omitNulls
      [ "username" .= connectUserRequestUsername
      , "firstName" .= connectUserRequestFirstName
      , "lastName" .= connectUserRequestLastName
      , "email" .= connectUserRequestEmail
      ]


-- | Construct a value of type 'ConnectUserRequest' (by applying it's required fields, if any)
mkConnectUserRequest
  :: Text -- ^ 'connectUserRequestUsername' 
  -> Text -- ^ 'connectUserRequestFirstName' 
  -> Text -- ^ 'connectUserRequestLastName' 
  -> Text -- ^ 'connectUserRequestEmail' 
  -> ConnectUserRequest
mkConnectUserRequest connectUserRequestUsername connectUserRequestFirstName connectUserRequestLastName connectUserRequestEmail =
  ConnectUserRequest
  { connectUserRequestUsername
  , connectUserRequestFirstName
  , connectUserRequestLastName
  , connectUserRequestEmail
  }

-- ** ConvertAmounts200Response
-- | ConvertAmounts200Response
-- 
data ConvertAmounts200Response = ConvertAmounts200Response
  { convertAmounts200ResponseSourceAmount :: !(Double) -- ^ /Required/ "sourceAmount"
  , convertAmounts200ResponseSourceUnit :: !(Text) -- ^ /Required/ "sourceUnit"
  , convertAmounts200ResponseTargetAmount :: !(Double) -- ^ /Required/ "targetAmount"
  , convertAmounts200ResponseTargetUnit :: !(Text) -- ^ /Required/ "targetUnit"
  , convertAmounts200ResponseAnswer :: !(Text) -- ^ /Required/ "answer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConvertAmounts200Response
instance A.FromJSON ConvertAmounts200Response where
  parseJSON = A.withObject "ConvertAmounts200Response" $ \o ->
    ConvertAmounts200Response
      <$> (o .:  "sourceAmount")
      <*> (o .:  "sourceUnit")
      <*> (o .:  "targetAmount")
      <*> (o .:  "targetUnit")
      <*> (o .:  "answer")

-- | ToJSON ConvertAmounts200Response
instance A.ToJSON ConvertAmounts200Response where
  toJSON ConvertAmounts200Response {..} =
   _omitNulls
      [ "sourceAmount" .= convertAmounts200ResponseSourceAmount
      , "sourceUnit" .= convertAmounts200ResponseSourceUnit
      , "targetAmount" .= convertAmounts200ResponseTargetAmount
      , "targetUnit" .= convertAmounts200ResponseTargetUnit
      , "answer" .= convertAmounts200ResponseAnswer
      ]


-- | Construct a value of type 'ConvertAmounts200Response' (by applying it's required fields, if any)
mkConvertAmounts200Response
  :: Double -- ^ 'convertAmounts200ResponseSourceAmount' 
  -> Text -- ^ 'convertAmounts200ResponseSourceUnit' 
  -> Double -- ^ 'convertAmounts200ResponseTargetAmount' 
  -> Text -- ^ 'convertAmounts200ResponseTargetUnit' 
  -> Text -- ^ 'convertAmounts200ResponseAnswer' 
  -> ConvertAmounts200Response
mkConvertAmounts200Response convertAmounts200ResponseSourceAmount convertAmounts200ResponseSourceUnit convertAmounts200ResponseTargetAmount convertAmounts200ResponseTargetUnit convertAmounts200ResponseAnswer =
  ConvertAmounts200Response
  { convertAmounts200ResponseSourceAmount
  , convertAmounts200ResponseSourceUnit
  , convertAmounts200ResponseTargetAmount
  , convertAmounts200ResponseTargetUnit
  , convertAmounts200ResponseAnswer
  }

-- ** CreateRecipeCard200Response
-- | CreateRecipeCard200Response
-- 
data CreateRecipeCard200Response = CreateRecipeCard200Response
  { createRecipeCard200ResponseUrl :: !(Text) -- ^ /Required/ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateRecipeCard200Response
instance A.FromJSON CreateRecipeCard200Response where
  parseJSON = A.withObject "CreateRecipeCard200Response" $ \o ->
    CreateRecipeCard200Response
      <$> (o .:  "url")

-- | ToJSON CreateRecipeCard200Response
instance A.ToJSON CreateRecipeCard200Response where
  toJSON CreateRecipeCard200Response {..} =
   _omitNulls
      [ "url" .= createRecipeCard200ResponseUrl
      ]


-- | Construct a value of type 'CreateRecipeCard200Response' (by applying it's required fields, if any)
mkCreateRecipeCard200Response
  :: Text -- ^ 'createRecipeCard200ResponseUrl' 
  -> CreateRecipeCard200Response
mkCreateRecipeCard200Response createRecipeCard200ResponseUrl =
  CreateRecipeCard200Response
  { createRecipeCard200ResponseUrl
  }

-- ** DeleteFromMealPlanRequest
-- | DeleteFromMealPlanRequest
data DeleteFromMealPlanRequest = DeleteFromMealPlanRequest
  { deleteFromMealPlanRequestUsername :: !(Text) -- ^ /Required/ "username" - The username.
  , deleteFromMealPlanRequestId :: !(Double) -- ^ /Required/ "id" - The shopping list item id.
  , deleteFromMealPlanRequestHash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteFromMealPlanRequest
instance A.FromJSON DeleteFromMealPlanRequest where
  parseJSON = A.withObject "DeleteFromMealPlanRequest" $ \o ->
    DeleteFromMealPlanRequest
      <$> (o .:  "username")
      <*> (o .:  "id")
      <*> (o .:  "hash")

-- | ToJSON DeleteFromMealPlanRequest
instance A.ToJSON DeleteFromMealPlanRequest where
  toJSON DeleteFromMealPlanRequest {..} =
   _omitNulls
      [ "username" .= deleteFromMealPlanRequestUsername
      , "id" .= deleteFromMealPlanRequestId
      , "hash" .= deleteFromMealPlanRequestHash
      ]


-- | Construct a value of type 'DeleteFromMealPlanRequest' (by applying it's required fields, if any)
mkDeleteFromMealPlanRequest
  :: Text -- ^ 'deleteFromMealPlanRequestUsername': The username.
  -> Double -- ^ 'deleteFromMealPlanRequestId': The shopping list item id.
  -> Text -- ^ 'deleteFromMealPlanRequestHash': The private hash for the username.
  -> DeleteFromMealPlanRequest
mkDeleteFromMealPlanRequest deleteFromMealPlanRequestUsername deleteFromMealPlanRequestId deleteFromMealPlanRequestHash =
  DeleteFromMealPlanRequest
  { deleteFromMealPlanRequestUsername
  , deleteFromMealPlanRequestId
  , deleteFromMealPlanRequestHash
  }

-- ** DetectFoodInText200Response
-- | DetectFoodInText200Response
-- 
data DetectFoodInText200Response = DetectFoodInText200Response
  { detectFoodInText200ResponseAnnotations :: !([DetectFoodInText200ResponseAnnotationsInner]) -- ^ /Required/ "annotations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectFoodInText200Response
instance A.FromJSON DetectFoodInText200Response where
  parseJSON = A.withObject "DetectFoodInText200Response" $ \o ->
    DetectFoodInText200Response
      <$> (o .:  "annotations")

-- | ToJSON DetectFoodInText200Response
instance A.ToJSON DetectFoodInText200Response where
  toJSON DetectFoodInText200Response {..} =
   _omitNulls
      [ "annotations" .= detectFoodInText200ResponseAnnotations
      ]


-- | Construct a value of type 'DetectFoodInText200Response' (by applying it's required fields, if any)
mkDetectFoodInText200Response
  :: [DetectFoodInText200ResponseAnnotationsInner] -- ^ 'detectFoodInText200ResponseAnnotations' 
  -> DetectFoodInText200Response
mkDetectFoodInText200Response detectFoodInText200ResponseAnnotations =
  DetectFoodInText200Response
  { detectFoodInText200ResponseAnnotations
  }

-- ** DetectFoodInText200ResponseAnnotationsInner
-- | DetectFoodInText200ResponseAnnotationsInner
data DetectFoodInText200ResponseAnnotationsInner = DetectFoodInText200ResponseAnnotationsInner
  { detectFoodInText200ResponseAnnotationsInnerAnnotation :: !(Text) -- ^ /Required/ "annotation"
  , detectFoodInText200ResponseAnnotationsInnerImage :: !(Text) -- ^ /Required/ "image"
  , detectFoodInText200ResponseAnnotationsInnerTag :: !(Text) -- ^ /Required/ "tag"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DetectFoodInText200ResponseAnnotationsInner
instance A.FromJSON DetectFoodInText200ResponseAnnotationsInner where
  parseJSON = A.withObject "DetectFoodInText200ResponseAnnotationsInner" $ \o ->
    DetectFoodInText200ResponseAnnotationsInner
      <$> (o .:  "annotation")
      <*> (o .:  "image")
      <*> (o .:  "tag")

-- | ToJSON DetectFoodInText200ResponseAnnotationsInner
instance A.ToJSON DetectFoodInText200ResponseAnnotationsInner where
  toJSON DetectFoodInText200ResponseAnnotationsInner {..} =
   _omitNulls
      [ "annotation" .= detectFoodInText200ResponseAnnotationsInnerAnnotation
      , "image" .= detectFoodInText200ResponseAnnotationsInnerImage
      , "tag" .= detectFoodInText200ResponseAnnotationsInnerTag
      ]


-- | Construct a value of type 'DetectFoodInText200ResponseAnnotationsInner' (by applying it's required fields, if any)
mkDetectFoodInText200ResponseAnnotationsInner
  :: Text -- ^ 'detectFoodInText200ResponseAnnotationsInnerAnnotation' 
  -> Text -- ^ 'detectFoodInText200ResponseAnnotationsInnerImage' 
  -> Text -- ^ 'detectFoodInText200ResponseAnnotationsInnerTag' 
  -> DetectFoodInText200ResponseAnnotationsInner
mkDetectFoodInText200ResponseAnnotationsInner detectFoodInText200ResponseAnnotationsInnerAnnotation detectFoodInText200ResponseAnnotationsInnerImage detectFoodInText200ResponseAnnotationsInnerTag =
  DetectFoodInText200ResponseAnnotationsInner
  { detectFoodInText200ResponseAnnotationsInnerAnnotation
  , detectFoodInText200ResponseAnnotationsInnerImage
  , detectFoodInText200ResponseAnnotationsInnerTag
  }

-- ** GenerateMealPlan200Response
-- | GenerateMealPlan200Response
-- 
data GenerateMealPlan200Response = GenerateMealPlan200Response
  { generateMealPlan200ResponseMeals :: !([GetSimilarRecipes200ResponseInner]) -- ^ /Required/ "meals"
  , generateMealPlan200ResponseNutrients :: !(GenerateMealPlan200ResponseNutrients) -- ^ /Required/ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateMealPlan200Response
instance A.FromJSON GenerateMealPlan200Response where
  parseJSON = A.withObject "GenerateMealPlan200Response" $ \o ->
    GenerateMealPlan200Response
      <$> (o .:  "meals")
      <*> (o .:  "nutrients")

-- | ToJSON GenerateMealPlan200Response
instance A.ToJSON GenerateMealPlan200Response where
  toJSON GenerateMealPlan200Response {..} =
   _omitNulls
      [ "meals" .= generateMealPlan200ResponseMeals
      , "nutrients" .= generateMealPlan200ResponseNutrients
      ]


-- | Construct a value of type 'GenerateMealPlan200Response' (by applying it's required fields, if any)
mkGenerateMealPlan200Response
  :: [GetSimilarRecipes200ResponseInner] -- ^ 'generateMealPlan200ResponseMeals' 
  -> GenerateMealPlan200ResponseNutrients -- ^ 'generateMealPlan200ResponseNutrients' 
  -> GenerateMealPlan200Response
mkGenerateMealPlan200Response generateMealPlan200ResponseMeals generateMealPlan200ResponseNutrients =
  GenerateMealPlan200Response
  { generateMealPlan200ResponseMeals
  , generateMealPlan200ResponseNutrients
  }

-- ** GenerateMealPlan200ResponseNutrients
-- | GenerateMealPlan200ResponseNutrients
data GenerateMealPlan200ResponseNutrients = GenerateMealPlan200ResponseNutrients
  { generateMealPlan200ResponseNutrientsCalories :: !(Double) -- ^ /Required/ "calories"
  , generateMealPlan200ResponseNutrientsCarbohydrates :: !(Double) -- ^ /Required/ "carbohydrates"
  , generateMealPlan200ResponseNutrientsFat :: !(Double) -- ^ /Required/ "fat"
  , generateMealPlan200ResponseNutrientsProtein :: !(Double) -- ^ /Required/ "protein"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateMealPlan200ResponseNutrients
instance A.FromJSON GenerateMealPlan200ResponseNutrients where
  parseJSON = A.withObject "GenerateMealPlan200ResponseNutrients" $ \o ->
    GenerateMealPlan200ResponseNutrients
      <$> (o .:  "calories")
      <*> (o .:  "carbohydrates")
      <*> (o .:  "fat")
      <*> (o .:  "protein")

-- | ToJSON GenerateMealPlan200ResponseNutrients
instance A.ToJSON GenerateMealPlan200ResponseNutrients where
  toJSON GenerateMealPlan200ResponseNutrients {..} =
   _omitNulls
      [ "calories" .= generateMealPlan200ResponseNutrientsCalories
      , "carbohydrates" .= generateMealPlan200ResponseNutrientsCarbohydrates
      , "fat" .= generateMealPlan200ResponseNutrientsFat
      , "protein" .= generateMealPlan200ResponseNutrientsProtein
      ]


-- | Construct a value of type 'GenerateMealPlan200ResponseNutrients' (by applying it's required fields, if any)
mkGenerateMealPlan200ResponseNutrients
  :: Double -- ^ 'generateMealPlan200ResponseNutrientsCalories' 
  -> Double -- ^ 'generateMealPlan200ResponseNutrientsCarbohydrates' 
  -> Double -- ^ 'generateMealPlan200ResponseNutrientsFat' 
  -> Double -- ^ 'generateMealPlan200ResponseNutrientsProtein' 
  -> GenerateMealPlan200ResponseNutrients
mkGenerateMealPlan200ResponseNutrients generateMealPlan200ResponseNutrientsCalories generateMealPlan200ResponseNutrientsCarbohydrates generateMealPlan200ResponseNutrientsFat generateMealPlan200ResponseNutrientsProtein =
  GenerateMealPlan200ResponseNutrients
  { generateMealPlan200ResponseNutrientsCalories
  , generateMealPlan200ResponseNutrientsCarbohydrates
  , generateMealPlan200ResponseNutrientsFat
  , generateMealPlan200ResponseNutrientsProtein
  }

-- ** GenerateShoppingList200Response
-- | GenerateShoppingList200Response
-- 
data GenerateShoppingList200Response = GenerateShoppingList200Response
  { generateShoppingList200ResponseAisles :: !([GetShoppingList200ResponseAislesInner]) -- ^ /Required/ "aisles"
  , generateShoppingList200ResponseCost :: !(Double) -- ^ /Required/ "cost"
  , generateShoppingList200ResponseStartDate :: !(Double) -- ^ /Required/ "startDate"
  , generateShoppingList200ResponseEndDate :: !(Double) -- ^ /Required/ "endDate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateShoppingList200Response
instance A.FromJSON GenerateShoppingList200Response where
  parseJSON = A.withObject "GenerateShoppingList200Response" $ \o ->
    GenerateShoppingList200Response
      <$> (o .:  "aisles")
      <*> (o .:  "cost")
      <*> (o .:  "startDate")
      <*> (o .:  "endDate")

-- | ToJSON GenerateShoppingList200Response
instance A.ToJSON GenerateShoppingList200Response where
  toJSON GenerateShoppingList200Response {..} =
   _omitNulls
      [ "aisles" .= generateShoppingList200ResponseAisles
      , "cost" .= generateShoppingList200ResponseCost
      , "startDate" .= generateShoppingList200ResponseStartDate
      , "endDate" .= generateShoppingList200ResponseEndDate
      ]


-- | Construct a value of type 'GenerateShoppingList200Response' (by applying it's required fields, if any)
mkGenerateShoppingList200Response
  :: [GetShoppingList200ResponseAislesInner] -- ^ 'generateShoppingList200ResponseAisles' 
  -> Double -- ^ 'generateShoppingList200ResponseCost' 
  -> Double -- ^ 'generateShoppingList200ResponseStartDate' 
  -> Double -- ^ 'generateShoppingList200ResponseEndDate' 
  -> GenerateShoppingList200Response
mkGenerateShoppingList200Response generateShoppingList200ResponseAisles generateShoppingList200ResponseCost generateShoppingList200ResponseStartDate generateShoppingList200ResponseEndDate =
  GenerateShoppingList200Response
  { generateShoppingList200ResponseAisles
  , generateShoppingList200ResponseCost
  , generateShoppingList200ResponseStartDate
  , generateShoppingList200ResponseEndDate
  }

-- ** GenerateShoppingListRequest
-- | GenerateShoppingListRequest
data GenerateShoppingListRequest = GenerateShoppingListRequest
  { generateShoppingListRequestUsername :: !(Text) -- ^ /Required/ "username" - The username.
  , generateShoppingListRequestStartDate :: !(Text) -- ^ /Required/ "start-date" - The start date in the format yyyy-mm-dd.
  , generateShoppingListRequestEndDate :: !(Text) -- ^ /Required/ "end-date" - The end date in the format yyyy-mm-dd.
  , generateShoppingListRequestHash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateShoppingListRequest
instance A.FromJSON GenerateShoppingListRequest where
  parseJSON = A.withObject "GenerateShoppingListRequest" $ \o ->
    GenerateShoppingListRequest
      <$> (o .:  "username")
      <*> (o .:  "start-date")
      <*> (o .:  "end-date")
      <*> (o .:  "hash")

-- | ToJSON GenerateShoppingListRequest
instance A.ToJSON GenerateShoppingListRequest where
  toJSON GenerateShoppingListRequest {..} =
   _omitNulls
      [ "username" .= generateShoppingListRequestUsername
      , "start-date" .= generateShoppingListRequestStartDate
      , "end-date" .= generateShoppingListRequestEndDate
      , "hash" .= generateShoppingListRequestHash
      ]


-- | Construct a value of type 'GenerateShoppingListRequest' (by applying it's required fields, if any)
mkGenerateShoppingListRequest
  :: Text -- ^ 'generateShoppingListRequestUsername': The username.
  -> Text -- ^ 'generateShoppingListRequestStartDate': The start date in the format yyyy-mm-dd.
  -> Text -- ^ 'generateShoppingListRequestEndDate': The end date in the format yyyy-mm-dd.
  -> Text -- ^ 'generateShoppingListRequestHash': The private hash for the username.
  -> GenerateShoppingListRequest
mkGenerateShoppingListRequest generateShoppingListRequestUsername generateShoppingListRequestStartDate generateShoppingListRequestEndDate generateShoppingListRequestHash =
  GenerateShoppingListRequest
  { generateShoppingListRequestUsername
  , generateShoppingListRequestStartDate
  , generateShoppingListRequestEndDate
  , generateShoppingListRequestHash
  }

-- ** GetARandomFoodJoke200Response
-- | GetARandomFoodJoke200Response
-- 
data GetARandomFoodJoke200Response = GetARandomFoodJoke200Response
  { getARandomFoodJoke200ResponseText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetARandomFoodJoke200Response
instance A.FromJSON GetARandomFoodJoke200Response where
  parseJSON = A.withObject "GetARandomFoodJoke200Response" $ \o ->
    GetARandomFoodJoke200Response
      <$> (o .:  "text")

-- | ToJSON GetARandomFoodJoke200Response
instance A.ToJSON GetARandomFoodJoke200Response where
  toJSON GetARandomFoodJoke200Response {..} =
   _omitNulls
      [ "text" .= getARandomFoodJoke200ResponseText
      ]


-- | Construct a value of type 'GetARandomFoodJoke200Response' (by applying it's required fields, if any)
mkGetARandomFoodJoke200Response
  :: Text -- ^ 'getARandomFoodJoke200ResponseText' 
  -> GetARandomFoodJoke200Response
mkGetARandomFoodJoke200Response getARandomFoodJoke200ResponseText =
  GetARandomFoodJoke200Response
  { getARandomFoodJoke200ResponseText
  }

-- ** GetAnalyzedRecipeInstructions200Response
-- | GetAnalyzedRecipeInstructions200Response
-- 
data GetAnalyzedRecipeInstructions200Response = GetAnalyzedRecipeInstructions200Response
  { getAnalyzedRecipeInstructions200ResponseParsedInstructions :: !([GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner]) -- ^ /Required/ "parsedInstructions"
  , getAnalyzedRecipeInstructions200ResponseIngredients :: !([GetAnalyzedRecipeInstructions200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  , getAnalyzedRecipeInstructions200ResponseEquipment :: !([GetAnalyzedRecipeInstructions200ResponseIngredientsInner]) -- ^ /Required/ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAnalyzedRecipeInstructions200Response
instance A.FromJSON GetAnalyzedRecipeInstructions200Response where
  parseJSON = A.withObject "GetAnalyzedRecipeInstructions200Response" $ \o ->
    GetAnalyzedRecipeInstructions200Response
      <$> (o .:  "parsedInstructions")
      <*> (o .:  "ingredients")
      <*> (o .:  "equipment")

-- | ToJSON GetAnalyzedRecipeInstructions200Response
instance A.ToJSON GetAnalyzedRecipeInstructions200Response where
  toJSON GetAnalyzedRecipeInstructions200Response {..} =
   _omitNulls
      [ "parsedInstructions" .= getAnalyzedRecipeInstructions200ResponseParsedInstructions
      , "ingredients" .= getAnalyzedRecipeInstructions200ResponseIngredients
      , "equipment" .= getAnalyzedRecipeInstructions200ResponseEquipment
      ]


-- | Construct a value of type 'GetAnalyzedRecipeInstructions200Response' (by applying it's required fields, if any)
mkGetAnalyzedRecipeInstructions200Response
  :: [GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner] -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructions' 
  -> [GetAnalyzedRecipeInstructions200ResponseIngredientsInner] -- ^ 'getAnalyzedRecipeInstructions200ResponseIngredients' 
  -> [GetAnalyzedRecipeInstructions200ResponseIngredientsInner] -- ^ 'getAnalyzedRecipeInstructions200ResponseEquipment' 
  -> GetAnalyzedRecipeInstructions200Response
mkGetAnalyzedRecipeInstructions200Response getAnalyzedRecipeInstructions200ResponseParsedInstructions getAnalyzedRecipeInstructions200ResponseIngredients getAnalyzedRecipeInstructions200ResponseEquipment =
  GetAnalyzedRecipeInstructions200Response
  { getAnalyzedRecipeInstructions200ResponseParsedInstructions
  , getAnalyzedRecipeInstructions200ResponseIngredients
  , getAnalyzedRecipeInstructions200ResponseEquipment
  }

-- ** GetAnalyzedRecipeInstructions200ResponseIngredientsInner
-- | GetAnalyzedRecipeInstructions200ResponseIngredientsInner
data GetAnalyzedRecipeInstructions200ResponseIngredientsInner = GetAnalyzedRecipeInstructions200ResponseIngredientsInner
  { getAnalyzedRecipeInstructions200ResponseIngredientsInnerId :: !(Int) -- ^ /Required/ "id"
  , getAnalyzedRecipeInstructions200ResponseIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAnalyzedRecipeInstructions200ResponseIngredientsInner
instance A.FromJSON GetAnalyzedRecipeInstructions200ResponseIngredientsInner where
  parseJSON = A.withObject "GetAnalyzedRecipeInstructions200ResponseIngredientsInner" $ \o ->
    GetAnalyzedRecipeInstructions200ResponseIngredientsInner
      <$> (o .:  "id")
      <*> (o .:  "name")

-- | ToJSON GetAnalyzedRecipeInstructions200ResponseIngredientsInner
instance A.ToJSON GetAnalyzedRecipeInstructions200ResponseIngredientsInner where
  toJSON GetAnalyzedRecipeInstructions200ResponseIngredientsInner {..} =
   _omitNulls
      [ "id" .= getAnalyzedRecipeInstructions200ResponseIngredientsInnerId
      , "name" .= getAnalyzedRecipeInstructions200ResponseIngredientsInnerName
      ]


-- | Construct a value of type 'GetAnalyzedRecipeInstructions200ResponseIngredientsInner' (by applying it's required fields, if any)
mkGetAnalyzedRecipeInstructions200ResponseIngredientsInner
  :: Int -- ^ 'getAnalyzedRecipeInstructions200ResponseIngredientsInnerId' 
  -> Text -- ^ 'getAnalyzedRecipeInstructions200ResponseIngredientsInnerName' 
  -> GetAnalyzedRecipeInstructions200ResponseIngredientsInner
mkGetAnalyzedRecipeInstructions200ResponseIngredientsInner getAnalyzedRecipeInstructions200ResponseIngredientsInnerId getAnalyzedRecipeInstructions200ResponseIngredientsInnerName =
  GetAnalyzedRecipeInstructions200ResponseIngredientsInner
  { getAnalyzedRecipeInstructions200ResponseIngredientsInnerId
  , getAnalyzedRecipeInstructions200ResponseIngredientsInnerName
  }

-- ** GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
-- | GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
data GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner = GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
  { getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerName :: !(Text) -- ^ /Required/ "name"
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerSteps :: !(Maybe [GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner]) -- ^ "steps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
instance A.FromJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner where
  parseJSON = A.withObject "GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner" $ \o ->
    GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
      <$> (o .:  "name")
      <*> (o .:? "steps")

-- | ToJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
instance A.ToJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner where
  toJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner {..} =
   _omitNulls
      [ "name" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerName
      , "steps" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerSteps
      ]


-- | Construct a value of type 'GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner' (by applying it's required fields, if any)
mkGetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
  :: Text -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerName' 
  -> GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
mkGetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerName =
  GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInner
  { getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerName
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerSteps = Nothing
  }

-- ** GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
-- | GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
data GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner = GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
  { getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber :: !(Double) -- ^ /Required/ "number"
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep :: !(Text) -- ^ /Required/ "step"
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredients :: !(Maybe [GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner]) -- ^ "ingredients"
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerEquipment :: !(Maybe [GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner]) -- ^ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
instance A.FromJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner where
  parseJSON = A.withObject "GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner" $ \o ->
    GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
      <$> (o .:  "number")
      <*> (o .:  "step")
      <*> (o .:? "ingredients")
      <*> (o .:? "equipment")

-- | ToJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
instance A.ToJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner where
  toJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner {..} =
   _omitNulls
      [ "number" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber
      , "step" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep
      , "ingredients" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredients
      , "equipment" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerEquipment
      ]


-- | Construct a value of type 'GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner' (by applying it's required fields, if any)
mkGetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
  :: Double -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber' 
  -> Text -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep' 
  -> GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
mkGetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep =
  GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInner
  { getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerNumber
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerStep
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredients = Nothing
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerEquipment = Nothing
  }

-- ** GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
-- | GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
data GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner = GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
  { getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId :: !(Int) -- ^ /Required/ "id"
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName :: !(Text) -- ^ /Required/ "localizedName"
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage :: !(Text) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
instance A.FromJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner where
  parseJSON = A.withObject "GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner" $ \o ->
    GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "localizedName")
      <*> (o .:  "image")

-- | ToJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
instance A.ToJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner where
  toJSON GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner {..} =
   _omitNulls
      [ "id" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId
      , "name" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName
      , "localizedName" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName
      , "image" .= getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage
      ]


-- | Construct a value of type 'GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner' (by applying it's required fields, if any)
mkGetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
  :: Int -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId' 
  -> Text -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName' 
  -> Text -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName' 
  -> Text -- ^ 'getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage' 
  -> GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
mkGetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage =
  GetAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInner
  { getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerId
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerName
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerLocalizedName
  , getAnalyzedRecipeInstructions200ResponseParsedInstructionsInnerStepsInnerIngredientsInnerImage
  }

-- ** GetComparableProducts200Response
-- | GetComparableProducts200Response
-- 
data GetComparableProducts200Response = GetComparableProducts200Response
  { getComparableProducts200ResponseComparableProducts :: !(GetComparableProducts200ResponseComparableProducts) -- ^ /Required/ "comparableProducts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetComparableProducts200Response
instance A.FromJSON GetComparableProducts200Response where
  parseJSON = A.withObject "GetComparableProducts200Response" $ \o ->
    GetComparableProducts200Response
      <$> (o .:  "comparableProducts")

-- | ToJSON GetComparableProducts200Response
instance A.ToJSON GetComparableProducts200Response where
  toJSON GetComparableProducts200Response {..} =
   _omitNulls
      [ "comparableProducts" .= getComparableProducts200ResponseComparableProducts
      ]


-- | Construct a value of type 'GetComparableProducts200Response' (by applying it's required fields, if any)
mkGetComparableProducts200Response
  :: GetComparableProducts200ResponseComparableProducts -- ^ 'getComparableProducts200ResponseComparableProducts' 
  -> GetComparableProducts200Response
mkGetComparableProducts200Response getComparableProducts200ResponseComparableProducts =
  GetComparableProducts200Response
  { getComparableProducts200ResponseComparableProducts
  }

-- ** GetComparableProducts200ResponseComparableProducts
-- | GetComparableProducts200ResponseComparableProducts
data GetComparableProducts200ResponseComparableProducts = GetComparableProducts200ResponseComparableProducts
  { getComparableProducts200ResponseComparableProductsCalories :: !([A.Value]) -- ^ /Required/ "calories"
  , getComparableProducts200ResponseComparableProductsLikes :: !([A.Value]) -- ^ /Required/ "likes"
  , getComparableProducts200ResponseComparableProductsPrice :: !([A.Value]) -- ^ /Required/ "price"
  , getComparableProducts200ResponseComparableProductsProtein :: !([GetComparableProducts200ResponseComparableProductsProteinInner]) -- ^ /Required/ "protein"
  , getComparableProducts200ResponseComparableProductsSpoonacularScore :: !([GetComparableProducts200ResponseComparableProductsProteinInner]) -- ^ /Required/ "spoonacularScore"
  , getComparableProducts200ResponseComparableProductsSugar :: !([A.Value]) -- ^ /Required/ "sugar"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetComparableProducts200ResponseComparableProducts
instance A.FromJSON GetComparableProducts200ResponseComparableProducts where
  parseJSON = A.withObject "GetComparableProducts200ResponseComparableProducts" $ \o ->
    GetComparableProducts200ResponseComparableProducts
      <$> (o .:  "calories")
      <*> (o .:  "likes")
      <*> (o .:  "price")
      <*> (o .:  "protein")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "sugar")

-- | ToJSON GetComparableProducts200ResponseComparableProducts
instance A.ToJSON GetComparableProducts200ResponseComparableProducts where
  toJSON GetComparableProducts200ResponseComparableProducts {..} =
   _omitNulls
      [ "calories" .= getComparableProducts200ResponseComparableProductsCalories
      , "likes" .= getComparableProducts200ResponseComparableProductsLikes
      , "price" .= getComparableProducts200ResponseComparableProductsPrice
      , "protein" .= getComparableProducts200ResponseComparableProductsProtein
      , "spoonacularScore" .= getComparableProducts200ResponseComparableProductsSpoonacularScore
      , "sugar" .= getComparableProducts200ResponseComparableProductsSugar
      ]


-- | Construct a value of type 'GetComparableProducts200ResponseComparableProducts' (by applying it's required fields, if any)
mkGetComparableProducts200ResponseComparableProducts
  :: [A.Value] -- ^ 'getComparableProducts200ResponseComparableProductsCalories' 
  -> [A.Value] -- ^ 'getComparableProducts200ResponseComparableProductsLikes' 
  -> [A.Value] -- ^ 'getComparableProducts200ResponseComparableProductsPrice' 
  -> [GetComparableProducts200ResponseComparableProductsProteinInner] -- ^ 'getComparableProducts200ResponseComparableProductsProtein' 
  -> [GetComparableProducts200ResponseComparableProductsProteinInner] -- ^ 'getComparableProducts200ResponseComparableProductsSpoonacularScore' 
  -> [A.Value] -- ^ 'getComparableProducts200ResponseComparableProductsSugar' 
  -> GetComparableProducts200ResponseComparableProducts
mkGetComparableProducts200ResponseComparableProducts getComparableProducts200ResponseComparableProductsCalories getComparableProducts200ResponseComparableProductsLikes getComparableProducts200ResponseComparableProductsPrice getComparableProducts200ResponseComparableProductsProtein getComparableProducts200ResponseComparableProductsSpoonacularScore getComparableProducts200ResponseComparableProductsSugar =
  GetComparableProducts200ResponseComparableProducts
  { getComparableProducts200ResponseComparableProductsCalories
  , getComparableProducts200ResponseComparableProductsLikes
  , getComparableProducts200ResponseComparableProductsPrice
  , getComparableProducts200ResponseComparableProductsProtein
  , getComparableProducts200ResponseComparableProductsSpoonacularScore
  , getComparableProducts200ResponseComparableProductsSugar
  }

-- ** GetComparableProducts200ResponseComparableProductsProteinInner
-- | GetComparableProducts200ResponseComparableProductsProteinInner
data GetComparableProducts200ResponseComparableProductsProteinInner = GetComparableProducts200ResponseComparableProductsProteinInner
  { getComparableProducts200ResponseComparableProductsProteinInnerDifference :: !(Double) -- ^ /Required/ "difference"
  , getComparableProducts200ResponseComparableProductsProteinInnerId :: !(Int) -- ^ /Required/ "id"
  , getComparableProducts200ResponseComparableProductsProteinInnerImage :: !(Text) -- ^ /Required/ "image"
  , getComparableProducts200ResponseComparableProductsProteinInnerTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetComparableProducts200ResponseComparableProductsProteinInner
instance A.FromJSON GetComparableProducts200ResponseComparableProductsProteinInner where
  parseJSON = A.withObject "GetComparableProducts200ResponseComparableProductsProteinInner" $ \o ->
    GetComparableProducts200ResponseComparableProductsProteinInner
      <$> (o .:  "difference")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:  "title")

-- | ToJSON GetComparableProducts200ResponseComparableProductsProteinInner
instance A.ToJSON GetComparableProducts200ResponseComparableProductsProteinInner where
  toJSON GetComparableProducts200ResponseComparableProductsProteinInner {..} =
   _omitNulls
      [ "difference" .= getComparableProducts200ResponseComparableProductsProteinInnerDifference
      , "id" .= getComparableProducts200ResponseComparableProductsProteinInnerId
      , "image" .= getComparableProducts200ResponseComparableProductsProteinInnerImage
      , "title" .= getComparableProducts200ResponseComparableProductsProteinInnerTitle
      ]


-- | Construct a value of type 'GetComparableProducts200ResponseComparableProductsProteinInner' (by applying it's required fields, if any)
mkGetComparableProducts200ResponseComparableProductsProteinInner
  :: Double -- ^ 'getComparableProducts200ResponseComparableProductsProteinInnerDifference' 
  -> Int -- ^ 'getComparableProducts200ResponseComparableProductsProteinInnerId' 
  -> Text -- ^ 'getComparableProducts200ResponseComparableProductsProteinInnerImage' 
  -> Text -- ^ 'getComparableProducts200ResponseComparableProductsProteinInnerTitle' 
  -> GetComparableProducts200ResponseComparableProductsProteinInner
mkGetComparableProducts200ResponseComparableProductsProteinInner getComparableProducts200ResponseComparableProductsProteinInnerDifference getComparableProducts200ResponseComparableProductsProteinInnerId getComparableProducts200ResponseComparableProductsProteinInnerImage getComparableProducts200ResponseComparableProductsProteinInnerTitle =
  GetComparableProducts200ResponseComparableProductsProteinInner
  { getComparableProducts200ResponseComparableProductsProteinInnerDifference
  , getComparableProducts200ResponseComparableProductsProteinInnerId
  , getComparableProducts200ResponseComparableProductsProteinInnerImage
  , getComparableProducts200ResponseComparableProductsProteinInnerTitle
  }

-- ** GetConversationSuggests200Response
-- | GetConversationSuggests200Response
-- 
data GetConversationSuggests200Response = GetConversationSuggests200Response
  { getConversationSuggests200ResponseSuggests :: !(GetConversationSuggests200ResponseSuggests) -- ^ /Required/ "suggests"
  , getConversationSuggests200ResponseWords :: !([AnyType]) -- ^ /Required/ "words"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetConversationSuggests200Response
instance A.FromJSON GetConversationSuggests200Response where
  parseJSON = A.withObject "GetConversationSuggests200Response" $ \o ->
    GetConversationSuggests200Response
      <$> (o .:  "suggests")
      <*> (o .:  "words")

-- | ToJSON GetConversationSuggests200Response
instance A.ToJSON GetConversationSuggests200Response where
  toJSON GetConversationSuggests200Response {..} =
   _omitNulls
      [ "suggests" .= getConversationSuggests200ResponseSuggests
      , "words" .= getConversationSuggests200ResponseWords
      ]


-- | Construct a value of type 'GetConversationSuggests200Response' (by applying it's required fields, if any)
mkGetConversationSuggests200Response
  :: GetConversationSuggests200ResponseSuggests -- ^ 'getConversationSuggests200ResponseSuggests' 
  -> [AnyType] -- ^ 'getConversationSuggests200ResponseWords' 
  -> GetConversationSuggests200Response
mkGetConversationSuggests200Response getConversationSuggests200ResponseSuggests getConversationSuggests200ResponseWords =
  GetConversationSuggests200Response
  { getConversationSuggests200ResponseSuggests
  , getConversationSuggests200ResponseWords
  }

-- ** GetConversationSuggests200ResponseSuggests
-- | GetConversationSuggests200ResponseSuggests
data GetConversationSuggests200ResponseSuggests = GetConversationSuggests200ResponseSuggests
  { getConversationSuggests200ResponseSuggests :: !([GetConversationSuggests200ResponseSuggestsInner]) -- ^ /Required/ "_"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetConversationSuggests200ResponseSuggests
instance A.FromJSON GetConversationSuggests200ResponseSuggests where
  parseJSON = A.withObject "GetConversationSuggests200ResponseSuggests" $ \o ->
    GetConversationSuggests200ResponseSuggests
      <$> (o .:  "_")

-- | ToJSON GetConversationSuggests200ResponseSuggests
instance A.ToJSON GetConversationSuggests200ResponseSuggests where
  toJSON GetConversationSuggests200ResponseSuggests {..} =
   _omitNulls
      [ "_" .= getConversationSuggests200ResponseSuggests
      ]


-- | Construct a value of type 'GetConversationSuggests200ResponseSuggests' (by applying it's required fields, if any)
mkGetConversationSuggests200ResponseSuggests
  :: [GetConversationSuggests200ResponseSuggestsInner] -- ^ 'getConversationSuggests200ResponseSuggests' 
  -> GetConversationSuggests200ResponseSuggests
mkGetConversationSuggests200ResponseSuggests getConversationSuggests200ResponseSuggests =
  GetConversationSuggests200ResponseSuggests
  { getConversationSuggests200ResponseSuggests
  }

-- ** GetConversationSuggests200ResponseSuggestsInner
-- | GetConversationSuggests200ResponseSuggestsInner
data GetConversationSuggests200ResponseSuggestsInner = GetConversationSuggests200ResponseSuggestsInner
  { getConversationSuggests200ResponseSuggestsInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetConversationSuggests200ResponseSuggestsInner
instance A.FromJSON GetConversationSuggests200ResponseSuggestsInner where
  parseJSON = A.withObject "GetConversationSuggests200ResponseSuggestsInner" $ \o ->
    GetConversationSuggests200ResponseSuggestsInner
      <$> (o .:  "name")

-- | ToJSON GetConversationSuggests200ResponseSuggestsInner
instance A.ToJSON GetConversationSuggests200ResponseSuggestsInner where
  toJSON GetConversationSuggests200ResponseSuggestsInner {..} =
   _omitNulls
      [ "name" .= getConversationSuggests200ResponseSuggestsInnerName
      ]


-- | Construct a value of type 'GetConversationSuggests200ResponseSuggestsInner' (by applying it's required fields, if any)
mkGetConversationSuggests200ResponseSuggestsInner
  :: Text -- ^ 'getConversationSuggests200ResponseSuggestsInnerName' 
  -> GetConversationSuggests200ResponseSuggestsInner
mkGetConversationSuggests200ResponseSuggestsInner getConversationSuggests200ResponseSuggestsInnerName =
  GetConversationSuggests200ResponseSuggestsInner
  { getConversationSuggests200ResponseSuggestsInnerName
  }

-- ** GetDishPairingForWine200Response
-- | GetDishPairingForWine200Response
-- 
data GetDishPairingForWine200Response = GetDishPairingForWine200Response
  { getDishPairingForWine200ResponsePairings :: !([Text]) -- ^ /Required/ "pairings"
  , getDishPairingForWine200ResponseText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetDishPairingForWine200Response
instance A.FromJSON GetDishPairingForWine200Response where
  parseJSON = A.withObject "GetDishPairingForWine200Response" $ \o ->
    GetDishPairingForWine200Response
      <$> (o .:  "pairings")
      <*> (o .:  "text")

-- | ToJSON GetDishPairingForWine200Response
instance A.ToJSON GetDishPairingForWine200Response where
  toJSON GetDishPairingForWine200Response {..} =
   _omitNulls
      [ "pairings" .= getDishPairingForWine200ResponsePairings
      , "text" .= getDishPairingForWine200ResponseText
      ]


-- | Construct a value of type 'GetDishPairingForWine200Response' (by applying it's required fields, if any)
mkGetDishPairingForWine200Response
  :: [Text] -- ^ 'getDishPairingForWine200ResponsePairings' 
  -> Text -- ^ 'getDishPairingForWine200ResponseText' 
  -> GetDishPairingForWine200Response
mkGetDishPairingForWine200Response getDishPairingForWine200ResponsePairings getDishPairingForWine200ResponseText =
  GetDishPairingForWine200Response
  { getDishPairingForWine200ResponsePairings
  , getDishPairingForWine200ResponseText
  }

-- ** GetIngredientInformation200Response
-- | GetIngredientInformation200Response
-- 
data GetIngredientInformation200Response = GetIngredientInformation200Response
  { getIngredientInformation200ResponseId :: !(Int) -- ^ /Required/ "id"
  , getIngredientInformation200ResponseOriginal :: !(Text) -- ^ /Required/ "original"
  , getIngredientInformation200ResponseOriginalName :: !(Text) -- ^ /Required/ "originalName"
  , getIngredientInformation200ResponseName :: !(Text) -- ^ /Required/ "name"
  , getIngredientInformation200ResponseNameClean :: !(Text) -- ^ /Required/ "nameClean"
  , getIngredientInformation200ResponseAmount :: !(Double) -- ^ /Required/ "amount"
  , getIngredientInformation200ResponseUnit :: !(Text) -- ^ /Required/ "unit"
  , getIngredientInformation200ResponseUnitShort :: !(Text) -- ^ /Required/ "unitShort"
  , getIngredientInformation200ResponseUnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , getIngredientInformation200ResponsePossibleUnits :: !([Text]) -- ^ /Required/ "possibleUnits"
  , getIngredientInformation200ResponseEstimatedCost :: !(ParseIngredients200ResponseInnerEstimatedCost) -- ^ /Required/ "estimatedCost"
  , getIngredientInformation200ResponseConsistency :: !(Text) -- ^ /Required/ "consistency"
  , getIngredientInformation200ResponseShoppingListUnits :: !([Text]) -- ^ /Required/ "shoppingListUnits"
  , getIngredientInformation200ResponseAisle :: !(Text) -- ^ /Required/ "aisle"
  , getIngredientInformation200ResponseImage :: !(Text) -- ^ /Required/ "image"
  , getIngredientInformation200ResponseMeta :: !([A.Value]) -- ^ /Required/ "meta"
  , getIngredientInformation200ResponseNutrition :: !(GetIngredientInformation200ResponseNutrition) -- ^ /Required/ "nutrition"
  , getIngredientInformation200ResponseCategoryPath :: !([Text]) -- ^ /Required/ "categoryPath"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetIngredientInformation200Response
instance A.FromJSON GetIngredientInformation200Response where
  parseJSON = A.withObject "GetIngredientInformation200Response" $ \o ->
    GetIngredientInformation200Response
      <$> (o .:  "id")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "name")
      <*> (o .:  "nameClean")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "unitShort")
      <*> (o .:  "unitLong")
      <*> (o .:  "possibleUnits")
      <*> (o .:  "estimatedCost")
      <*> (o .:  "consistency")
      <*> (o .:  "shoppingListUnits")
      <*> (o .:  "aisle")
      <*> (o .:  "image")
      <*> (o .:  "meta")
      <*> (o .:  "nutrition")
      <*> (o .:  "categoryPath")

-- | ToJSON GetIngredientInformation200Response
instance A.ToJSON GetIngredientInformation200Response where
  toJSON GetIngredientInformation200Response {..} =
   _omitNulls
      [ "id" .= getIngredientInformation200ResponseId
      , "original" .= getIngredientInformation200ResponseOriginal
      , "originalName" .= getIngredientInformation200ResponseOriginalName
      , "name" .= getIngredientInformation200ResponseName
      , "nameClean" .= getIngredientInformation200ResponseNameClean
      , "amount" .= getIngredientInformation200ResponseAmount
      , "unit" .= getIngredientInformation200ResponseUnit
      , "unitShort" .= getIngredientInformation200ResponseUnitShort
      , "unitLong" .= getIngredientInformation200ResponseUnitLong
      , "possibleUnits" .= getIngredientInformation200ResponsePossibleUnits
      , "estimatedCost" .= getIngredientInformation200ResponseEstimatedCost
      , "consistency" .= getIngredientInformation200ResponseConsistency
      , "shoppingListUnits" .= getIngredientInformation200ResponseShoppingListUnits
      , "aisle" .= getIngredientInformation200ResponseAisle
      , "image" .= getIngredientInformation200ResponseImage
      , "meta" .= getIngredientInformation200ResponseMeta
      , "nutrition" .= getIngredientInformation200ResponseNutrition
      , "categoryPath" .= getIngredientInformation200ResponseCategoryPath
      ]


-- | Construct a value of type 'GetIngredientInformation200Response' (by applying it's required fields, if any)
mkGetIngredientInformation200Response
  :: Int -- ^ 'getIngredientInformation200ResponseId' 
  -> Text -- ^ 'getIngredientInformation200ResponseOriginal' 
  -> Text -- ^ 'getIngredientInformation200ResponseOriginalName' 
  -> Text -- ^ 'getIngredientInformation200ResponseName' 
  -> Text -- ^ 'getIngredientInformation200ResponseNameClean' 
  -> Double -- ^ 'getIngredientInformation200ResponseAmount' 
  -> Text -- ^ 'getIngredientInformation200ResponseUnit' 
  -> Text -- ^ 'getIngredientInformation200ResponseUnitShort' 
  -> Text -- ^ 'getIngredientInformation200ResponseUnitLong' 
  -> [Text] -- ^ 'getIngredientInformation200ResponsePossibleUnits' 
  -> ParseIngredients200ResponseInnerEstimatedCost -- ^ 'getIngredientInformation200ResponseEstimatedCost' 
  -> Text -- ^ 'getIngredientInformation200ResponseConsistency' 
  -> [Text] -- ^ 'getIngredientInformation200ResponseShoppingListUnits' 
  -> Text -- ^ 'getIngredientInformation200ResponseAisle' 
  -> Text -- ^ 'getIngredientInformation200ResponseImage' 
  -> [A.Value] -- ^ 'getIngredientInformation200ResponseMeta' 
  -> GetIngredientInformation200ResponseNutrition -- ^ 'getIngredientInformation200ResponseNutrition' 
  -> [Text] -- ^ 'getIngredientInformation200ResponseCategoryPath' 
  -> GetIngredientInformation200Response
mkGetIngredientInformation200Response getIngredientInformation200ResponseId getIngredientInformation200ResponseOriginal getIngredientInformation200ResponseOriginalName getIngredientInformation200ResponseName getIngredientInformation200ResponseNameClean getIngredientInformation200ResponseAmount getIngredientInformation200ResponseUnit getIngredientInformation200ResponseUnitShort getIngredientInformation200ResponseUnitLong getIngredientInformation200ResponsePossibleUnits getIngredientInformation200ResponseEstimatedCost getIngredientInformation200ResponseConsistency getIngredientInformation200ResponseShoppingListUnits getIngredientInformation200ResponseAisle getIngredientInformation200ResponseImage getIngredientInformation200ResponseMeta getIngredientInformation200ResponseNutrition getIngredientInformation200ResponseCategoryPath =
  GetIngredientInformation200Response
  { getIngredientInformation200ResponseId
  , getIngredientInformation200ResponseOriginal
  , getIngredientInformation200ResponseOriginalName
  , getIngredientInformation200ResponseName
  , getIngredientInformation200ResponseNameClean
  , getIngredientInformation200ResponseAmount
  , getIngredientInformation200ResponseUnit
  , getIngredientInformation200ResponseUnitShort
  , getIngredientInformation200ResponseUnitLong
  , getIngredientInformation200ResponsePossibleUnits
  , getIngredientInformation200ResponseEstimatedCost
  , getIngredientInformation200ResponseConsistency
  , getIngredientInformation200ResponseShoppingListUnits
  , getIngredientInformation200ResponseAisle
  , getIngredientInformation200ResponseImage
  , getIngredientInformation200ResponseMeta
  , getIngredientInformation200ResponseNutrition
  , getIngredientInformation200ResponseCategoryPath
  }

-- ** GetIngredientInformation200ResponseNutrition
-- | GetIngredientInformation200ResponseNutrition
data GetIngredientInformation200ResponseNutrition = GetIngredientInformation200ResponseNutrition
  { getIngredientInformation200ResponseNutritionNutrients :: !([ParseIngredients200ResponseInnerNutritionNutrientsInner]) -- ^ /Required/ "nutrients"
  , getIngredientInformation200ResponseNutritionProperties :: !([ParseIngredients200ResponseInnerNutritionPropertiesInner]) -- ^ /Required/ "properties"
  , getIngredientInformation200ResponseNutritionCaloricBreakdown :: !(ParseIngredients200ResponseInnerNutritionCaloricBreakdown) -- ^ /Required/ "caloricBreakdown"
  , getIngredientInformation200ResponseNutritionWeightPerServing :: !(ParseIngredients200ResponseInnerNutritionWeightPerServing) -- ^ /Required/ "weightPerServing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetIngredientInformation200ResponseNutrition
instance A.FromJSON GetIngredientInformation200ResponseNutrition where
  parseJSON = A.withObject "GetIngredientInformation200ResponseNutrition" $ \o ->
    GetIngredientInformation200ResponseNutrition
      <$> (o .:  "nutrients")
      <*> (o .:  "properties")
      <*> (o .:  "caloricBreakdown")
      <*> (o .:  "weightPerServing")

-- | ToJSON GetIngredientInformation200ResponseNutrition
instance A.ToJSON GetIngredientInformation200ResponseNutrition where
  toJSON GetIngredientInformation200ResponseNutrition {..} =
   _omitNulls
      [ "nutrients" .= getIngredientInformation200ResponseNutritionNutrients
      , "properties" .= getIngredientInformation200ResponseNutritionProperties
      , "caloricBreakdown" .= getIngredientInformation200ResponseNutritionCaloricBreakdown
      , "weightPerServing" .= getIngredientInformation200ResponseNutritionWeightPerServing
      ]


-- | Construct a value of type 'GetIngredientInformation200ResponseNutrition' (by applying it's required fields, if any)
mkGetIngredientInformation200ResponseNutrition
  :: [ParseIngredients200ResponseInnerNutritionNutrientsInner] -- ^ 'getIngredientInformation200ResponseNutritionNutrients' 
  -> [ParseIngredients200ResponseInnerNutritionPropertiesInner] -- ^ 'getIngredientInformation200ResponseNutritionProperties' 
  -> ParseIngredients200ResponseInnerNutritionCaloricBreakdown -- ^ 'getIngredientInformation200ResponseNutritionCaloricBreakdown' 
  -> ParseIngredients200ResponseInnerNutritionWeightPerServing -- ^ 'getIngredientInformation200ResponseNutritionWeightPerServing' 
  -> GetIngredientInformation200ResponseNutrition
mkGetIngredientInformation200ResponseNutrition getIngredientInformation200ResponseNutritionNutrients getIngredientInformation200ResponseNutritionProperties getIngredientInformation200ResponseNutritionCaloricBreakdown getIngredientInformation200ResponseNutritionWeightPerServing =
  GetIngredientInformation200ResponseNutrition
  { getIngredientInformation200ResponseNutritionNutrients
  , getIngredientInformation200ResponseNutritionProperties
  , getIngredientInformation200ResponseNutritionCaloricBreakdown
  , getIngredientInformation200ResponseNutritionWeightPerServing
  }

-- ** GetIngredientSubstitutes200Response
-- | GetIngredientSubstitutes200Response
-- 
data GetIngredientSubstitutes200Response = GetIngredientSubstitutes200Response
  { getIngredientSubstitutes200ResponseIngredient :: !(Text) -- ^ /Required/ "ingredient"
  , getIngredientSubstitutes200ResponseSubstitutes :: !([Text]) -- ^ /Required/ "substitutes"
  , getIngredientSubstitutes200ResponseMessage :: !(Text) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetIngredientSubstitutes200Response
instance A.FromJSON GetIngredientSubstitutes200Response where
  parseJSON = A.withObject "GetIngredientSubstitutes200Response" $ \o ->
    GetIngredientSubstitutes200Response
      <$> (o .:  "ingredient")
      <*> (o .:  "substitutes")
      <*> (o .:  "message")

-- | ToJSON GetIngredientSubstitutes200Response
instance A.ToJSON GetIngredientSubstitutes200Response where
  toJSON GetIngredientSubstitutes200Response {..} =
   _omitNulls
      [ "ingredient" .= getIngredientSubstitutes200ResponseIngredient
      , "substitutes" .= getIngredientSubstitutes200ResponseSubstitutes
      , "message" .= getIngredientSubstitutes200ResponseMessage
      ]


-- | Construct a value of type 'GetIngredientSubstitutes200Response' (by applying it's required fields, if any)
mkGetIngredientSubstitutes200Response
  :: Text -- ^ 'getIngredientSubstitutes200ResponseIngredient' 
  -> [Text] -- ^ 'getIngredientSubstitutes200ResponseSubstitutes' 
  -> Text -- ^ 'getIngredientSubstitutes200ResponseMessage' 
  -> GetIngredientSubstitutes200Response
mkGetIngredientSubstitutes200Response getIngredientSubstitutes200ResponseIngredient getIngredientSubstitutes200ResponseSubstitutes getIngredientSubstitutes200ResponseMessage =
  GetIngredientSubstitutes200Response
  { getIngredientSubstitutes200ResponseIngredient
  , getIngredientSubstitutes200ResponseSubstitutes
  , getIngredientSubstitutes200ResponseMessage
  }

-- ** GetMealPlanTemplate200Response
-- | GetMealPlanTemplate200Response
-- 
data GetMealPlanTemplate200Response = GetMealPlanTemplate200Response
  { getMealPlanTemplate200ResponseId :: !(Int) -- ^ /Required/ "id"
  , getMealPlanTemplate200ResponseName :: !(Text) -- ^ /Required/ "name"
  , getMealPlanTemplate200ResponseDays :: !([GetMealPlanTemplate200ResponseDaysInner]) -- ^ /Required/ "days"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanTemplate200Response
instance A.FromJSON GetMealPlanTemplate200Response where
  parseJSON = A.withObject "GetMealPlanTemplate200Response" $ \o ->
    GetMealPlanTemplate200Response
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "days")

-- | ToJSON GetMealPlanTemplate200Response
instance A.ToJSON GetMealPlanTemplate200Response where
  toJSON GetMealPlanTemplate200Response {..} =
   _omitNulls
      [ "id" .= getMealPlanTemplate200ResponseId
      , "name" .= getMealPlanTemplate200ResponseName
      , "days" .= getMealPlanTemplate200ResponseDays
      ]


-- | Construct a value of type 'GetMealPlanTemplate200Response' (by applying it's required fields, if any)
mkGetMealPlanTemplate200Response
  :: Int -- ^ 'getMealPlanTemplate200ResponseId' 
  -> Text -- ^ 'getMealPlanTemplate200ResponseName' 
  -> [GetMealPlanTemplate200ResponseDaysInner] -- ^ 'getMealPlanTemplate200ResponseDays' 
  -> GetMealPlanTemplate200Response
mkGetMealPlanTemplate200Response getMealPlanTemplate200ResponseId getMealPlanTemplate200ResponseName getMealPlanTemplate200ResponseDays =
  GetMealPlanTemplate200Response
  { getMealPlanTemplate200ResponseId
  , getMealPlanTemplate200ResponseName
  , getMealPlanTemplate200ResponseDays
  }

-- ** GetMealPlanTemplate200ResponseDaysInner
-- | GetMealPlanTemplate200ResponseDaysInner
data GetMealPlanTemplate200ResponseDaysInner = GetMealPlanTemplate200ResponseDaysInner
  { getMealPlanTemplate200ResponseDaysInnerNutritionSummary :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummary"
  , getMealPlanTemplate200ResponseDaysInnerNutritionSummaryBreakfast :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummaryBreakfast"
  , getMealPlanTemplate200ResponseDaysInnerNutritionSummaryLunch :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummaryLunch"
  , getMealPlanTemplate200ResponseDaysInnerNutritionSummaryDinner :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummaryDinner"
  , getMealPlanTemplate200ResponseDaysInnerDay :: !(Text) -- ^ /Required/ "day"
  , getMealPlanTemplate200ResponseDaysInnerItems :: !(Maybe [GetMealPlanTemplate200ResponseDaysInnerItemsInner]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanTemplate200ResponseDaysInner
instance A.FromJSON GetMealPlanTemplate200ResponseDaysInner where
  parseJSON = A.withObject "GetMealPlanTemplate200ResponseDaysInner" $ \o ->
    GetMealPlanTemplate200ResponseDaysInner
      <$> (o .:? "nutritionSummary")
      <*> (o .:? "nutritionSummaryBreakfast")
      <*> (o .:? "nutritionSummaryLunch")
      <*> (o .:? "nutritionSummaryDinner")
      <*> (o .:  "day")
      <*> (o .:? "items")

-- | ToJSON GetMealPlanTemplate200ResponseDaysInner
instance A.ToJSON GetMealPlanTemplate200ResponseDaysInner where
  toJSON GetMealPlanTemplate200ResponseDaysInner {..} =
   _omitNulls
      [ "nutritionSummary" .= getMealPlanTemplate200ResponseDaysInnerNutritionSummary
      , "nutritionSummaryBreakfast" .= getMealPlanTemplate200ResponseDaysInnerNutritionSummaryBreakfast
      , "nutritionSummaryLunch" .= getMealPlanTemplate200ResponseDaysInnerNutritionSummaryLunch
      , "nutritionSummaryDinner" .= getMealPlanTemplate200ResponseDaysInnerNutritionSummaryDinner
      , "day" .= getMealPlanTemplate200ResponseDaysInnerDay
      , "items" .= getMealPlanTemplate200ResponseDaysInnerItems
      ]


-- | Construct a value of type 'GetMealPlanTemplate200ResponseDaysInner' (by applying it's required fields, if any)
mkGetMealPlanTemplate200ResponseDaysInner
  :: Text -- ^ 'getMealPlanTemplate200ResponseDaysInnerDay' 
  -> GetMealPlanTemplate200ResponseDaysInner
mkGetMealPlanTemplate200ResponseDaysInner getMealPlanTemplate200ResponseDaysInnerDay =
  GetMealPlanTemplate200ResponseDaysInner
  { getMealPlanTemplate200ResponseDaysInnerNutritionSummary = Nothing
  , getMealPlanTemplate200ResponseDaysInnerNutritionSummaryBreakfast = Nothing
  , getMealPlanTemplate200ResponseDaysInnerNutritionSummaryLunch = Nothing
  , getMealPlanTemplate200ResponseDaysInnerNutritionSummaryDinner = Nothing
  , getMealPlanTemplate200ResponseDaysInnerDay
  , getMealPlanTemplate200ResponseDaysInnerItems = Nothing
  }

-- ** GetMealPlanTemplate200ResponseDaysInnerItemsInner
-- | GetMealPlanTemplate200ResponseDaysInnerItemsInner
data GetMealPlanTemplate200ResponseDaysInnerItemsInner = GetMealPlanTemplate200ResponseDaysInnerItemsInner
  { getMealPlanTemplate200ResponseDaysInnerItemsInnerId :: !(Int) -- ^ /Required/ "id"
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerSlot :: !(Int) -- ^ /Required/ "slot"
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerPosition :: !(Int) -- ^ /Required/ "position"
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerType :: !(Text) -- ^ /Required/ "type"
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerValue :: !(Maybe GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanTemplate200ResponseDaysInnerItemsInner
instance A.FromJSON GetMealPlanTemplate200ResponseDaysInnerItemsInner where
  parseJSON = A.withObject "GetMealPlanTemplate200ResponseDaysInnerItemsInner" $ \o ->
    GetMealPlanTemplate200ResponseDaysInnerItemsInner
      <$> (o .:  "id")
      <*> (o .:  "slot")
      <*> (o .:  "position")
      <*> (o .:  "type")
      <*> (o .:? "value")

-- | ToJSON GetMealPlanTemplate200ResponseDaysInnerItemsInner
instance A.ToJSON GetMealPlanTemplate200ResponseDaysInnerItemsInner where
  toJSON GetMealPlanTemplate200ResponseDaysInnerItemsInner {..} =
   _omitNulls
      [ "id" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerId
      , "slot" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerSlot
      , "position" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerPosition
      , "type" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerType
      , "value" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerValue
      ]


-- | Construct a value of type 'GetMealPlanTemplate200ResponseDaysInnerItemsInner' (by applying it's required fields, if any)
mkGetMealPlanTemplate200ResponseDaysInnerItemsInner
  :: Int -- ^ 'getMealPlanTemplate200ResponseDaysInnerItemsInnerId' 
  -> Int -- ^ 'getMealPlanTemplate200ResponseDaysInnerItemsInnerSlot' 
  -> Int -- ^ 'getMealPlanTemplate200ResponseDaysInnerItemsInnerPosition' 
  -> Text -- ^ 'getMealPlanTemplate200ResponseDaysInnerItemsInnerType' 
  -> GetMealPlanTemplate200ResponseDaysInnerItemsInner
mkGetMealPlanTemplate200ResponseDaysInnerItemsInner getMealPlanTemplate200ResponseDaysInnerItemsInnerId getMealPlanTemplate200ResponseDaysInnerItemsInnerSlot getMealPlanTemplate200ResponseDaysInnerItemsInnerPosition getMealPlanTemplate200ResponseDaysInnerItemsInnerType =
  GetMealPlanTemplate200ResponseDaysInnerItemsInner
  { getMealPlanTemplate200ResponseDaysInnerItemsInnerId
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerSlot
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerPosition
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerType
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerValue = Nothing
  }

-- ** GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
-- | GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
data GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue = GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
  { getMealPlanTemplate200ResponseDaysInnerItemsInnerValueId :: !(Double) -- ^ /Required/ "id"
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerValueTitle :: !(Text) -- ^ /Required/ "title"
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerValueImageType :: !(Text) -- ^ /Required/ "imageType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
instance A.FromJSON GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue where
  parseJSON = A.withObject "GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue" $ \o ->
    GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")

-- | ToJSON GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
instance A.ToJSON GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue where
  toJSON GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue {..} =
   _omitNulls
      [ "id" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerValueId
      , "title" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerValueTitle
      , "imageType" .= getMealPlanTemplate200ResponseDaysInnerItemsInnerValueImageType
      ]


-- | Construct a value of type 'GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue' (by applying it's required fields, if any)
mkGetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
  :: Double -- ^ 'getMealPlanTemplate200ResponseDaysInnerItemsInnerValueId' 
  -> Text -- ^ 'getMealPlanTemplate200ResponseDaysInnerItemsInnerValueTitle' 
  -> Text -- ^ 'getMealPlanTemplate200ResponseDaysInnerItemsInnerValueImageType' 
  -> GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
mkGetMealPlanTemplate200ResponseDaysInnerItemsInnerValue getMealPlanTemplate200ResponseDaysInnerItemsInnerValueId getMealPlanTemplate200ResponseDaysInnerItemsInnerValueTitle getMealPlanTemplate200ResponseDaysInnerItemsInnerValueImageType =
  GetMealPlanTemplate200ResponseDaysInnerItemsInnerValue
  { getMealPlanTemplate200ResponseDaysInnerItemsInnerValueId
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerValueTitle
  , getMealPlanTemplate200ResponseDaysInnerItemsInnerValueImageType
  }

-- ** GetMealPlanTemplates200Response
-- | GetMealPlanTemplates200Response
-- 
data GetMealPlanTemplates200Response = GetMealPlanTemplates200Response
  { getMealPlanTemplates200ResponseTemplates :: !([GetAnalyzedRecipeInstructions200ResponseIngredientsInner]) -- ^ /Required/ "templates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanTemplates200Response
instance A.FromJSON GetMealPlanTemplates200Response where
  parseJSON = A.withObject "GetMealPlanTemplates200Response" $ \o ->
    GetMealPlanTemplates200Response
      <$> (o .:  "templates")

-- | ToJSON GetMealPlanTemplates200Response
instance A.ToJSON GetMealPlanTemplates200Response where
  toJSON GetMealPlanTemplates200Response {..} =
   _omitNulls
      [ "templates" .= getMealPlanTemplates200ResponseTemplates
      ]


-- | Construct a value of type 'GetMealPlanTemplates200Response' (by applying it's required fields, if any)
mkGetMealPlanTemplates200Response
  :: [GetAnalyzedRecipeInstructions200ResponseIngredientsInner] -- ^ 'getMealPlanTemplates200ResponseTemplates' 
  -> GetMealPlanTemplates200Response
mkGetMealPlanTemplates200Response getMealPlanTemplates200ResponseTemplates =
  GetMealPlanTemplates200Response
  { getMealPlanTemplates200ResponseTemplates
  }

-- ** GetMealPlanWeek200Response
-- | GetMealPlanWeek200Response
-- 
data GetMealPlanWeek200Response = GetMealPlanWeek200Response
  { getMealPlanWeek200ResponseDays :: !([GetMealPlanWeek200ResponseDaysInner]) -- ^ /Required/ "days"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanWeek200Response
instance A.FromJSON GetMealPlanWeek200Response where
  parseJSON = A.withObject "GetMealPlanWeek200Response" $ \o ->
    GetMealPlanWeek200Response
      <$> (o .:  "days")

-- | ToJSON GetMealPlanWeek200Response
instance A.ToJSON GetMealPlanWeek200Response where
  toJSON GetMealPlanWeek200Response {..} =
   _omitNulls
      [ "days" .= getMealPlanWeek200ResponseDays
      ]


-- | Construct a value of type 'GetMealPlanWeek200Response' (by applying it's required fields, if any)
mkGetMealPlanWeek200Response
  :: [GetMealPlanWeek200ResponseDaysInner] -- ^ 'getMealPlanWeek200ResponseDays' 
  -> GetMealPlanWeek200Response
mkGetMealPlanWeek200Response getMealPlanWeek200ResponseDays =
  GetMealPlanWeek200Response
  { getMealPlanWeek200ResponseDays
  }

-- ** GetMealPlanWeek200ResponseDaysInner
-- | GetMealPlanWeek200ResponseDaysInner
data GetMealPlanWeek200ResponseDaysInner = GetMealPlanWeek200ResponseDaysInner
  { getMealPlanWeek200ResponseDaysInnerNutritionSummary :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummary"
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryBreakfast :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummaryBreakfast"
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryLunch :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummaryLunch"
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryDinner :: !(Maybe GetMealPlanWeek200ResponseDaysInnerNutritionSummary) -- ^ "nutritionSummaryDinner"
  , getMealPlanWeek200ResponseDaysInnerDate :: !(Double) -- ^ /Required/ "date"
  , getMealPlanWeek200ResponseDaysInnerDay :: !(Text) -- ^ /Required/ "day"
  , getMealPlanWeek200ResponseDaysInnerItems :: !(Maybe [GetMealPlanWeek200ResponseDaysInnerItemsInner]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanWeek200ResponseDaysInner
instance A.FromJSON GetMealPlanWeek200ResponseDaysInner where
  parseJSON = A.withObject "GetMealPlanWeek200ResponseDaysInner" $ \o ->
    GetMealPlanWeek200ResponseDaysInner
      <$> (o .:? "nutritionSummary")
      <*> (o .:? "nutritionSummaryBreakfast")
      <*> (o .:? "nutritionSummaryLunch")
      <*> (o .:? "nutritionSummaryDinner")
      <*> (o .:  "date")
      <*> (o .:  "day")
      <*> (o .:? "items")

-- | ToJSON GetMealPlanWeek200ResponseDaysInner
instance A.ToJSON GetMealPlanWeek200ResponseDaysInner where
  toJSON GetMealPlanWeek200ResponseDaysInner {..} =
   _omitNulls
      [ "nutritionSummary" .= getMealPlanWeek200ResponseDaysInnerNutritionSummary
      , "nutritionSummaryBreakfast" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryBreakfast
      , "nutritionSummaryLunch" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryLunch
      , "nutritionSummaryDinner" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryDinner
      , "date" .= getMealPlanWeek200ResponseDaysInnerDate
      , "day" .= getMealPlanWeek200ResponseDaysInnerDay
      , "items" .= getMealPlanWeek200ResponseDaysInnerItems
      ]


-- | Construct a value of type 'GetMealPlanWeek200ResponseDaysInner' (by applying it's required fields, if any)
mkGetMealPlanWeek200ResponseDaysInner
  :: Double -- ^ 'getMealPlanWeek200ResponseDaysInnerDate' 
  -> Text -- ^ 'getMealPlanWeek200ResponseDaysInnerDay' 
  -> GetMealPlanWeek200ResponseDaysInner
mkGetMealPlanWeek200ResponseDaysInner getMealPlanWeek200ResponseDaysInnerDate getMealPlanWeek200ResponseDaysInnerDay =
  GetMealPlanWeek200ResponseDaysInner
  { getMealPlanWeek200ResponseDaysInnerNutritionSummary = Nothing
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryBreakfast = Nothing
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryLunch = Nothing
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryDinner = Nothing
  , getMealPlanWeek200ResponseDaysInnerDate
  , getMealPlanWeek200ResponseDaysInnerDay
  , getMealPlanWeek200ResponseDaysInnerItems = Nothing
  }

-- ** GetMealPlanWeek200ResponseDaysInnerItemsInner
-- | GetMealPlanWeek200ResponseDaysInnerItemsInner
data GetMealPlanWeek200ResponseDaysInnerItemsInner = GetMealPlanWeek200ResponseDaysInnerItemsInner
  { getMealPlanWeek200ResponseDaysInnerItemsInnerId :: !(Int) -- ^ /Required/ "id"
  , getMealPlanWeek200ResponseDaysInnerItemsInnerSlot :: !(Int) -- ^ /Required/ "slot"
  , getMealPlanWeek200ResponseDaysInnerItemsInnerPosition :: !(Int) -- ^ /Required/ "position"
  , getMealPlanWeek200ResponseDaysInnerItemsInnerType :: !(Text) -- ^ /Required/ "type"
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValue :: !(Maybe GetMealPlanWeek200ResponseDaysInnerItemsInnerValue) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanWeek200ResponseDaysInnerItemsInner
instance A.FromJSON GetMealPlanWeek200ResponseDaysInnerItemsInner where
  parseJSON = A.withObject "GetMealPlanWeek200ResponseDaysInnerItemsInner" $ \o ->
    GetMealPlanWeek200ResponseDaysInnerItemsInner
      <$> (o .:  "id")
      <*> (o .:  "slot")
      <*> (o .:  "position")
      <*> (o .:  "type")
      <*> (o .:? "value")

-- | ToJSON GetMealPlanWeek200ResponseDaysInnerItemsInner
instance A.ToJSON GetMealPlanWeek200ResponseDaysInnerItemsInner where
  toJSON GetMealPlanWeek200ResponseDaysInnerItemsInner {..} =
   _omitNulls
      [ "id" .= getMealPlanWeek200ResponseDaysInnerItemsInnerId
      , "slot" .= getMealPlanWeek200ResponseDaysInnerItemsInnerSlot
      , "position" .= getMealPlanWeek200ResponseDaysInnerItemsInnerPosition
      , "type" .= getMealPlanWeek200ResponseDaysInnerItemsInnerType
      , "value" .= getMealPlanWeek200ResponseDaysInnerItemsInnerValue
      ]


-- | Construct a value of type 'GetMealPlanWeek200ResponseDaysInnerItemsInner' (by applying it's required fields, if any)
mkGetMealPlanWeek200ResponseDaysInnerItemsInner
  :: Int -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerId' 
  -> Int -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerSlot' 
  -> Int -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerPosition' 
  -> Text -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerType' 
  -> GetMealPlanWeek200ResponseDaysInnerItemsInner
mkGetMealPlanWeek200ResponseDaysInnerItemsInner getMealPlanWeek200ResponseDaysInnerItemsInnerId getMealPlanWeek200ResponseDaysInnerItemsInnerSlot getMealPlanWeek200ResponseDaysInnerItemsInnerPosition getMealPlanWeek200ResponseDaysInnerItemsInnerType =
  GetMealPlanWeek200ResponseDaysInnerItemsInner
  { getMealPlanWeek200ResponseDaysInnerItemsInnerId
  , getMealPlanWeek200ResponseDaysInnerItemsInnerSlot
  , getMealPlanWeek200ResponseDaysInnerItemsInnerPosition
  , getMealPlanWeek200ResponseDaysInnerItemsInnerType
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValue = Nothing
  }

-- ** GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
-- | GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
data GetMealPlanWeek200ResponseDaysInnerItemsInnerValue = GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
  { getMealPlanWeek200ResponseDaysInnerItemsInnerValueServings :: !(Double) -- ^ /Required/ "servings"
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValueId :: !(Double) -- ^ /Required/ "id"
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValueTitle :: !(Text) -- ^ /Required/ "title"
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValueImageType :: !(Text) -- ^ /Required/ "imageType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
instance A.FromJSON GetMealPlanWeek200ResponseDaysInnerItemsInnerValue where
  parseJSON = A.withObject "GetMealPlanWeek200ResponseDaysInnerItemsInnerValue" $ \o ->
    GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
      <$> (o .:  "servings")
      <*> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")

-- | ToJSON GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
instance A.ToJSON GetMealPlanWeek200ResponseDaysInnerItemsInnerValue where
  toJSON GetMealPlanWeek200ResponseDaysInnerItemsInnerValue {..} =
   _omitNulls
      [ "servings" .= getMealPlanWeek200ResponseDaysInnerItemsInnerValueServings
      , "id" .= getMealPlanWeek200ResponseDaysInnerItemsInnerValueId
      , "title" .= getMealPlanWeek200ResponseDaysInnerItemsInnerValueTitle
      , "imageType" .= getMealPlanWeek200ResponseDaysInnerItemsInnerValueImageType
      ]


-- | Construct a value of type 'GetMealPlanWeek200ResponseDaysInnerItemsInnerValue' (by applying it's required fields, if any)
mkGetMealPlanWeek200ResponseDaysInnerItemsInnerValue
  :: Double -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerValueServings' 
  -> Double -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerValueId' 
  -> Text -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerValueTitle' 
  -> Text -- ^ 'getMealPlanWeek200ResponseDaysInnerItemsInnerValueImageType' 
  -> GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
mkGetMealPlanWeek200ResponseDaysInnerItemsInnerValue getMealPlanWeek200ResponseDaysInnerItemsInnerValueServings getMealPlanWeek200ResponseDaysInnerItemsInnerValueId getMealPlanWeek200ResponseDaysInnerItemsInnerValueTitle getMealPlanWeek200ResponseDaysInnerItemsInnerValueImageType =
  GetMealPlanWeek200ResponseDaysInnerItemsInnerValue
  { getMealPlanWeek200ResponseDaysInnerItemsInnerValueServings
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValueId
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValueTitle
  , getMealPlanWeek200ResponseDaysInnerItemsInnerValueImageType
  }

-- ** GetMealPlanWeek200ResponseDaysInnerNutritionSummary
-- | GetMealPlanWeek200ResponseDaysInnerNutritionSummary
data GetMealPlanWeek200ResponseDaysInnerNutritionSummary = GetMealPlanWeek200ResponseDaysInnerNutritionSummary
  { getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrients :: !([GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner]) -- ^ /Required/ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummary
instance A.FromJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummary where
  parseJSON = A.withObject "GetMealPlanWeek200ResponseDaysInnerNutritionSummary" $ \o ->
    GetMealPlanWeek200ResponseDaysInnerNutritionSummary
      <$> (o .:  "nutrients")

-- | ToJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummary
instance A.ToJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummary where
  toJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummary {..} =
   _omitNulls
      [ "nutrients" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrients
      ]


-- | Construct a value of type 'GetMealPlanWeek200ResponseDaysInnerNutritionSummary' (by applying it's required fields, if any)
mkGetMealPlanWeek200ResponseDaysInnerNutritionSummary
  :: [GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner] -- ^ 'getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrients' 
  -> GetMealPlanWeek200ResponseDaysInnerNutritionSummary
mkGetMealPlanWeek200ResponseDaysInnerNutritionSummary getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrients =
  GetMealPlanWeek200ResponseDaysInnerNutritionSummary
  { getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrients
  }

-- ** GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
-- | GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
data GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner = GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
  { getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerName :: !(Text) -- ^ /Required/ "name"
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerAmount :: !(Double) -- ^ /Required/ "amount"
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerUnit :: !(Text) -- ^ /Required/ "unit"
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerPercentDailyNeeds :: !(Double) -- ^ /Required/ "percentDailyNeeds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
instance A.FromJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner where
  parseJSON = A.withObject "GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner" $ \o ->
    GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
      <$> (o .:  "name")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "percentDailyNeeds")

-- | ToJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
instance A.ToJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner where
  toJSON GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner {..} =
   _omitNulls
      [ "name" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerName
      , "amount" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerAmount
      , "unit" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerUnit
      , "percentDailyNeeds" .= getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerPercentDailyNeeds
      ]


-- | Construct a value of type 'GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner' (by applying it's required fields, if any)
mkGetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
  :: Text -- ^ 'getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerName' 
  -> Double -- ^ 'getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerAmount' 
  -> Text -- ^ 'getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerUnit' 
  -> Double -- ^ 'getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerPercentDailyNeeds' 
  -> GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
mkGetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerName getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerAmount getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerUnit getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerPercentDailyNeeds =
  GetMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInner
  { getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerName
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerAmount
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerUnit
  , getMealPlanWeek200ResponseDaysInnerNutritionSummaryNutrientsInnerPercentDailyNeeds
  }

-- ** GetMenuItemInformation200Response
-- | GetMenuItemInformation200Response
-- 
data GetMenuItemInformation200Response = GetMenuItemInformation200Response
  { getMenuItemInformation200ResponseId :: !(Int) -- ^ /Required/ "id"
  , getMenuItemInformation200ResponseTitle :: !(Text) -- ^ /Required/ "title"
  , getMenuItemInformation200ResponseRestaurantChain :: !(Text) -- ^ /Required/ "restaurantChain"
  , getMenuItemInformation200ResponseNutrition :: !(SearchGroceryProductsByUPC200ResponseNutrition) -- ^ /Required/ "nutrition"
  , getMenuItemInformation200ResponseBadges :: !([Text]) -- ^ /Required/ "badges"
  , getMenuItemInformation200ResponseBreadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , getMenuItemInformation200ResponseGeneratedText :: !(Maybe Text) -- ^ "generatedText"
  , getMenuItemInformation200ResponseImageType :: !(Text) -- ^ /Required/ "imageType"
  , getMenuItemInformation200ResponseLikes :: !(Double) -- ^ /Required/ "likes"
  , getMenuItemInformation200ResponseServings :: !(SearchGroceryProductsByUPC200ResponseServings) -- ^ /Required/ "servings"
  , getMenuItemInformation200ResponsePrice :: !(Maybe Double) -- ^ "price"
  , getMenuItemInformation200ResponseSpoonacularScore :: !(Maybe Double) -- ^ "spoonacularScore"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMenuItemInformation200Response
instance A.FromJSON GetMenuItemInformation200Response where
  parseJSON = A.withObject "GetMenuItemInformation200Response" $ \o ->
    GetMenuItemInformation200Response
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "restaurantChain")
      <*> (o .:  "nutrition")
      <*> (o .:  "badges")
      <*> (o .:  "breadcrumbs")
      <*> (o .:? "generatedText")
      <*> (o .:  "imageType")
      <*> (o .:  "likes")
      <*> (o .:  "servings")
      <*> (o .:? "price")
      <*> (o .:? "spoonacularScore")

-- | ToJSON GetMenuItemInformation200Response
instance A.ToJSON GetMenuItemInformation200Response where
  toJSON GetMenuItemInformation200Response {..} =
   _omitNulls
      [ "id" .= getMenuItemInformation200ResponseId
      , "title" .= getMenuItemInformation200ResponseTitle
      , "restaurantChain" .= getMenuItemInformation200ResponseRestaurantChain
      , "nutrition" .= getMenuItemInformation200ResponseNutrition
      , "badges" .= getMenuItemInformation200ResponseBadges
      , "breadcrumbs" .= getMenuItemInformation200ResponseBreadcrumbs
      , "generatedText" .= getMenuItemInformation200ResponseGeneratedText
      , "imageType" .= getMenuItemInformation200ResponseImageType
      , "likes" .= getMenuItemInformation200ResponseLikes
      , "servings" .= getMenuItemInformation200ResponseServings
      , "price" .= getMenuItemInformation200ResponsePrice
      , "spoonacularScore" .= getMenuItemInformation200ResponseSpoonacularScore
      ]


-- | Construct a value of type 'GetMenuItemInformation200Response' (by applying it's required fields, if any)
mkGetMenuItemInformation200Response
  :: Int -- ^ 'getMenuItemInformation200ResponseId' 
  -> Text -- ^ 'getMenuItemInformation200ResponseTitle' 
  -> Text -- ^ 'getMenuItemInformation200ResponseRestaurantChain' 
  -> SearchGroceryProductsByUPC200ResponseNutrition -- ^ 'getMenuItemInformation200ResponseNutrition' 
  -> [Text] -- ^ 'getMenuItemInformation200ResponseBadges' 
  -> [Text] -- ^ 'getMenuItemInformation200ResponseBreadcrumbs' 
  -> Text -- ^ 'getMenuItemInformation200ResponseImageType' 
  -> Double -- ^ 'getMenuItemInformation200ResponseLikes' 
  -> SearchGroceryProductsByUPC200ResponseServings -- ^ 'getMenuItemInformation200ResponseServings' 
  -> GetMenuItemInformation200Response
mkGetMenuItemInformation200Response getMenuItemInformation200ResponseId getMenuItemInformation200ResponseTitle getMenuItemInformation200ResponseRestaurantChain getMenuItemInformation200ResponseNutrition getMenuItemInformation200ResponseBadges getMenuItemInformation200ResponseBreadcrumbs getMenuItemInformation200ResponseImageType getMenuItemInformation200ResponseLikes getMenuItemInformation200ResponseServings =
  GetMenuItemInformation200Response
  { getMenuItemInformation200ResponseId
  , getMenuItemInformation200ResponseTitle
  , getMenuItemInformation200ResponseRestaurantChain
  , getMenuItemInformation200ResponseNutrition
  , getMenuItemInformation200ResponseBadges
  , getMenuItemInformation200ResponseBreadcrumbs
  , getMenuItemInformation200ResponseGeneratedText = Nothing
  , getMenuItemInformation200ResponseImageType
  , getMenuItemInformation200ResponseLikes
  , getMenuItemInformation200ResponseServings
  , getMenuItemInformation200ResponsePrice = Nothing
  , getMenuItemInformation200ResponseSpoonacularScore = Nothing
  }

-- ** GetProductInformation200Response
-- | GetProductInformation200Response
-- 
data GetProductInformation200Response = GetProductInformation200Response
  { getProductInformation200ResponseId :: !(Int) -- ^ /Required/ "id"
  , getProductInformation200ResponseTitle :: !(Text) -- ^ /Required/ "title"
  , getProductInformation200ResponseBreadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , getProductInformation200ResponseImageType :: !(Text) -- ^ /Required/ "imageType"
  , getProductInformation200ResponseBadges :: !([Text]) -- ^ /Required/ "badges"
  , getProductInformation200ResponseImportantBadges :: !([Text]) -- ^ /Required/ "importantBadges"
  , getProductInformation200ResponseIngredientCount :: !(Int) -- ^ /Required/ "ingredientCount"
  , getProductInformation200ResponseGeneratedText :: !(Maybe AnyType) -- ^ "generatedText"
  , getProductInformation200ResponseIngredientList :: !(Text) -- ^ /Required/ "ingredientList"
  , getProductInformation200ResponseIngredients :: !([GetProductInformation200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  , getProductInformation200ResponseLikes :: !(Double) -- ^ /Required/ "likes"
  , getProductInformation200ResponseAisle :: !(Text) -- ^ /Required/ "aisle"
  , getProductInformation200ResponseNutrition :: !(SearchGroceryProductsByUPC200ResponseNutrition) -- ^ /Required/ "nutrition"
  , getProductInformation200ResponsePrice :: !(Double) -- ^ /Required/ "price"
  , getProductInformation200ResponseServings :: !(SearchGroceryProductsByUPC200ResponseServings) -- ^ /Required/ "servings"
  , getProductInformation200ResponseSpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetProductInformation200Response
instance A.FromJSON GetProductInformation200Response where
  parseJSON = A.withObject "GetProductInformation200Response" $ \o ->
    GetProductInformation200Response
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "breadcrumbs")
      <*> (o .:  "imageType")
      <*> (o .:  "badges")
      <*> (o .:  "importantBadges")
      <*> (o .:  "ingredientCount")
      <*> (o .:? "generatedText")
      <*> (o .:  "ingredientList")
      <*> (o .:  "ingredients")
      <*> (o .:  "likes")
      <*> (o .:  "aisle")
      <*> (o .:  "nutrition")
      <*> (o .:  "price")
      <*> (o .:  "servings")
      <*> (o .:  "spoonacularScore")

-- | ToJSON GetProductInformation200Response
instance A.ToJSON GetProductInformation200Response where
  toJSON GetProductInformation200Response {..} =
   _omitNulls
      [ "id" .= getProductInformation200ResponseId
      , "title" .= getProductInformation200ResponseTitle
      , "breadcrumbs" .= getProductInformation200ResponseBreadcrumbs
      , "imageType" .= getProductInformation200ResponseImageType
      , "badges" .= getProductInformation200ResponseBadges
      , "importantBadges" .= getProductInformation200ResponseImportantBadges
      , "ingredientCount" .= getProductInformation200ResponseIngredientCount
      , "generatedText" .= getProductInformation200ResponseGeneratedText
      , "ingredientList" .= getProductInformation200ResponseIngredientList
      , "ingredients" .= getProductInformation200ResponseIngredients
      , "likes" .= getProductInformation200ResponseLikes
      , "aisle" .= getProductInformation200ResponseAisle
      , "nutrition" .= getProductInformation200ResponseNutrition
      , "price" .= getProductInformation200ResponsePrice
      , "servings" .= getProductInformation200ResponseServings
      , "spoonacularScore" .= getProductInformation200ResponseSpoonacularScore
      ]


-- | Construct a value of type 'GetProductInformation200Response' (by applying it's required fields, if any)
mkGetProductInformation200Response
  :: Int -- ^ 'getProductInformation200ResponseId' 
  -> Text -- ^ 'getProductInformation200ResponseTitle' 
  -> [Text] -- ^ 'getProductInformation200ResponseBreadcrumbs' 
  -> Text -- ^ 'getProductInformation200ResponseImageType' 
  -> [Text] -- ^ 'getProductInformation200ResponseBadges' 
  -> [Text] -- ^ 'getProductInformation200ResponseImportantBadges' 
  -> Int -- ^ 'getProductInformation200ResponseIngredientCount' 
  -> Text -- ^ 'getProductInformation200ResponseIngredientList' 
  -> [GetProductInformation200ResponseIngredientsInner] -- ^ 'getProductInformation200ResponseIngredients' 
  -> Double -- ^ 'getProductInformation200ResponseLikes' 
  -> Text -- ^ 'getProductInformation200ResponseAisle' 
  -> SearchGroceryProductsByUPC200ResponseNutrition -- ^ 'getProductInformation200ResponseNutrition' 
  -> Double -- ^ 'getProductInformation200ResponsePrice' 
  -> SearchGroceryProductsByUPC200ResponseServings -- ^ 'getProductInformation200ResponseServings' 
  -> Double -- ^ 'getProductInformation200ResponseSpoonacularScore' 
  -> GetProductInformation200Response
mkGetProductInformation200Response getProductInformation200ResponseId getProductInformation200ResponseTitle getProductInformation200ResponseBreadcrumbs getProductInformation200ResponseImageType getProductInformation200ResponseBadges getProductInformation200ResponseImportantBadges getProductInformation200ResponseIngredientCount getProductInformation200ResponseIngredientList getProductInformation200ResponseIngredients getProductInformation200ResponseLikes getProductInformation200ResponseAisle getProductInformation200ResponseNutrition getProductInformation200ResponsePrice getProductInformation200ResponseServings getProductInformation200ResponseSpoonacularScore =
  GetProductInformation200Response
  { getProductInformation200ResponseId
  , getProductInformation200ResponseTitle
  , getProductInformation200ResponseBreadcrumbs
  , getProductInformation200ResponseImageType
  , getProductInformation200ResponseBadges
  , getProductInformation200ResponseImportantBadges
  , getProductInformation200ResponseIngredientCount
  , getProductInformation200ResponseGeneratedText = Nothing
  , getProductInformation200ResponseIngredientList
  , getProductInformation200ResponseIngredients
  , getProductInformation200ResponseLikes
  , getProductInformation200ResponseAisle
  , getProductInformation200ResponseNutrition
  , getProductInformation200ResponsePrice
  , getProductInformation200ResponseServings
  , getProductInformation200ResponseSpoonacularScore
  }

-- ** GetProductInformation200ResponseIngredientsInner
-- | GetProductInformation200ResponseIngredientsInner
data GetProductInformation200ResponseIngredientsInner = GetProductInformation200ResponseIngredientsInner
  { getProductInformation200ResponseIngredientsInnerDescription :: !(Maybe AnyType) -- ^ "description"
  , getProductInformation200ResponseIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  , getProductInformation200ResponseIngredientsInnerSafetyLevel :: !(Maybe AnyType) -- ^ "safety_level"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetProductInformation200ResponseIngredientsInner
instance A.FromJSON GetProductInformation200ResponseIngredientsInner where
  parseJSON = A.withObject "GetProductInformation200ResponseIngredientsInner" $ \o ->
    GetProductInformation200ResponseIngredientsInner
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "safety_level")

-- | ToJSON GetProductInformation200ResponseIngredientsInner
instance A.ToJSON GetProductInformation200ResponseIngredientsInner where
  toJSON GetProductInformation200ResponseIngredientsInner {..} =
   _omitNulls
      [ "description" .= getProductInformation200ResponseIngredientsInnerDescription
      , "name" .= getProductInformation200ResponseIngredientsInnerName
      , "safety_level" .= getProductInformation200ResponseIngredientsInnerSafetyLevel
      ]


-- | Construct a value of type 'GetProductInformation200ResponseIngredientsInner' (by applying it's required fields, if any)
mkGetProductInformation200ResponseIngredientsInner
  :: Text -- ^ 'getProductInformation200ResponseIngredientsInnerName' 
  -> GetProductInformation200ResponseIngredientsInner
mkGetProductInformation200ResponseIngredientsInner getProductInformation200ResponseIngredientsInnerName =
  GetProductInformation200ResponseIngredientsInner
  { getProductInformation200ResponseIngredientsInnerDescription = Nothing
  , getProductInformation200ResponseIngredientsInnerName
  , getProductInformation200ResponseIngredientsInnerSafetyLevel = Nothing
  }

-- ** GetRandomFoodTrivia200Response
-- | GetRandomFoodTrivia200Response
-- 
data GetRandomFoodTrivia200Response = GetRandomFoodTrivia200Response
  { getRandomFoodTrivia200ResponseText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRandomFoodTrivia200Response
instance A.FromJSON GetRandomFoodTrivia200Response where
  parseJSON = A.withObject "GetRandomFoodTrivia200Response" $ \o ->
    GetRandomFoodTrivia200Response
      <$> (o .:  "text")

-- | ToJSON GetRandomFoodTrivia200Response
instance A.ToJSON GetRandomFoodTrivia200Response where
  toJSON GetRandomFoodTrivia200Response {..} =
   _omitNulls
      [ "text" .= getRandomFoodTrivia200ResponseText
      ]


-- | Construct a value of type 'GetRandomFoodTrivia200Response' (by applying it's required fields, if any)
mkGetRandomFoodTrivia200Response
  :: Text -- ^ 'getRandomFoodTrivia200ResponseText' 
  -> GetRandomFoodTrivia200Response
mkGetRandomFoodTrivia200Response getRandomFoodTrivia200ResponseText =
  GetRandomFoodTrivia200Response
  { getRandomFoodTrivia200ResponseText
  }

-- ** GetRandomRecipes200Response
-- | GetRandomRecipes200Response
-- 
data GetRandomRecipes200Response = GetRandomRecipes200Response
  { getRandomRecipes200ResponseRecipes :: !([GetRandomRecipes200ResponseRecipesInner]) -- ^ /Required/ "recipes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRandomRecipes200Response
instance A.FromJSON GetRandomRecipes200Response where
  parseJSON = A.withObject "GetRandomRecipes200Response" $ \o ->
    GetRandomRecipes200Response
      <$> (o .:  "recipes")

-- | ToJSON GetRandomRecipes200Response
instance A.ToJSON GetRandomRecipes200Response where
  toJSON GetRandomRecipes200Response {..} =
   _omitNulls
      [ "recipes" .= getRandomRecipes200ResponseRecipes
      ]


-- | Construct a value of type 'GetRandomRecipes200Response' (by applying it's required fields, if any)
mkGetRandomRecipes200Response
  :: [GetRandomRecipes200ResponseRecipesInner] -- ^ 'getRandomRecipes200ResponseRecipes' 
  -> GetRandomRecipes200Response
mkGetRandomRecipes200Response getRandomRecipes200ResponseRecipes =
  GetRandomRecipes200Response
  { getRandomRecipes200ResponseRecipes
  }

-- ** GetRandomRecipes200ResponseRecipesInner
-- | GetRandomRecipes200ResponseRecipesInner
data GetRandomRecipes200ResponseRecipesInner = GetRandomRecipes200ResponseRecipesInner
  { getRandomRecipes200ResponseRecipesInnerId :: !(Int) -- ^ /Required/ "id"
  , getRandomRecipes200ResponseRecipesInnerTitle :: !(Text) -- ^ /Required/ "title"
  , getRandomRecipes200ResponseRecipesInnerImage :: !(Text) -- ^ /Required/ "image"
  , getRandomRecipes200ResponseRecipesInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , getRandomRecipes200ResponseRecipesInnerServings :: !(Double) -- ^ /Required/ "servings"
  , getRandomRecipes200ResponseRecipesInnerReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , getRandomRecipes200ResponseRecipesInnerLicense :: !(Text) -- ^ /Required/ "license"
  , getRandomRecipes200ResponseRecipesInnerSourceName :: !(Text) -- ^ /Required/ "sourceName"
  , getRandomRecipes200ResponseRecipesInnerSourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  , getRandomRecipes200ResponseRecipesInnerSpoonacularSourceUrl :: !(Text) -- ^ /Required/ "spoonacularSourceUrl"
  , getRandomRecipes200ResponseRecipesInnerAggregateLikes :: !(Double) -- ^ /Required/ "aggregateLikes"
  , getRandomRecipes200ResponseRecipesInnerHealthScore :: !(Double) -- ^ /Required/ "healthScore"
  , getRandomRecipes200ResponseRecipesInnerSpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  , getRandomRecipes200ResponseRecipesInnerPricePerServing :: !(Double) -- ^ /Required/ "pricePerServing"
  , getRandomRecipes200ResponseRecipesInnerAnalyzedInstructions :: !(Maybe [A.Value]) -- ^ "analyzedInstructions"
  , getRandomRecipes200ResponseRecipesInnerCheap :: !(Bool) -- ^ /Required/ "cheap"
  , getRandomRecipes200ResponseRecipesInnerCreditsText :: !(Text) -- ^ /Required/ "creditsText"
  , getRandomRecipes200ResponseRecipesInnerCuisines :: !(Maybe [Text]) -- ^ "cuisines"
  , getRandomRecipes200ResponseRecipesInnerDairyFree :: !(Bool) -- ^ /Required/ "dairyFree"
  , getRandomRecipes200ResponseRecipesInnerDiets :: !(Maybe [Text]) -- ^ "diets"
  , getRandomRecipes200ResponseRecipesInnerGaps :: !(Text) -- ^ /Required/ "gaps"
  , getRandomRecipes200ResponseRecipesInnerGlutenFree :: !(Bool) -- ^ /Required/ "glutenFree"
  , getRandomRecipes200ResponseRecipesInnerInstructions :: !(Text) -- ^ /Required/ "instructions"
  , getRandomRecipes200ResponseRecipesInnerKetogenic :: !(Bool) -- ^ /Required/ "ketogenic"
  , getRandomRecipes200ResponseRecipesInnerLowFodmap :: !(Bool) -- ^ /Required/ "lowFodmap"
  , getRandomRecipes200ResponseRecipesInnerOccasions :: !(Maybe [Text]) -- ^ "occasions"
  , getRandomRecipes200ResponseRecipesInnerSustainable :: !(Bool) -- ^ /Required/ "sustainable"
  , getRandomRecipes200ResponseRecipesInnerVegan :: !(Bool) -- ^ /Required/ "vegan"
  , getRandomRecipes200ResponseRecipesInnerVegetarian :: !(Bool) -- ^ /Required/ "vegetarian"
  , getRandomRecipes200ResponseRecipesInnerVeryHealthy :: !(Bool) -- ^ /Required/ "veryHealthy"
  , getRandomRecipes200ResponseRecipesInnerVeryPopular :: !(Bool) -- ^ /Required/ "veryPopular"
  , getRandomRecipes200ResponseRecipesInnerWhole30 :: !(Bool) -- ^ /Required/ "whole30"
  , getRandomRecipes200ResponseRecipesInnerWeightWatcherSmartPoints :: !(Double) -- ^ /Required/ "weightWatcherSmartPoints"
  , getRandomRecipes200ResponseRecipesInnerDishTypes :: !(Maybe [Text]) -- ^ "dishTypes"
  , getRandomRecipes200ResponseRecipesInnerExtendedIngredients :: !(Maybe [GetRecipeInformation200ResponseExtendedIngredientsInner]) -- ^ "extendedIngredients"
  , getRandomRecipes200ResponseRecipesInnerSummary :: !(Text) -- ^ /Required/ "summary"
  , getRandomRecipes200ResponseRecipesInnerWinePairing :: !(Maybe GetRecipeInformation200ResponseWinePairing) -- ^ "winePairing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRandomRecipes200ResponseRecipesInner
instance A.FromJSON GetRandomRecipes200ResponseRecipesInner where
  parseJSON = A.withObject "GetRandomRecipes200ResponseRecipesInner" $ \o ->
    GetRandomRecipes200ResponseRecipesInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "servings")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "license")
      <*> (o .:  "sourceName")
      <*> (o .:  "sourceUrl")
      <*> (o .:  "spoonacularSourceUrl")
      <*> (o .:  "aggregateLikes")
      <*> (o .:  "healthScore")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "pricePerServing")
      <*> (o .:? "analyzedInstructions")
      <*> (o .:  "cheap")
      <*> (o .:  "creditsText")
      <*> (o .:? "cuisines")
      <*> (o .:  "dairyFree")
      <*> (o .:? "diets")
      <*> (o .:  "gaps")
      <*> (o .:  "glutenFree")
      <*> (o .:  "instructions")
      <*> (o .:  "ketogenic")
      <*> (o .:  "lowFodmap")
      <*> (o .:? "occasions")
      <*> (o .:  "sustainable")
      <*> (o .:  "vegan")
      <*> (o .:  "vegetarian")
      <*> (o .:  "veryHealthy")
      <*> (o .:  "veryPopular")
      <*> (o .:  "whole30")
      <*> (o .:  "weightWatcherSmartPoints")
      <*> (o .:? "dishTypes")
      <*> (o .:? "extendedIngredients")
      <*> (o .:  "summary")
      <*> (o .:? "winePairing")

-- | ToJSON GetRandomRecipes200ResponseRecipesInner
instance A.ToJSON GetRandomRecipes200ResponseRecipesInner where
  toJSON GetRandomRecipes200ResponseRecipesInner {..} =
   _omitNulls
      [ "id" .= getRandomRecipes200ResponseRecipesInnerId
      , "title" .= getRandomRecipes200ResponseRecipesInnerTitle
      , "image" .= getRandomRecipes200ResponseRecipesInnerImage
      , "imageType" .= getRandomRecipes200ResponseRecipesInnerImageType
      , "servings" .= getRandomRecipes200ResponseRecipesInnerServings
      , "readyInMinutes" .= getRandomRecipes200ResponseRecipesInnerReadyInMinutes
      , "license" .= getRandomRecipes200ResponseRecipesInnerLicense
      , "sourceName" .= getRandomRecipes200ResponseRecipesInnerSourceName
      , "sourceUrl" .= getRandomRecipes200ResponseRecipesInnerSourceUrl
      , "spoonacularSourceUrl" .= getRandomRecipes200ResponseRecipesInnerSpoonacularSourceUrl
      , "aggregateLikes" .= getRandomRecipes200ResponseRecipesInnerAggregateLikes
      , "healthScore" .= getRandomRecipes200ResponseRecipesInnerHealthScore
      , "spoonacularScore" .= getRandomRecipes200ResponseRecipesInnerSpoonacularScore
      , "pricePerServing" .= getRandomRecipes200ResponseRecipesInnerPricePerServing
      , "analyzedInstructions" .= getRandomRecipes200ResponseRecipesInnerAnalyzedInstructions
      , "cheap" .= getRandomRecipes200ResponseRecipesInnerCheap
      , "creditsText" .= getRandomRecipes200ResponseRecipesInnerCreditsText
      , "cuisines" .= getRandomRecipes200ResponseRecipesInnerCuisines
      , "dairyFree" .= getRandomRecipes200ResponseRecipesInnerDairyFree
      , "diets" .= getRandomRecipes200ResponseRecipesInnerDiets
      , "gaps" .= getRandomRecipes200ResponseRecipesInnerGaps
      , "glutenFree" .= getRandomRecipes200ResponseRecipesInnerGlutenFree
      , "instructions" .= getRandomRecipes200ResponseRecipesInnerInstructions
      , "ketogenic" .= getRandomRecipes200ResponseRecipesInnerKetogenic
      , "lowFodmap" .= getRandomRecipes200ResponseRecipesInnerLowFodmap
      , "occasions" .= getRandomRecipes200ResponseRecipesInnerOccasions
      , "sustainable" .= getRandomRecipes200ResponseRecipesInnerSustainable
      , "vegan" .= getRandomRecipes200ResponseRecipesInnerVegan
      , "vegetarian" .= getRandomRecipes200ResponseRecipesInnerVegetarian
      , "veryHealthy" .= getRandomRecipes200ResponseRecipesInnerVeryHealthy
      , "veryPopular" .= getRandomRecipes200ResponseRecipesInnerVeryPopular
      , "whole30" .= getRandomRecipes200ResponseRecipesInnerWhole30
      , "weightWatcherSmartPoints" .= getRandomRecipes200ResponseRecipesInnerWeightWatcherSmartPoints
      , "dishTypes" .= getRandomRecipes200ResponseRecipesInnerDishTypes
      , "extendedIngredients" .= getRandomRecipes200ResponseRecipesInnerExtendedIngredients
      , "summary" .= getRandomRecipes200ResponseRecipesInnerSummary
      , "winePairing" .= getRandomRecipes200ResponseRecipesInnerWinePairing
      ]


-- | Construct a value of type 'GetRandomRecipes200ResponseRecipesInner' (by applying it's required fields, if any)
mkGetRandomRecipes200ResponseRecipesInner
  :: Int -- ^ 'getRandomRecipes200ResponseRecipesInnerId' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerTitle' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerImage' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerImageType' 
  -> Double -- ^ 'getRandomRecipes200ResponseRecipesInnerServings' 
  -> Int -- ^ 'getRandomRecipes200ResponseRecipesInnerReadyInMinutes' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerLicense' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerSourceName' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerSourceUrl' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerSpoonacularSourceUrl' 
  -> Double -- ^ 'getRandomRecipes200ResponseRecipesInnerAggregateLikes' 
  -> Double -- ^ 'getRandomRecipes200ResponseRecipesInnerHealthScore' 
  -> Double -- ^ 'getRandomRecipes200ResponseRecipesInnerSpoonacularScore' 
  -> Double -- ^ 'getRandomRecipes200ResponseRecipesInnerPricePerServing' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerCheap' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerCreditsText' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerDairyFree' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerGaps' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerGlutenFree' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerInstructions' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerKetogenic' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerLowFodmap' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerSustainable' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerVegan' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerVegetarian' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerVeryHealthy' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerVeryPopular' 
  -> Bool -- ^ 'getRandomRecipes200ResponseRecipesInnerWhole30' 
  -> Double -- ^ 'getRandomRecipes200ResponseRecipesInnerWeightWatcherSmartPoints' 
  -> Text -- ^ 'getRandomRecipes200ResponseRecipesInnerSummary' 
  -> GetRandomRecipes200ResponseRecipesInner
mkGetRandomRecipes200ResponseRecipesInner getRandomRecipes200ResponseRecipesInnerId getRandomRecipes200ResponseRecipesInnerTitle getRandomRecipes200ResponseRecipesInnerImage getRandomRecipes200ResponseRecipesInnerImageType getRandomRecipes200ResponseRecipesInnerServings getRandomRecipes200ResponseRecipesInnerReadyInMinutes getRandomRecipes200ResponseRecipesInnerLicense getRandomRecipes200ResponseRecipesInnerSourceName getRandomRecipes200ResponseRecipesInnerSourceUrl getRandomRecipes200ResponseRecipesInnerSpoonacularSourceUrl getRandomRecipes200ResponseRecipesInnerAggregateLikes getRandomRecipes200ResponseRecipesInnerHealthScore getRandomRecipes200ResponseRecipesInnerSpoonacularScore getRandomRecipes200ResponseRecipesInnerPricePerServing getRandomRecipes200ResponseRecipesInnerCheap getRandomRecipes200ResponseRecipesInnerCreditsText getRandomRecipes200ResponseRecipesInnerDairyFree getRandomRecipes200ResponseRecipesInnerGaps getRandomRecipes200ResponseRecipesInnerGlutenFree getRandomRecipes200ResponseRecipesInnerInstructions getRandomRecipes200ResponseRecipesInnerKetogenic getRandomRecipes200ResponseRecipesInnerLowFodmap getRandomRecipes200ResponseRecipesInnerSustainable getRandomRecipes200ResponseRecipesInnerVegan getRandomRecipes200ResponseRecipesInnerVegetarian getRandomRecipes200ResponseRecipesInnerVeryHealthy getRandomRecipes200ResponseRecipesInnerVeryPopular getRandomRecipes200ResponseRecipesInnerWhole30 getRandomRecipes200ResponseRecipesInnerWeightWatcherSmartPoints getRandomRecipes200ResponseRecipesInnerSummary =
  GetRandomRecipes200ResponseRecipesInner
  { getRandomRecipes200ResponseRecipesInnerId
  , getRandomRecipes200ResponseRecipesInnerTitle
  , getRandomRecipes200ResponseRecipesInnerImage
  , getRandomRecipes200ResponseRecipesInnerImageType
  , getRandomRecipes200ResponseRecipesInnerServings
  , getRandomRecipes200ResponseRecipesInnerReadyInMinutes
  , getRandomRecipes200ResponseRecipesInnerLicense
  , getRandomRecipes200ResponseRecipesInnerSourceName
  , getRandomRecipes200ResponseRecipesInnerSourceUrl
  , getRandomRecipes200ResponseRecipesInnerSpoonacularSourceUrl
  , getRandomRecipes200ResponseRecipesInnerAggregateLikes
  , getRandomRecipes200ResponseRecipesInnerHealthScore
  , getRandomRecipes200ResponseRecipesInnerSpoonacularScore
  , getRandomRecipes200ResponseRecipesInnerPricePerServing
  , getRandomRecipes200ResponseRecipesInnerAnalyzedInstructions = Nothing
  , getRandomRecipes200ResponseRecipesInnerCheap
  , getRandomRecipes200ResponseRecipesInnerCreditsText
  , getRandomRecipes200ResponseRecipesInnerCuisines = Nothing
  , getRandomRecipes200ResponseRecipesInnerDairyFree
  , getRandomRecipes200ResponseRecipesInnerDiets = Nothing
  , getRandomRecipes200ResponseRecipesInnerGaps
  , getRandomRecipes200ResponseRecipesInnerGlutenFree
  , getRandomRecipes200ResponseRecipesInnerInstructions
  , getRandomRecipes200ResponseRecipesInnerKetogenic
  , getRandomRecipes200ResponseRecipesInnerLowFodmap
  , getRandomRecipes200ResponseRecipesInnerOccasions = Nothing
  , getRandomRecipes200ResponseRecipesInnerSustainable
  , getRandomRecipes200ResponseRecipesInnerVegan
  , getRandomRecipes200ResponseRecipesInnerVegetarian
  , getRandomRecipes200ResponseRecipesInnerVeryHealthy
  , getRandomRecipes200ResponseRecipesInnerVeryPopular
  , getRandomRecipes200ResponseRecipesInnerWhole30
  , getRandomRecipes200ResponseRecipesInnerWeightWatcherSmartPoints
  , getRandomRecipes200ResponseRecipesInnerDishTypes = Nothing
  , getRandomRecipes200ResponseRecipesInnerExtendedIngredients = Nothing
  , getRandomRecipes200ResponseRecipesInnerSummary
  , getRandomRecipes200ResponseRecipesInnerWinePairing = Nothing
  }

-- ** GetRecipeEquipmentByID200Response
-- | GetRecipeEquipmentByID200Response
-- 
data GetRecipeEquipmentByID200Response = GetRecipeEquipmentByID200Response
  { getRecipeEquipmentByID200ResponseEquipment :: !([GetRecipeEquipmentByID200ResponseEquipmentInner]) -- ^ /Required/ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeEquipmentByID200Response
instance A.FromJSON GetRecipeEquipmentByID200Response where
  parseJSON = A.withObject "GetRecipeEquipmentByID200Response" $ \o ->
    GetRecipeEquipmentByID200Response
      <$> (o .:  "equipment")

-- | ToJSON GetRecipeEquipmentByID200Response
instance A.ToJSON GetRecipeEquipmentByID200Response where
  toJSON GetRecipeEquipmentByID200Response {..} =
   _omitNulls
      [ "equipment" .= getRecipeEquipmentByID200ResponseEquipment
      ]


-- | Construct a value of type 'GetRecipeEquipmentByID200Response' (by applying it's required fields, if any)
mkGetRecipeEquipmentByID200Response
  :: [GetRecipeEquipmentByID200ResponseEquipmentInner] -- ^ 'getRecipeEquipmentByID200ResponseEquipment' 
  -> GetRecipeEquipmentByID200Response
mkGetRecipeEquipmentByID200Response getRecipeEquipmentByID200ResponseEquipment =
  GetRecipeEquipmentByID200Response
  { getRecipeEquipmentByID200ResponseEquipment
  }

-- ** GetRecipeEquipmentByID200ResponseEquipmentInner
-- | GetRecipeEquipmentByID200ResponseEquipmentInner
data GetRecipeEquipmentByID200ResponseEquipmentInner = GetRecipeEquipmentByID200ResponseEquipmentInner
  { getRecipeEquipmentByID200ResponseEquipmentInnerImage :: !(Text) -- ^ /Required/ "image"
  , getRecipeEquipmentByID200ResponseEquipmentInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeEquipmentByID200ResponseEquipmentInner
instance A.FromJSON GetRecipeEquipmentByID200ResponseEquipmentInner where
  parseJSON = A.withObject "GetRecipeEquipmentByID200ResponseEquipmentInner" $ \o ->
    GetRecipeEquipmentByID200ResponseEquipmentInner
      <$> (o .:  "image")
      <*> (o .:  "name")

-- | ToJSON GetRecipeEquipmentByID200ResponseEquipmentInner
instance A.ToJSON GetRecipeEquipmentByID200ResponseEquipmentInner where
  toJSON GetRecipeEquipmentByID200ResponseEquipmentInner {..} =
   _omitNulls
      [ "image" .= getRecipeEquipmentByID200ResponseEquipmentInnerImage
      , "name" .= getRecipeEquipmentByID200ResponseEquipmentInnerName
      ]


-- | Construct a value of type 'GetRecipeEquipmentByID200ResponseEquipmentInner' (by applying it's required fields, if any)
mkGetRecipeEquipmentByID200ResponseEquipmentInner
  :: Text -- ^ 'getRecipeEquipmentByID200ResponseEquipmentInnerImage' 
  -> Text -- ^ 'getRecipeEquipmentByID200ResponseEquipmentInnerName' 
  -> GetRecipeEquipmentByID200ResponseEquipmentInner
mkGetRecipeEquipmentByID200ResponseEquipmentInner getRecipeEquipmentByID200ResponseEquipmentInnerImage getRecipeEquipmentByID200ResponseEquipmentInnerName =
  GetRecipeEquipmentByID200ResponseEquipmentInner
  { getRecipeEquipmentByID200ResponseEquipmentInnerImage
  , getRecipeEquipmentByID200ResponseEquipmentInnerName
  }

-- ** GetRecipeInformation200Response
-- | GetRecipeInformation200Response
-- 
data GetRecipeInformation200Response = GetRecipeInformation200Response
  { getRecipeInformation200ResponseId :: !(Int) -- ^ /Required/ "id"
  , getRecipeInformation200ResponseTitle :: !(Text) -- ^ /Required/ "title"
  , getRecipeInformation200ResponseImage :: !(Text) -- ^ /Required/ "image"
  , getRecipeInformation200ResponseImageType :: !(Text) -- ^ /Required/ "imageType"
  , getRecipeInformation200ResponseServings :: !(Double) -- ^ /Required/ "servings"
  , getRecipeInformation200ResponseReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , getRecipeInformation200ResponseLicense :: !(Text) -- ^ /Required/ "license"
  , getRecipeInformation200ResponseSourceName :: !(Text) -- ^ /Required/ "sourceName"
  , getRecipeInformation200ResponseSourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  , getRecipeInformation200ResponseSpoonacularSourceUrl :: !(Text) -- ^ /Required/ "spoonacularSourceUrl"
  , getRecipeInformation200ResponseAggregateLikes :: !(Int) -- ^ /Required/ "aggregateLikes"
  , getRecipeInformation200ResponseHealthScore :: !(Double) -- ^ /Required/ "healthScore"
  , getRecipeInformation200ResponseSpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  , getRecipeInformation200ResponsePricePerServing :: !(Double) -- ^ /Required/ "pricePerServing"
  , getRecipeInformation200ResponseAnalyzedInstructions :: !([A.Value]) -- ^ /Required/ "analyzedInstructions"
  , getRecipeInformation200ResponseCheap :: !(Bool) -- ^ /Required/ "cheap"
  , getRecipeInformation200ResponseCreditsText :: !(Text) -- ^ /Required/ "creditsText"
  , getRecipeInformation200ResponseCuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , getRecipeInformation200ResponseDairyFree :: !(Bool) -- ^ /Required/ "dairyFree"
  , getRecipeInformation200ResponseDiets :: !([Text]) -- ^ /Required/ "diets"
  , getRecipeInformation200ResponseGaps :: !(Text) -- ^ /Required/ "gaps"
  , getRecipeInformation200ResponseGlutenFree :: !(Bool) -- ^ /Required/ "glutenFree"
  , getRecipeInformation200ResponseInstructions :: !(Text) -- ^ /Required/ "instructions"
  , getRecipeInformation200ResponseKetogenic :: !(Bool) -- ^ /Required/ "ketogenic"
  , getRecipeInformation200ResponseLowFodmap :: !(Bool) -- ^ /Required/ "lowFodmap"
  , getRecipeInformation200ResponseOccasions :: !([Text]) -- ^ /Required/ "occasions"
  , getRecipeInformation200ResponseSustainable :: !(Bool) -- ^ /Required/ "sustainable"
  , getRecipeInformation200ResponseVegan :: !(Bool) -- ^ /Required/ "vegan"
  , getRecipeInformation200ResponseVegetarian :: !(Bool) -- ^ /Required/ "vegetarian"
  , getRecipeInformation200ResponseVeryHealthy :: !(Bool) -- ^ /Required/ "veryHealthy"
  , getRecipeInformation200ResponseVeryPopular :: !(Bool) -- ^ /Required/ "veryPopular"
  , getRecipeInformation200ResponseWhole30 :: !(Bool) -- ^ /Required/ "whole30"
  , getRecipeInformation200ResponseWeightWatcherSmartPoints :: !(Double) -- ^ /Required/ "weightWatcherSmartPoints"
  , getRecipeInformation200ResponseDishTypes :: !([Text]) -- ^ /Required/ "dishTypes"
  , getRecipeInformation200ResponseExtendedIngredients :: !([GetRecipeInformation200ResponseExtendedIngredientsInner]) -- ^ /Required/ "extendedIngredients"
  , getRecipeInformation200ResponseSummary :: !(Text) -- ^ /Required/ "summary"
  , getRecipeInformation200ResponseWinePairing :: !(GetRecipeInformation200ResponseWinePairing) -- ^ /Required/ "winePairing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeInformation200Response
instance A.FromJSON GetRecipeInformation200Response where
  parseJSON = A.withObject "GetRecipeInformation200Response" $ \o ->
    GetRecipeInformation200Response
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "servings")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "license")
      <*> (o .:  "sourceName")
      <*> (o .:  "sourceUrl")
      <*> (o .:  "spoonacularSourceUrl")
      <*> (o .:  "aggregateLikes")
      <*> (o .:  "healthScore")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "pricePerServing")
      <*> (o .:  "analyzedInstructions")
      <*> (o .:  "cheap")
      <*> (o .:  "creditsText")
      <*> (o .:  "cuisines")
      <*> (o .:  "dairyFree")
      <*> (o .:  "diets")
      <*> (o .:  "gaps")
      <*> (o .:  "glutenFree")
      <*> (o .:  "instructions")
      <*> (o .:  "ketogenic")
      <*> (o .:  "lowFodmap")
      <*> (o .:  "occasions")
      <*> (o .:  "sustainable")
      <*> (o .:  "vegan")
      <*> (o .:  "vegetarian")
      <*> (o .:  "veryHealthy")
      <*> (o .:  "veryPopular")
      <*> (o .:  "whole30")
      <*> (o .:  "weightWatcherSmartPoints")
      <*> (o .:  "dishTypes")
      <*> (o .:  "extendedIngredients")
      <*> (o .:  "summary")
      <*> (o .:  "winePairing")

-- | ToJSON GetRecipeInformation200Response
instance A.ToJSON GetRecipeInformation200Response where
  toJSON GetRecipeInformation200Response {..} =
   _omitNulls
      [ "id" .= getRecipeInformation200ResponseId
      , "title" .= getRecipeInformation200ResponseTitle
      , "image" .= getRecipeInformation200ResponseImage
      , "imageType" .= getRecipeInformation200ResponseImageType
      , "servings" .= getRecipeInformation200ResponseServings
      , "readyInMinutes" .= getRecipeInformation200ResponseReadyInMinutes
      , "license" .= getRecipeInformation200ResponseLicense
      , "sourceName" .= getRecipeInformation200ResponseSourceName
      , "sourceUrl" .= getRecipeInformation200ResponseSourceUrl
      , "spoonacularSourceUrl" .= getRecipeInformation200ResponseSpoonacularSourceUrl
      , "aggregateLikes" .= getRecipeInformation200ResponseAggregateLikes
      , "healthScore" .= getRecipeInformation200ResponseHealthScore
      , "spoonacularScore" .= getRecipeInformation200ResponseSpoonacularScore
      , "pricePerServing" .= getRecipeInformation200ResponsePricePerServing
      , "analyzedInstructions" .= getRecipeInformation200ResponseAnalyzedInstructions
      , "cheap" .= getRecipeInformation200ResponseCheap
      , "creditsText" .= getRecipeInformation200ResponseCreditsText
      , "cuisines" .= getRecipeInformation200ResponseCuisines
      , "dairyFree" .= getRecipeInformation200ResponseDairyFree
      , "diets" .= getRecipeInformation200ResponseDiets
      , "gaps" .= getRecipeInformation200ResponseGaps
      , "glutenFree" .= getRecipeInformation200ResponseGlutenFree
      , "instructions" .= getRecipeInformation200ResponseInstructions
      , "ketogenic" .= getRecipeInformation200ResponseKetogenic
      , "lowFodmap" .= getRecipeInformation200ResponseLowFodmap
      , "occasions" .= getRecipeInformation200ResponseOccasions
      , "sustainable" .= getRecipeInformation200ResponseSustainable
      , "vegan" .= getRecipeInformation200ResponseVegan
      , "vegetarian" .= getRecipeInformation200ResponseVegetarian
      , "veryHealthy" .= getRecipeInformation200ResponseVeryHealthy
      , "veryPopular" .= getRecipeInformation200ResponseVeryPopular
      , "whole30" .= getRecipeInformation200ResponseWhole30
      , "weightWatcherSmartPoints" .= getRecipeInformation200ResponseWeightWatcherSmartPoints
      , "dishTypes" .= getRecipeInformation200ResponseDishTypes
      , "extendedIngredients" .= getRecipeInformation200ResponseExtendedIngredients
      , "summary" .= getRecipeInformation200ResponseSummary
      , "winePairing" .= getRecipeInformation200ResponseWinePairing
      ]


-- | Construct a value of type 'GetRecipeInformation200Response' (by applying it's required fields, if any)
mkGetRecipeInformation200Response
  :: Int -- ^ 'getRecipeInformation200ResponseId' 
  -> Text -- ^ 'getRecipeInformation200ResponseTitle' 
  -> Text -- ^ 'getRecipeInformation200ResponseImage' 
  -> Text -- ^ 'getRecipeInformation200ResponseImageType' 
  -> Double -- ^ 'getRecipeInformation200ResponseServings' 
  -> Int -- ^ 'getRecipeInformation200ResponseReadyInMinutes' 
  -> Text -- ^ 'getRecipeInformation200ResponseLicense' 
  -> Text -- ^ 'getRecipeInformation200ResponseSourceName' 
  -> Text -- ^ 'getRecipeInformation200ResponseSourceUrl' 
  -> Text -- ^ 'getRecipeInformation200ResponseSpoonacularSourceUrl' 
  -> Int -- ^ 'getRecipeInformation200ResponseAggregateLikes' 
  -> Double -- ^ 'getRecipeInformation200ResponseHealthScore' 
  -> Double -- ^ 'getRecipeInformation200ResponseSpoonacularScore' 
  -> Double -- ^ 'getRecipeInformation200ResponsePricePerServing' 
  -> [A.Value] -- ^ 'getRecipeInformation200ResponseAnalyzedInstructions' 
  -> Bool -- ^ 'getRecipeInformation200ResponseCheap' 
  -> Text -- ^ 'getRecipeInformation200ResponseCreditsText' 
  -> [Text] -- ^ 'getRecipeInformation200ResponseCuisines' 
  -> Bool -- ^ 'getRecipeInformation200ResponseDairyFree' 
  -> [Text] -- ^ 'getRecipeInformation200ResponseDiets' 
  -> Text -- ^ 'getRecipeInformation200ResponseGaps' 
  -> Bool -- ^ 'getRecipeInformation200ResponseGlutenFree' 
  -> Text -- ^ 'getRecipeInformation200ResponseInstructions' 
  -> Bool -- ^ 'getRecipeInformation200ResponseKetogenic' 
  -> Bool -- ^ 'getRecipeInformation200ResponseLowFodmap' 
  -> [Text] -- ^ 'getRecipeInformation200ResponseOccasions' 
  -> Bool -- ^ 'getRecipeInformation200ResponseSustainable' 
  -> Bool -- ^ 'getRecipeInformation200ResponseVegan' 
  -> Bool -- ^ 'getRecipeInformation200ResponseVegetarian' 
  -> Bool -- ^ 'getRecipeInformation200ResponseVeryHealthy' 
  -> Bool -- ^ 'getRecipeInformation200ResponseVeryPopular' 
  -> Bool -- ^ 'getRecipeInformation200ResponseWhole30' 
  -> Double -- ^ 'getRecipeInformation200ResponseWeightWatcherSmartPoints' 
  -> [Text] -- ^ 'getRecipeInformation200ResponseDishTypes' 
  -> [GetRecipeInformation200ResponseExtendedIngredientsInner] -- ^ 'getRecipeInformation200ResponseExtendedIngredients' 
  -> Text -- ^ 'getRecipeInformation200ResponseSummary' 
  -> GetRecipeInformation200ResponseWinePairing -- ^ 'getRecipeInformation200ResponseWinePairing' 
  -> GetRecipeInformation200Response
mkGetRecipeInformation200Response getRecipeInformation200ResponseId getRecipeInformation200ResponseTitle getRecipeInformation200ResponseImage getRecipeInformation200ResponseImageType getRecipeInformation200ResponseServings getRecipeInformation200ResponseReadyInMinutes getRecipeInformation200ResponseLicense getRecipeInformation200ResponseSourceName getRecipeInformation200ResponseSourceUrl getRecipeInformation200ResponseSpoonacularSourceUrl getRecipeInformation200ResponseAggregateLikes getRecipeInformation200ResponseHealthScore getRecipeInformation200ResponseSpoonacularScore getRecipeInformation200ResponsePricePerServing getRecipeInformation200ResponseAnalyzedInstructions getRecipeInformation200ResponseCheap getRecipeInformation200ResponseCreditsText getRecipeInformation200ResponseCuisines getRecipeInformation200ResponseDairyFree getRecipeInformation200ResponseDiets getRecipeInformation200ResponseGaps getRecipeInformation200ResponseGlutenFree getRecipeInformation200ResponseInstructions getRecipeInformation200ResponseKetogenic getRecipeInformation200ResponseLowFodmap getRecipeInformation200ResponseOccasions getRecipeInformation200ResponseSustainable getRecipeInformation200ResponseVegan getRecipeInformation200ResponseVegetarian getRecipeInformation200ResponseVeryHealthy getRecipeInformation200ResponseVeryPopular getRecipeInformation200ResponseWhole30 getRecipeInformation200ResponseWeightWatcherSmartPoints getRecipeInformation200ResponseDishTypes getRecipeInformation200ResponseExtendedIngredients getRecipeInformation200ResponseSummary getRecipeInformation200ResponseWinePairing =
  GetRecipeInformation200Response
  { getRecipeInformation200ResponseId
  , getRecipeInformation200ResponseTitle
  , getRecipeInformation200ResponseImage
  , getRecipeInformation200ResponseImageType
  , getRecipeInformation200ResponseServings
  , getRecipeInformation200ResponseReadyInMinutes
  , getRecipeInformation200ResponseLicense
  , getRecipeInformation200ResponseSourceName
  , getRecipeInformation200ResponseSourceUrl
  , getRecipeInformation200ResponseSpoonacularSourceUrl
  , getRecipeInformation200ResponseAggregateLikes
  , getRecipeInformation200ResponseHealthScore
  , getRecipeInformation200ResponseSpoonacularScore
  , getRecipeInformation200ResponsePricePerServing
  , getRecipeInformation200ResponseAnalyzedInstructions
  , getRecipeInformation200ResponseCheap
  , getRecipeInformation200ResponseCreditsText
  , getRecipeInformation200ResponseCuisines
  , getRecipeInformation200ResponseDairyFree
  , getRecipeInformation200ResponseDiets
  , getRecipeInformation200ResponseGaps
  , getRecipeInformation200ResponseGlutenFree
  , getRecipeInformation200ResponseInstructions
  , getRecipeInformation200ResponseKetogenic
  , getRecipeInformation200ResponseLowFodmap
  , getRecipeInformation200ResponseOccasions
  , getRecipeInformation200ResponseSustainable
  , getRecipeInformation200ResponseVegan
  , getRecipeInformation200ResponseVegetarian
  , getRecipeInformation200ResponseVeryHealthy
  , getRecipeInformation200ResponseVeryPopular
  , getRecipeInformation200ResponseWhole30
  , getRecipeInformation200ResponseWeightWatcherSmartPoints
  , getRecipeInformation200ResponseDishTypes
  , getRecipeInformation200ResponseExtendedIngredients
  , getRecipeInformation200ResponseSummary
  , getRecipeInformation200ResponseWinePairing
  }

-- ** GetRecipeInformation200ResponseExtendedIngredientsInner
-- | GetRecipeInformation200ResponseExtendedIngredientsInner
data GetRecipeInformation200ResponseExtendedIngredientsInner = GetRecipeInformation200ResponseExtendedIngredientsInner
  { getRecipeInformation200ResponseExtendedIngredientsInnerAisle :: !(Text) -- ^ /Required/ "aisle"
  , getRecipeInformation200ResponseExtendedIngredientsInnerAmount :: !(Double) -- ^ /Required/ "amount"
  , getRecipeInformation200ResponseExtendedIngredientsInnerConsitency :: !(Text) -- ^ /Required/ "consitency"
  , getRecipeInformation200ResponseExtendedIngredientsInnerId :: !(Int) -- ^ /Required/ "id"
  , getRecipeInformation200ResponseExtendedIngredientsInnerImage :: !(Text) -- ^ /Required/ "image"
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasures :: !(Maybe GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures) -- ^ "measures"
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeta :: !(Maybe [Text]) -- ^ "meta"
  , getRecipeInformation200ResponseExtendedIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  , getRecipeInformation200ResponseExtendedIngredientsInnerOriginal :: !(Text) -- ^ /Required/ "original"
  , getRecipeInformation200ResponseExtendedIngredientsInnerOriginalName :: !(Text) -- ^ /Required/ "originalName"
  , getRecipeInformation200ResponseExtendedIngredientsInnerUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeInformation200ResponseExtendedIngredientsInner
instance A.FromJSON GetRecipeInformation200ResponseExtendedIngredientsInner where
  parseJSON = A.withObject "GetRecipeInformation200ResponseExtendedIngredientsInner" $ \o ->
    GetRecipeInformation200ResponseExtendedIngredientsInner
      <$> (o .:  "aisle")
      <*> (o .:  "amount")
      <*> (o .:  "consitency")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:? "measures")
      <*> (o .:? "meta")
      <*> (o .:  "name")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "unit")

-- | ToJSON GetRecipeInformation200ResponseExtendedIngredientsInner
instance A.ToJSON GetRecipeInformation200ResponseExtendedIngredientsInner where
  toJSON GetRecipeInformation200ResponseExtendedIngredientsInner {..} =
   _omitNulls
      [ "aisle" .= getRecipeInformation200ResponseExtendedIngredientsInnerAisle
      , "amount" .= getRecipeInformation200ResponseExtendedIngredientsInnerAmount
      , "consitency" .= getRecipeInformation200ResponseExtendedIngredientsInnerConsitency
      , "id" .= getRecipeInformation200ResponseExtendedIngredientsInnerId
      , "image" .= getRecipeInformation200ResponseExtendedIngredientsInnerImage
      , "measures" .= getRecipeInformation200ResponseExtendedIngredientsInnerMeasures
      , "meta" .= getRecipeInformation200ResponseExtendedIngredientsInnerMeta
      , "name" .= getRecipeInformation200ResponseExtendedIngredientsInnerName
      , "original" .= getRecipeInformation200ResponseExtendedIngredientsInnerOriginal
      , "originalName" .= getRecipeInformation200ResponseExtendedIngredientsInnerOriginalName
      , "unit" .= getRecipeInformation200ResponseExtendedIngredientsInnerUnit
      ]


-- | Construct a value of type 'GetRecipeInformation200ResponseExtendedIngredientsInner' (by applying it's required fields, if any)
mkGetRecipeInformation200ResponseExtendedIngredientsInner
  :: Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerAisle' 
  -> Double -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerAmount' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerConsitency' 
  -> Int -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerId' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerImage' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerName' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerOriginal' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerOriginalName' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerUnit' 
  -> GetRecipeInformation200ResponseExtendedIngredientsInner
mkGetRecipeInformation200ResponseExtendedIngredientsInner getRecipeInformation200ResponseExtendedIngredientsInnerAisle getRecipeInformation200ResponseExtendedIngredientsInnerAmount getRecipeInformation200ResponseExtendedIngredientsInnerConsitency getRecipeInformation200ResponseExtendedIngredientsInnerId getRecipeInformation200ResponseExtendedIngredientsInnerImage getRecipeInformation200ResponseExtendedIngredientsInnerName getRecipeInformation200ResponseExtendedIngredientsInnerOriginal getRecipeInformation200ResponseExtendedIngredientsInnerOriginalName getRecipeInformation200ResponseExtendedIngredientsInnerUnit =
  GetRecipeInformation200ResponseExtendedIngredientsInner
  { getRecipeInformation200ResponseExtendedIngredientsInnerAisle
  , getRecipeInformation200ResponseExtendedIngredientsInnerAmount
  , getRecipeInformation200ResponseExtendedIngredientsInnerConsitency
  , getRecipeInformation200ResponseExtendedIngredientsInnerId
  , getRecipeInformation200ResponseExtendedIngredientsInnerImage
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasures = Nothing
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeta = Nothing
  , getRecipeInformation200ResponseExtendedIngredientsInnerName
  , getRecipeInformation200ResponseExtendedIngredientsInnerOriginal
  , getRecipeInformation200ResponseExtendedIngredientsInnerOriginalName
  , getRecipeInformation200ResponseExtendedIngredientsInnerUnit
  }

-- ** GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
-- | GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
data GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures = GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
  { getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric :: !(GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric) -- ^ /Required/ "metric"
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresUs :: !(GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric) -- ^ /Required/ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
instance A.FromJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures where
  parseJSON = A.withObject "GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures" $ \o ->
    GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
      <$> (o .:  "metric")
      <*> (o .:  "us")

-- | ToJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
instance A.ToJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures where
  toJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures {..} =
   _omitNulls
      [ "metric" .= getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
      , "us" .= getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresUs
      ]


-- | Construct a value of type 'GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures' (by applying it's required fields, if any)
mkGetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
  :: GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric' 
  -> GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresUs' 
  -> GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
mkGetRecipeInformation200ResponseExtendedIngredientsInnerMeasures getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresUs =
  GetRecipeInformation200ResponseExtendedIngredientsInnerMeasures
  { getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresUs
  }

-- ** GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
-- | GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
data GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric = GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
  { getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricAmount :: !(Double) -- ^ /Required/ "amount"
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitShort :: !(Text) -- ^ /Required/ "unitShort"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
instance A.FromJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric where
  parseJSON = A.withObject "GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric" $ \o ->
    GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
      <$> (o .:  "amount")
      <*> (o .:  "unitLong")
      <*> (o .:  "unitShort")

-- | ToJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
instance A.ToJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric where
  toJSON GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric {..} =
   _omitNulls
      [ "amount" .= getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricAmount
      , "unitLong" .= getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitLong
      , "unitShort" .= getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitShort
      ]


-- | Construct a value of type 'GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric' (by applying it's required fields, if any)
mkGetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
  :: Double -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricAmount' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitLong' 
  -> Text -- ^ 'getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitShort' 
  -> GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
mkGetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricAmount getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitLong getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitShort =
  GetRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetric
  { getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricAmount
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitLong
  , getRecipeInformation200ResponseExtendedIngredientsInnerMeasuresMetricUnitShort
  }

-- ** GetRecipeInformation200ResponseWinePairing
-- | GetRecipeInformation200ResponseWinePairing
data GetRecipeInformation200ResponseWinePairing = GetRecipeInformation200ResponseWinePairing
  { getRecipeInformation200ResponseWinePairingPairedWines :: !([Text]) -- ^ /Required/ "pairedWines"
  , getRecipeInformation200ResponseWinePairingPairingText :: !(Text) -- ^ /Required/ "pairingText"
  , getRecipeInformation200ResponseWinePairingProductMatches :: !([GetRecipeInformation200ResponseWinePairingProductMatchesInner]) -- ^ /Required/ "productMatches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeInformation200ResponseWinePairing
instance A.FromJSON GetRecipeInformation200ResponseWinePairing where
  parseJSON = A.withObject "GetRecipeInformation200ResponseWinePairing" $ \o ->
    GetRecipeInformation200ResponseWinePairing
      <$> (o .:  "pairedWines")
      <*> (o .:  "pairingText")
      <*> (o .:  "productMatches")

-- | ToJSON GetRecipeInformation200ResponseWinePairing
instance A.ToJSON GetRecipeInformation200ResponseWinePairing where
  toJSON GetRecipeInformation200ResponseWinePairing {..} =
   _omitNulls
      [ "pairedWines" .= getRecipeInformation200ResponseWinePairingPairedWines
      , "pairingText" .= getRecipeInformation200ResponseWinePairingPairingText
      , "productMatches" .= getRecipeInformation200ResponseWinePairingProductMatches
      ]


-- | Construct a value of type 'GetRecipeInformation200ResponseWinePairing' (by applying it's required fields, if any)
mkGetRecipeInformation200ResponseWinePairing
  :: [Text] -- ^ 'getRecipeInformation200ResponseWinePairingPairedWines' 
  -> Text -- ^ 'getRecipeInformation200ResponseWinePairingPairingText' 
  -> [GetRecipeInformation200ResponseWinePairingProductMatchesInner] -- ^ 'getRecipeInformation200ResponseWinePairingProductMatches' 
  -> GetRecipeInformation200ResponseWinePairing
mkGetRecipeInformation200ResponseWinePairing getRecipeInformation200ResponseWinePairingPairedWines getRecipeInformation200ResponseWinePairingPairingText getRecipeInformation200ResponseWinePairingProductMatches =
  GetRecipeInformation200ResponseWinePairing
  { getRecipeInformation200ResponseWinePairingPairedWines
  , getRecipeInformation200ResponseWinePairingPairingText
  , getRecipeInformation200ResponseWinePairingProductMatches
  }

-- ** GetRecipeInformation200ResponseWinePairingProductMatchesInner
-- | GetRecipeInformation200ResponseWinePairingProductMatchesInner
data GetRecipeInformation200ResponseWinePairingProductMatchesInner = GetRecipeInformation200ResponseWinePairingProductMatchesInner
  { getRecipeInformation200ResponseWinePairingProductMatchesInnerId :: !(Int) -- ^ /Required/ "id"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerTitle :: !(Text) -- ^ /Required/ "title"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerDescription :: !(Text) -- ^ /Required/ "description"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerPrice :: !(Text) -- ^ /Required/ "price"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerAverageRating :: !(Double) -- ^ /Required/ "averageRating"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerRatingCount :: !(Int) -- ^ /Required/ "ratingCount"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerScore :: !(Double) -- ^ /Required/ "score"
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerLink :: !(Text) -- ^ /Required/ "link"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeInformation200ResponseWinePairingProductMatchesInner
instance A.FromJSON GetRecipeInformation200ResponseWinePairingProductMatchesInner where
  parseJSON = A.withObject "GetRecipeInformation200ResponseWinePairingProductMatchesInner" $ \o ->
    GetRecipeInformation200ResponseWinePairingProductMatchesInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "description")
      <*> (o .:  "price")
      <*> (o .:  "imageUrl")
      <*> (o .:  "averageRating")
      <*> (o .:  "ratingCount")
      <*> (o .:  "score")
      <*> (o .:  "link")

-- | ToJSON GetRecipeInformation200ResponseWinePairingProductMatchesInner
instance A.ToJSON GetRecipeInformation200ResponseWinePairingProductMatchesInner where
  toJSON GetRecipeInformation200ResponseWinePairingProductMatchesInner {..} =
   _omitNulls
      [ "id" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerId
      , "title" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerTitle
      , "description" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerDescription
      , "price" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerPrice
      , "imageUrl" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerImageUrl
      , "averageRating" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerAverageRating
      , "ratingCount" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerRatingCount
      , "score" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerScore
      , "link" .= getRecipeInformation200ResponseWinePairingProductMatchesInnerLink
      ]


-- | Construct a value of type 'GetRecipeInformation200ResponseWinePairingProductMatchesInner' (by applying it's required fields, if any)
mkGetRecipeInformation200ResponseWinePairingProductMatchesInner
  :: Int -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerId' 
  -> Text -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerTitle' 
  -> Text -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerDescription' 
  -> Text -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerPrice' 
  -> Text -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerImageUrl' 
  -> Double -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerAverageRating' 
  -> Int -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerRatingCount' 
  -> Double -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerScore' 
  -> Text -- ^ 'getRecipeInformation200ResponseWinePairingProductMatchesInnerLink' 
  -> GetRecipeInformation200ResponseWinePairingProductMatchesInner
mkGetRecipeInformation200ResponseWinePairingProductMatchesInner getRecipeInformation200ResponseWinePairingProductMatchesInnerId getRecipeInformation200ResponseWinePairingProductMatchesInnerTitle getRecipeInformation200ResponseWinePairingProductMatchesInnerDescription getRecipeInformation200ResponseWinePairingProductMatchesInnerPrice getRecipeInformation200ResponseWinePairingProductMatchesInnerImageUrl getRecipeInformation200ResponseWinePairingProductMatchesInnerAverageRating getRecipeInformation200ResponseWinePairingProductMatchesInnerRatingCount getRecipeInformation200ResponseWinePairingProductMatchesInnerScore getRecipeInformation200ResponseWinePairingProductMatchesInnerLink =
  GetRecipeInformation200ResponseWinePairingProductMatchesInner
  { getRecipeInformation200ResponseWinePairingProductMatchesInnerId
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerTitle
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerDescription
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerPrice
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerImageUrl
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerAverageRating
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerRatingCount
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerScore
  , getRecipeInformation200ResponseWinePairingProductMatchesInnerLink
  }

-- ** GetRecipeInformationBulk200ResponseInner
-- | GetRecipeInformationBulk200ResponseInner
data GetRecipeInformationBulk200ResponseInner = GetRecipeInformationBulk200ResponseInner
  { getRecipeInformationBulk200ResponseInnerId :: !(Int) -- ^ /Required/ "id"
  , getRecipeInformationBulk200ResponseInnerTitle :: !(Text) -- ^ /Required/ "title"
  , getRecipeInformationBulk200ResponseInnerImage :: !(Text) -- ^ /Required/ "image"
  , getRecipeInformationBulk200ResponseInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , getRecipeInformationBulk200ResponseInnerServings :: !(Double) -- ^ /Required/ "servings"
  , getRecipeInformationBulk200ResponseInnerReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , getRecipeInformationBulk200ResponseInnerLicense :: !(Text) -- ^ /Required/ "license"
  , getRecipeInformationBulk200ResponseInnerSourceName :: !(Text) -- ^ /Required/ "sourceName"
  , getRecipeInformationBulk200ResponseInnerSourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  , getRecipeInformationBulk200ResponseInnerSpoonacularSourceUrl :: !(Text) -- ^ /Required/ "spoonacularSourceUrl"
  , getRecipeInformationBulk200ResponseInnerAggregateLikes :: !(Int) -- ^ /Required/ "aggregateLikes"
  , getRecipeInformationBulk200ResponseInnerHealthScore :: !(Double) -- ^ /Required/ "healthScore"
  , getRecipeInformationBulk200ResponseInnerSpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  , getRecipeInformationBulk200ResponseInnerPricePerServing :: !(Double) -- ^ /Required/ "pricePerServing"
  , getRecipeInformationBulk200ResponseInnerAnalyzedInstructions :: !([Text]) -- ^ /Required/ "analyzedInstructions"
  , getRecipeInformationBulk200ResponseInnerCheap :: !(Bool) -- ^ /Required/ "cheap"
  , getRecipeInformationBulk200ResponseInnerCreditsText :: !(Text) -- ^ /Required/ "creditsText"
  , getRecipeInformationBulk200ResponseInnerCuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , getRecipeInformationBulk200ResponseInnerDairyFree :: !(Bool) -- ^ /Required/ "dairyFree"
  , getRecipeInformationBulk200ResponseInnerDiets :: !([Text]) -- ^ /Required/ "diets"
  , getRecipeInformationBulk200ResponseInnerGaps :: !(Text) -- ^ /Required/ "gaps"
  , getRecipeInformationBulk200ResponseInnerGlutenFree :: !(Bool) -- ^ /Required/ "glutenFree"
  , getRecipeInformationBulk200ResponseInnerInstructions :: !(Text) -- ^ /Required/ "instructions"
  , getRecipeInformationBulk200ResponseInnerKetogenic :: !(Bool) -- ^ /Required/ "ketogenic"
  , getRecipeInformationBulk200ResponseInnerLowFodmap :: !(Bool) -- ^ /Required/ "lowFodmap"
  , getRecipeInformationBulk200ResponseInnerOccasions :: !([Text]) -- ^ /Required/ "occasions"
  , getRecipeInformationBulk200ResponseInnerSustainable :: !(Bool) -- ^ /Required/ "sustainable"
  , getRecipeInformationBulk200ResponseInnerVegan :: !(Bool) -- ^ /Required/ "vegan"
  , getRecipeInformationBulk200ResponseInnerVegetarian :: !(Bool) -- ^ /Required/ "vegetarian"
  , getRecipeInformationBulk200ResponseInnerVeryHealthy :: !(Bool) -- ^ /Required/ "veryHealthy"
  , getRecipeInformationBulk200ResponseInnerVeryPopular :: !(Bool) -- ^ /Required/ "veryPopular"
  , getRecipeInformationBulk200ResponseInnerWhole30 :: !(Bool) -- ^ /Required/ "whole30"
  , getRecipeInformationBulk200ResponseInnerWeightWatcherSmartPoints :: !(Double) -- ^ /Required/ "weightWatcherSmartPoints"
  , getRecipeInformationBulk200ResponseInnerDishTypes :: !([Text]) -- ^ /Required/ "dishTypes"
  , getRecipeInformationBulk200ResponseInnerExtendedIngredients :: !([GetRecipeInformation200ResponseExtendedIngredientsInner]) -- ^ /Required/ "extendedIngredients"
  , getRecipeInformationBulk200ResponseInnerSummary :: !(Text) -- ^ /Required/ "summary"
  , getRecipeInformationBulk200ResponseInnerWinePairing :: !(GetRecipeInformation200ResponseWinePairing) -- ^ /Required/ "winePairing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeInformationBulk200ResponseInner
instance A.FromJSON GetRecipeInformationBulk200ResponseInner where
  parseJSON = A.withObject "GetRecipeInformationBulk200ResponseInner" $ \o ->
    GetRecipeInformationBulk200ResponseInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "servings")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "license")
      <*> (o .:  "sourceName")
      <*> (o .:  "sourceUrl")
      <*> (o .:  "spoonacularSourceUrl")
      <*> (o .:  "aggregateLikes")
      <*> (o .:  "healthScore")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "pricePerServing")
      <*> (o .:  "analyzedInstructions")
      <*> (o .:  "cheap")
      <*> (o .:  "creditsText")
      <*> (o .:  "cuisines")
      <*> (o .:  "dairyFree")
      <*> (o .:  "diets")
      <*> (o .:  "gaps")
      <*> (o .:  "glutenFree")
      <*> (o .:  "instructions")
      <*> (o .:  "ketogenic")
      <*> (o .:  "lowFodmap")
      <*> (o .:  "occasions")
      <*> (o .:  "sustainable")
      <*> (o .:  "vegan")
      <*> (o .:  "vegetarian")
      <*> (o .:  "veryHealthy")
      <*> (o .:  "veryPopular")
      <*> (o .:  "whole30")
      <*> (o .:  "weightWatcherSmartPoints")
      <*> (o .:  "dishTypes")
      <*> (o .:  "extendedIngredients")
      <*> (o .:  "summary")
      <*> (o .:  "winePairing")

-- | ToJSON GetRecipeInformationBulk200ResponseInner
instance A.ToJSON GetRecipeInformationBulk200ResponseInner where
  toJSON GetRecipeInformationBulk200ResponseInner {..} =
   _omitNulls
      [ "id" .= getRecipeInformationBulk200ResponseInnerId
      , "title" .= getRecipeInformationBulk200ResponseInnerTitle
      , "image" .= getRecipeInformationBulk200ResponseInnerImage
      , "imageType" .= getRecipeInformationBulk200ResponseInnerImageType
      , "servings" .= getRecipeInformationBulk200ResponseInnerServings
      , "readyInMinutes" .= getRecipeInformationBulk200ResponseInnerReadyInMinutes
      , "license" .= getRecipeInformationBulk200ResponseInnerLicense
      , "sourceName" .= getRecipeInformationBulk200ResponseInnerSourceName
      , "sourceUrl" .= getRecipeInformationBulk200ResponseInnerSourceUrl
      , "spoonacularSourceUrl" .= getRecipeInformationBulk200ResponseInnerSpoonacularSourceUrl
      , "aggregateLikes" .= getRecipeInformationBulk200ResponseInnerAggregateLikes
      , "healthScore" .= getRecipeInformationBulk200ResponseInnerHealthScore
      , "spoonacularScore" .= getRecipeInformationBulk200ResponseInnerSpoonacularScore
      , "pricePerServing" .= getRecipeInformationBulk200ResponseInnerPricePerServing
      , "analyzedInstructions" .= getRecipeInformationBulk200ResponseInnerAnalyzedInstructions
      , "cheap" .= getRecipeInformationBulk200ResponseInnerCheap
      , "creditsText" .= getRecipeInformationBulk200ResponseInnerCreditsText
      , "cuisines" .= getRecipeInformationBulk200ResponseInnerCuisines
      , "dairyFree" .= getRecipeInformationBulk200ResponseInnerDairyFree
      , "diets" .= getRecipeInformationBulk200ResponseInnerDiets
      , "gaps" .= getRecipeInformationBulk200ResponseInnerGaps
      , "glutenFree" .= getRecipeInformationBulk200ResponseInnerGlutenFree
      , "instructions" .= getRecipeInformationBulk200ResponseInnerInstructions
      , "ketogenic" .= getRecipeInformationBulk200ResponseInnerKetogenic
      , "lowFodmap" .= getRecipeInformationBulk200ResponseInnerLowFodmap
      , "occasions" .= getRecipeInformationBulk200ResponseInnerOccasions
      , "sustainable" .= getRecipeInformationBulk200ResponseInnerSustainable
      , "vegan" .= getRecipeInformationBulk200ResponseInnerVegan
      , "vegetarian" .= getRecipeInformationBulk200ResponseInnerVegetarian
      , "veryHealthy" .= getRecipeInformationBulk200ResponseInnerVeryHealthy
      , "veryPopular" .= getRecipeInformationBulk200ResponseInnerVeryPopular
      , "whole30" .= getRecipeInformationBulk200ResponseInnerWhole30
      , "weightWatcherSmartPoints" .= getRecipeInformationBulk200ResponseInnerWeightWatcherSmartPoints
      , "dishTypes" .= getRecipeInformationBulk200ResponseInnerDishTypes
      , "extendedIngredients" .= getRecipeInformationBulk200ResponseInnerExtendedIngredients
      , "summary" .= getRecipeInformationBulk200ResponseInnerSummary
      , "winePairing" .= getRecipeInformationBulk200ResponseInnerWinePairing
      ]


-- | Construct a value of type 'GetRecipeInformationBulk200ResponseInner' (by applying it's required fields, if any)
mkGetRecipeInformationBulk200ResponseInner
  :: Int -- ^ 'getRecipeInformationBulk200ResponseInnerId' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerTitle' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerImage' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerImageType' 
  -> Double -- ^ 'getRecipeInformationBulk200ResponseInnerServings' 
  -> Int -- ^ 'getRecipeInformationBulk200ResponseInnerReadyInMinutes' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerLicense' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerSourceName' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerSourceUrl' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerSpoonacularSourceUrl' 
  -> Int -- ^ 'getRecipeInformationBulk200ResponseInnerAggregateLikes' 
  -> Double -- ^ 'getRecipeInformationBulk200ResponseInnerHealthScore' 
  -> Double -- ^ 'getRecipeInformationBulk200ResponseInnerSpoonacularScore' 
  -> Double -- ^ 'getRecipeInformationBulk200ResponseInnerPricePerServing' 
  -> [Text] -- ^ 'getRecipeInformationBulk200ResponseInnerAnalyzedInstructions' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerCheap' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerCreditsText' 
  -> [Text] -- ^ 'getRecipeInformationBulk200ResponseInnerCuisines' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerDairyFree' 
  -> [Text] -- ^ 'getRecipeInformationBulk200ResponseInnerDiets' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerGaps' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerGlutenFree' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerInstructions' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerKetogenic' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerLowFodmap' 
  -> [Text] -- ^ 'getRecipeInformationBulk200ResponseInnerOccasions' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerSustainable' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerVegan' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerVegetarian' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerVeryHealthy' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerVeryPopular' 
  -> Bool -- ^ 'getRecipeInformationBulk200ResponseInnerWhole30' 
  -> Double -- ^ 'getRecipeInformationBulk200ResponseInnerWeightWatcherSmartPoints' 
  -> [Text] -- ^ 'getRecipeInformationBulk200ResponseInnerDishTypes' 
  -> [GetRecipeInformation200ResponseExtendedIngredientsInner] -- ^ 'getRecipeInformationBulk200ResponseInnerExtendedIngredients' 
  -> Text -- ^ 'getRecipeInformationBulk200ResponseInnerSummary' 
  -> GetRecipeInformation200ResponseWinePairing -- ^ 'getRecipeInformationBulk200ResponseInnerWinePairing' 
  -> GetRecipeInformationBulk200ResponseInner
mkGetRecipeInformationBulk200ResponseInner getRecipeInformationBulk200ResponseInnerId getRecipeInformationBulk200ResponseInnerTitle getRecipeInformationBulk200ResponseInnerImage getRecipeInformationBulk200ResponseInnerImageType getRecipeInformationBulk200ResponseInnerServings getRecipeInformationBulk200ResponseInnerReadyInMinutes getRecipeInformationBulk200ResponseInnerLicense getRecipeInformationBulk200ResponseInnerSourceName getRecipeInformationBulk200ResponseInnerSourceUrl getRecipeInformationBulk200ResponseInnerSpoonacularSourceUrl getRecipeInformationBulk200ResponseInnerAggregateLikes getRecipeInformationBulk200ResponseInnerHealthScore getRecipeInformationBulk200ResponseInnerSpoonacularScore getRecipeInformationBulk200ResponseInnerPricePerServing getRecipeInformationBulk200ResponseInnerAnalyzedInstructions getRecipeInformationBulk200ResponseInnerCheap getRecipeInformationBulk200ResponseInnerCreditsText getRecipeInformationBulk200ResponseInnerCuisines getRecipeInformationBulk200ResponseInnerDairyFree getRecipeInformationBulk200ResponseInnerDiets getRecipeInformationBulk200ResponseInnerGaps getRecipeInformationBulk200ResponseInnerGlutenFree getRecipeInformationBulk200ResponseInnerInstructions getRecipeInformationBulk200ResponseInnerKetogenic getRecipeInformationBulk200ResponseInnerLowFodmap getRecipeInformationBulk200ResponseInnerOccasions getRecipeInformationBulk200ResponseInnerSustainable getRecipeInformationBulk200ResponseInnerVegan getRecipeInformationBulk200ResponseInnerVegetarian getRecipeInformationBulk200ResponseInnerVeryHealthy getRecipeInformationBulk200ResponseInnerVeryPopular getRecipeInformationBulk200ResponseInnerWhole30 getRecipeInformationBulk200ResponseInnerWeightWatcherSmartPoints getRecipeInformationBulk200ResponseInnerDishTypes getRecipeInformationBulk200ResponseInnerExtendedIngredients getRecipeInformationBulk200ResponseInnerSummary getRecipeInformationBulk200ResponseInnerWinePairing =
  GetRecipeInformationBulk200ResponseInner
  { getRecipeInformationBulk200ResponseInnerId
  , getRecipeInformationBulk200ResponseInnerTitle
  , getRecipeInformationBulk200ResponseInnerImage
  , getRecipeInformationBulk200ResponseInnerImageType
  , getRecipeInformationBulk200ResponseInnerServings
  , getRecipeInformationBulk200ResponseInnerReadyInMinutes
  , getRecipeInformationBulk200ResponseInnerLicense
  , getRecipeInformationBulk200ResponseInnerSourceName
  , getRecipeInformationBulk200ResponseInnerSourceUrl
  , getRecipeInformationBulk200ResponseInnerSpoonacularSourceUrl
  , getRecipeInformationBulk200ResponseInnerAggregateLikes
  , getRecipeInformationBulk200ResponseInnerHealthScore
  , getRecipeInformationBulk200ResponseInnerSpoonacularScore
  , getRecipeInformationBulk200ResponseInnerPricePerServing
  , getRecipeInformationBulk200ResponseInnerAnalyzedInstructions
  , getRecipeInformationBulk200ResponseInnerCheap
  , getRecipeInformationBulk200ResponseInnerCreditsText
  , getRecipeInformationBulk200ResponseInnerCuisines
  , getRecipeInformationBulk200ResponseInnerDairyFree
  , getRecipeInformationBulk200ResponseInnerDiets
  , getRecipeInformationBulk200ResponseInnerGaps
  , getRecipeInformationBulk200ResponseInnerGlutenFree
  , getRecipeInformationBulk200ResponseInnerInstructions
  , getRecipeInformationBulk200ResponseInnerKetogenic
  , getRecipeInformationBulk200ResponseInnerLowFodmap
  , getRecipeInformationBulk200ResponseInnerOccasions
  , getRecipeInformationBulk200ResponseInnerSustainable
  , getRecipeInformationBulk200ResponseInnerVegan
  , getRecipeInformationBulk200ResponseInnerVegetarian
  , getRecipeInformationBulk200ResponseInnerVeryHealthy
  , getRecipeInformationBulk200ResponseInnerVeryPopular
  , getRecipeInformationBulk200ResponseInnerWhole30
  , getRecipeInformationBulk200ResponseInnerWeightWatcherSmartPoints
  , getRecipeInformationBulk200ResponseInnerDishTypes
  , getRecipeInformationBulk200ResponseInnerExtendedIngredients
  , getRecipeInformationBulk200ResponseInnerSummary
  , getRecipeInformationBulk200ResponseInnerWinePairing
  }

-- ** GetRecipeIngredientsByID200Response
-- | GetRecipeIngredientsByID200Response
-- 
data GetRecipeIngredientsByID200Response = GetRecipeIngredientsByID200Response
  { getRecipeIngredientsByID200ResponseIngredients :: !([GetRecipeIngredientsByID200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeIngredientsByID200Response
instance A.FromJSON GetRecipeIngredientsByID200Response where
  parseJSON = A.withObject "GetRecipeIngredientsByID200Response" $ \o ->
    GetRecipeIngredientsByID200Response
      <$> (o .:  "ingredients")

-- | ToJSON GetRecipeIngredientsByID200Response
instance A.ToJSON GetRecipeIngredientsByID200Response where
  toJSON GetRecipeIngredientsByID200Response {..} =
   _omitNulls
      [ "ingredients" .= getRecipeIngredientsByID200ResponseIngredients
      ]


-- | Construct a value of type 'GetRecipeIngredientsByID200Response' (by applying it's required fields, if any)
mkGetRecipeIngredientsByID200Response
  :: [GetRecipeIngredientsByID200ResponseIngredientsInner] -- ^ 'getRecipeIngredientsByID200ResponseIngredients' 
  -> GetRecipeIngredientsByID200Response
mkGetRecipeIngredientsByID200Response getRecipeIngredientsByID200ResponseIngredients =
  GetRecipeIngredientsByID200Response
  { getRecipeIngredientsByID200ResponseIngredients
  }

-- ** GetRecipeIngredientsByID200ResponseIngredientsInner
-- | GetRecipeIngredientsByID200ResponseIngredientsInner
data GetRecipeIngredientsByID200ResponseIngredientsInner = GetRecipeIngredientsByID200ResponseIngredientsInner
  { getRecipeIngredientsByID200ResponseIngredientsInnerAmount :: !(Maybe GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount) -- ^ "amount"
  , getRecipeIngredientsByID200ResponseIngredientsInnerImage :: !(Text) -- ^ /Required/ "image"
  , getRecipeIngredientsByID200ResponseIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeIngredientsByID200ResponseIngredientsInner
instance A.FromJSON GetRecipeIngredientsByID200ResponseIngredientsInner where
  parseJSON = A.withObject "GetRecipeIngredientsByID200ResponseIngredientsInner" $ \o ->
    GetRecipeIngredientsByID200ResponseIngredientsInner
      <$> (o .:? "amount")
      <*> (o .:  "image")
      <*> (o .:  "name")

-- | ToJSON GetRecipeIngredientsByID200ResponseIngredientsInner
instance A.ToJSON GetRecipeIngredientsByID200ResponseIngredientsInner where
  toJSON GetRecipeIngredientsByID200ResponseIngredientsInner {..} =
   _omitNulls
      [ "amount" .= getRecipeIngredientsByID200ResponseIngredientsInnerAmount
      , "image" .= getRecipeIngredientsByID200ResponseIngredientsInnerImage
      , "name" .= getRecipeIngredientsByID200ResponseIngredientsInnerName
      ]


-- | Construct a value of type 'GetRecipeIngredientsByID200ResponseIngredientsInner' (by applying it's required fields, if any)
mkGetRecipeIngredientsByID200ResponseIngredientsInner
  :: Text -- ^ 'getRecipeIngredientsByID200ResponseIngredientsInnerImage' 
  -> Text -- ^ 'getRecipeIngredientsByID200ResponseIngredientsInnerName' 
  -> GetRecipeIngredientsByID200ResponseIngredientsInner
mkGetRecipeIngredientsByID200ResponseIngredientsInner getRecipeIngredientsByID200ResponseIngredientsInnerImage getRecipeIngredientsByID200ResponseIngredientsInnerName =
  GetRecipeIngredientsByID200ResponseIngredientsInner
  { getRecipeIngredientsByID200ResponseIngredientsInnerAmount = Nothing
  , getRecipeIngredientsByID200ResponseIngredientsInnerImage
  , getRecipeIngredientsByID200ResponseIngredientsInnerName
  }

-- ** GetRecipeNutritionWidgetByID200Response
-- | GetRecipeNutritionWidgetByID200Response
-- 
data GetRecipeNutritionWidgetByID200Response = GetRecipeNutritionWidgetByID200Response
  { getRecipeNutritionWidgetByID200ResponseCalories :: !(Text) -- ^ /Required/ "calories"
  , getRecipeNutritionWidgetByID200ResponseCarbs :: !(Text) -- ^ /Required/ "carbs"
  , getRecipeNutritionWidgetByID200ResponseFat :: !(Text) -- ^ /Required/ "fat"
  , getRecipeNutritionWidgetByID200ResponseProtein :: !(Text) -- ^ /Required/ "protein"
  , getRecipeNutritionWidgetByID200ResponseBad :: !([GetRecipeNutritionWidgetByID200ResponseBadInner]) -- ^ /Required/ "bad"
  , getRecipeNutritionWidgetByID200ResponseGood :: !([GetRecipeNutritionWidgetByID200ResponseGoodInner]) -- ^ /Required/ "good"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeNutritionWidgetByID200Response
instance A.FromJSON GetRecipeNutritionWidgetByID200Response where
  parseJSON = A.withObject "GetRecipeNutritionWidgetByID200Response" $ \o ->
    GetRecipeNutritionWidgetByID200Response
      <$> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "protein")
      <*> (o .:  "bad")
      <*> (o .:  "good")

-- | ToJSON GetRecipeNutritionWidgetByID200Response
instance A.ToJSON GetRecipeNutritionWidgetByID200Response where
  toJSON GetRecipeNutritionWidgetByID200Response {..} =
   _omitNulls
      [ "calories" .= getRecipeNutritionWidgetByID200ResponseCalories
      , "carbs" .= getRecipeNutritionWidgetByID200ResponseCarbs
      , "fat" .= getRecipeNutritionWidgetByID200ResponseFat
      , "protein" .= getRecipeNutritionWidgetByID200ResponseProtein
      , "bad" .= getRecipeNutritionWidgetByID200ResponseBad
      , "good" .= getRecipeNutritionWidgetByID200ResponseGood
      ]


-- | Construct a value of type 'GetRecipeNutritionWidgetByID200Response' (by applying it's required fields, if any)
mkGetRecipeNutritionWidgetByID200Response
  :: Text -- ^ 'getRecipeNutritionWidgetByID200ResponseCalories' 
  -> Text -- ^ 'getRecipeNutritionWidgetByID200ResponseCarbs' 
  -> Text -- ^ 'getRecipeNutritionWidgetByID200ResponseFat' 
  -> Text -- ^ 'getRecipeNutritionWidgetByID200ResponseProtein' 
  -> [GetRecipeNutritionWidgetByID200ResponseBadInner] -- ^ 'getRecipeNutritionWidgetByID200ResponseBad' 
  -> [GetRecipeNutritionWidgetByID200ResponseGoodInner] -- ^ 'getRecipeNutritionWidgetByID200ResponseGood' 
  -> GetRecipeNutritionWidgetByID200Response
mkGetRecipeNutritionWidgetByID200Response getRecipeNutritionWidgetByID200ResponseCalories getRecipeNutritionWidgetByID200ResponseCarbs getRecipeNutritionWidgetByID200ResponseFat getRecipeNutritionWidgetByID200ResponseProtein getRecipeNutritionWidgetByID200ResponseBad getRecipeNutritionWidgetByID200ResponseGood =
  GetRecipeNutritionWidgetByID200Response
  { getRecipeNutritionWidgetByID200ResponseCalories
  , getRecipeNutritionWidgetByID200ResponseCarbs
  , getRecipeNutritionWidgetByID200ResponseFat
  , getRecipeNutritionWidgetByID200ResponseProtein
  , getRecipeNutritionWidgetByID200ResponseBad
  , getRecipeNutritionWidgetByID200ResponseGood
  }

-- ** GetRecipeNutritionWidgetByID200ResponseBadInner
-- | GetRecipeNutritionWidgetByID200ResponseBadInner
data GetRecipeNutritionWidgetByID200ResponseBadInner = GetRecipeNutritionWidgetByID200ResponseBadInner
  { getRecipeNutritionWidgetByID200ResponseBadInnerName :: !(Text) -- ^ /Required/ "name"
  , getRecipeNutritionWidgetByID200ResponseBadInnerAmount :: !(Text) -- ^ /Required/ "amount"
  , getRecipeNutritionWidgetByID200ResponseBadInnerIndented :: !(Bool) -- ^ /Required/ "indented"
  , getRecipeNutritionWidgetByID200ResponseBadInnerPercentOfDailyNeeds :: !(Double) -- ^ /Required/ "percentOfDailyNeeds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeNutritionWidgetByID200ResponseBadInner
instance A.FromJSON GetRecipeNutritionWidgetByID200ResponseBadInner where
  parseJSON = A.withObject "GetRecipeNutritionWidgetByID200ResponseBadInner" $ \o ->
    GetRecipeNutritionWidgetByID200ResponseBadInner
      <$> (o .:  "name")
      <*> (o .:  "amount")
      <*> (o .:  "indented")
      <*> (o .:  "percentOfDailyNeeds")

-- | ToJSON GetRecipeNutritionWidgetByID200ResponseBadInner
instance A.ToJSON GetRecipeNutritionWidgetByID200ResponseBadInner where
  toJSON GetRecipeNutritionWidgetByID200ResponseBadInner {..} =
   _omitNulls
      [ "name" .= getRecipeNutritionWidgetByID200ResponseBadInnerName
      , "amount" .= getRecipeNutritionWidgetByID200ResponseBadInnerAmount
      , "indented" .= getRecipeNutritionWidgetByID200ResponseBadInnerIndented
      , "percentOfDailyNeeds" .= getRecipeNutritionWidgetByID200ResponseBadInnerPercentOfDailyNeeds
      ]


-- | Construct a value of type 'GetRecipeNutritionWidgetByID200ResponseBadInner' (by applying it's required fields, if any)
mkGetRecipeNutritionWidgetByID200ResponseBadInner
  :: Text -- ^ 'getRecipeNutritionWidgetByID200ResponseBadInnerName' 
  -> Text -- ^ 'getRecipeNutritionWidgetByID200ResponseBadInnerAmount' 
  -> Bool -- ^ 'getRecipeNutritionWidgetByID200ResponseBadInnerIndented' 
  -> Double -- ^ 'getRecipeNutritionWidgetByID200ResponseBadInnerPercentOfDailyNeeds' 
  -> GetRecipeNutritionWidgetByID200ResponseBadInner
mkGetRecipeNutritionWidgetByID200ResponseBadInner getRecipeNutritionWidgetByID200ResponseBadInnerName getRecipeNutritionWidgetByID200ResponseBadInnerAmount getRecipeNutritionWidgetByID200ResponseBadInnerIndented getRecipeNutritionWidgetByID200ResponseBadInnerPercentOfDailyNeeds =
  GetRecipeNutritionWidgetByID200ResponseBadInner
  { getRecipeNutritionWidgetByID200ResponseBadInnerName
  , getRecipeNutritionWidgetByID200ResponseBadInnerAmount
  , getRecipeNutritionWidgetByID200ResponseBadInnerIndented
  , getRecipeNutritionWidgetByID200ResponseBadInnerPercentOfDailyNeeds
  }

-- ** GetRecipeNutritionWidgetByID200ResponseGoodInner
-- | GetRecipeNutritionWidgetByID200ResponseGoodInner
data GetRecipeNutritionWidgetByID200ResponseGoodInner = GetRecipeNutritionWidgetByID200ResponseGoodInner
  { getRecipeNutritionWidgetByID200ResponseGoodInnerAmount :: !(Text) -- ^ /Required/ "amount"
  , getRecipeNutritionWidgetByID200ResponseGoodInnerIndented :: !(Bool) -- ^ /Required/ "indented"
  , getRecipeNutritionWidgetByID200ResponseGoodInnerPercentOfDailyNeeds :: !(Double) -- ^ /Required/ "percentOfDailyNeeds"
  , getRecipeNutritionWidgetByID200ResponseGoodInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeNutritionWidgetByID200ResponseGoodInner
instance A.FromJSON GetRecipeNutritionWidgetByID200ResponseGoodInner where
  parseJSON = A.withObject "GetRecipeNutritionWidgetByID200ResponseGoodInner" $ \o ->
    GetRecipeNutritionWidgetByID200ResponseGoodInner
      <$> (o .:  "amount")
      <*> (o .:  "indented")
      <*> (o .:  "percentOfDailyNeeds")
      <*> (o .:  "name")

-- | ToJSON GetRecipeNutritionWidgetByID200ResponseGoodInner
instance A.ToJSON GetRecipeNutritionWidgetByID200ResponseGoodInner where
  toJSON GetRecipeNutritionWidgetByID200ResponseGoodInner {..} =
   _omitNulls
      [ "amount" .= getRecipeNutritionWidgetByID200ResponseGoodInnerAmount
      , "indented" .= getRecipeNutritionWidgetByID200ResponseGoodInnerIndented
      , "percentOfDailyNeeds" .= getRecipeNutritionWidgetByID200ResponseGoodInnerPercentOfDailyNeeds
      , "name" .= getRecipeNutritionWidgetByID200ResponseGoodInnerName
      ]


-- | Construct a value of type 'GetRecipeNutritionWidgetByID200ResponseGoodInner' (by applying it's required fields, if any)
mkGetRecipeNutritionWidgetByID200ResponseGoodInner
  :: Text -- ^ 'getRecipeNutritionWidgetByID200ResponseGoodInnerAmount' 
  -> Bool -- ^ 'getRecipeNutritionWidgetByID200ResponseGoodInnerIndented' 
  -> Double -- ^ 'getRecipeNutritionWidgetByID200ResponseGoodInnerPercentOfDailyNeeds' 
  -> Text -- ^ 'getRecipeNutritionWidgetByID200ResponseGoodInnerName' 
  -> GetRecipeNutritionWidgetByID200ResponseGoodInner
mkGetRecipeNutritionWidgetByID200ResponseGoodInner getRecipeNutritionWidgetByID200ResponseGoodInnerAmount getRecipeNutritionWidgetByID200ResponseGoodInnerIndented getRecipeNutritionWidgetByID200ResponseGoodInnerPercentOfDailyNeeds getRecipeNutritionWidgetByID200ResponseGoodInnerName =
  GetRecipeNutritionWidgetByID200ResponseGoodInner
  { getRecipeNutritionWidgetByID200ResponseGoodInnerAmount
  , getRecipeNutritionWidgetByID200ResponseGoodInnerIndented
  , getRecipeNutritionWidgetByID200ResponseGoodInnerPercentOfDailyNeeds
  , getRecipeNutritionWidgetByID200ResponseGoodInnerName
  }

-- ** GetRecipePriceBreakdownByID200Response
-- | GetRecipePriceBreakdownByID200Response
-- 
data GetRecipePriceBreakdownByID200Response = GetRecipePriceBreakdownByID200Response
  { getRecipePriceBreakdownByID200ResponseIngredients :: !([GetRecipePriceBreakdownByID200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  , getRecipePriceBreakdownByID200ResponseTotalCost :: !(Double) -- ^ /Required/ "totalCost"
  , getRecipePriceBreakdownByID200ResponseTotalCostPerServing :: !(Double) -- ^ /Required/ "totalCostPerServing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipePriceBreakdownByID200Response
instance A.FromJSON GetRecipePriceBreakdownByID200Response where
  parseJSON = A.withObject "GetRecipePriceBreakdownByID200Response" $ \o ->
    GetRecipePriceBreakdownByID200Response
      <$> (o .:  "ingredients")
      <*> (o .:  "totalCost")
      <*> (o .:  "totalCostPerServing")

-- | ToJSON GetRecipePriceBreakdownByID200Response
instance A.ToJSON GetRecipePriceBreakdownByID200Response where
  toJSON GetRecipePriceBreakdownByID200Response {..} =
   _omitNulls
      [ "ingredients" .= getRecipePriceBreakdownByID200ResponseIngredients
      , "totalCost" .= getRecipePriceBreakdownByID200ResponseTotalCost
      , "totalCostPerServing" .= getRecipePriceBreakdownByID200ResponseTotalCostPerServing
      ]


-- | Construct a value of type 'GetRecipePriceBreakdownByID200Response' (by applying it's required fields, if any)
mkGetRecipePriceBreakdownByID200Response
  :: [GetRecipePriceBreakdownByID200ResponseIngredientsInner] -- ^ 'getRecipePriceBreakdownByID200ResponseIngredients' 
  -> Double -- ^ 'getRecipePriceBreakdownByID200ResponseTotalCost' 
  -> Double -- ^ 'getRecipePriceBreakdownByID200ResponseTotalCostPerServing' 
  -> GetRecipePriceBreakdownByID200Response
mkGetRecipePriceBreakdownByID200Response getRecipePriceBreakdownByID200ResponseIngredients getRecipePriceBreakdownByID200ResponseTotalCost getRecipePriceBreakdownByID200ResponseTotalCostPerServing =
  GetRecipePriceBreakdownByID200Response
  { getRecipePriceBreakdownByID200ResponseIngredients
  , getRecipePriceBreakdownByID200ResponseTotalCost
  , getRecipePriceBreakdownByID200ResponseTotalCostPerServing
  }

-- ** GetRecipePriceBreakdownByID200ResponseIngredientsInner
-- | GetRecipePriceBreakdownByID200ResponseIngredientsInner
data GetRecipePriceBreakdownByID200ResponseIngredientsInner = GetRecipePriceBreakdownByID200ResponseIngredientsInner
  { getRecipePriceBreakdownByID200ResponseIngredientsInnerAmount :: !(Maybe GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount) -- ^ "amount"
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerImage :: !(Text) -- ^ /Required/ "image"
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerPrice :: !(Double) -- ^ /Required/ "price"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipePriceBreakdownByID200ResponseIngredientsInner
instance A.FromJSON GetRecipePriceBreakdownByID200ResponseIngredientsInner where
  parseJSON = A.withObject "GetRecipePriceBreakdownByID200ResponseIngredientsInner" $ \o ->
    GetRecipePriceBreakdownByID200ResponseIngredientsInner
      <$> (o .:? "amount")
      <*> (o .:  "image")
      <*> (o .:  "name")
      <*> (o .:  "price")

-- | ToJSON GetRecipePriceBreakdownByID200ResponseIngredientsInner
instance A.ToJSON GetRecipePriceBreakdownByID200ResponseIngredientsInner where
  toJSON GetRecipePriceBreakdownByID200ResponseIngredientsInner {..} =
   _omitNulls
      [ "amount" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
      , "image" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerImage
      , "name" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerName
      , "price" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerPrice
      ]


-- | Construct a value of type 'GetRecipePriceBreakdownByID200ResponseIngredientsInner' (by applying it's required fields, if any)
mkGetRecipePriceBreakdownByID200ResponseIngredientsInner
  :: Text -- ^ 'getRecipePriceBreakdownByID200ResponseIngredientsInnerImage' 
  -> Text -- ^ 'getRecipePriceBreakdownByID200ResponseIngredientsInnerName' 
  -> Double -- ^ 'getRecipePriceBreakdownByID200ResponseIngredientsInnerPrice' 
  -> GetRecipePriceBreakdownByID200ResponseIngredientsInner
mkGetRecipePriceBreakdownByID200ResponseIngredientsInner getRecipePriceBreakdownByID200ResponseIngredientsInnerImage getRecipePriceBreakdownByID200ResponseIngredientsInnerName getRecipePriceBreakdownByID200ResponseIngredientsInnerPrice =
  GetRecipePriceBreakdownByID200ResponseIngredientsInner
  { getRecipePriceBreakdownByID200ResponseIngredientsInnerAmount = Nothing
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerImage
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerName
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerPrice
  }

-- ** GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
-- | GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
data GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount = GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
  { getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric :: !(GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric) -- ^ /Required/ "metric"
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountUs :: !(GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric) -- ^ /Required/ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
instance A.FromJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount where
  parseJSON = A.withObject "GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount" $ \o ->
    GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
      <$> (o .:  "metric")
      <*> (o .:  "us")

-- | ToJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
instance A.ToJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount where
  toJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount {..} =
   _omitNulls
      [ "metric" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
      , "us" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountUs
      ]


-- | Construct a value of type 'GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount' (by applying it's required fields, if any)
mkGetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
  :: GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric -- ^ 'getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric' 
  -> GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric -- ^ 'getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountUs' 
  -> GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
mkGetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountUs =
  GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmount
  { getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountUs
  }

-- ** GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
-- | GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
data GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric = GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
  { getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricUnit :: !(Text) -- ^ /Required/ "unit"
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricValue :: !(Double) -- ^ /Required/ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
instance A.FromJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric where
  parseJSON = A.withObject "GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric" $ \o ->
    GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
      <$> (o .:  "unit")
      <*> (o .:  "value")

-- | ToJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
instance A.ToJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric where
  toJSON GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric {..} =
   _omitNulls
      [ "unit" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricUnit
      , "value" .= getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricValue
      ]


-- | Construct a value of type 'GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric' (by applying it's required fields, if any)
mkGetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
  :: Text -- ^ 'getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricUnit' 
  -> Double -- ^ 'getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricValue' 
  -> GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
mkGetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricUnit getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricValue =
  GetRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetric
  { getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricUnit
  , getRecipePriceBreakdownByID200ResponseIngredientsInnerAmountMetricValue
  }

-- ** GetRecipeTasteByID200Response
-- | GetRecipeTasteByID200Response
-- 
data GetRecipeTasteByID200Response = GetRecipeTasteByID200Response
  { getRecipeTasteByID200ResponseSweetness :: !(Double) -- ^ /Required/ "sweetness"
  , getRecipeTasteByID200ResponseSaltiness :: !(Double) -- ^ /Required/ "saltiness"
  , getRecipeTasteByID200ResponseSourness :: !(Double) -- ^ /Required/ "sourness"
  , getRecipeTasteByID200ResponseBitterness :: !(Double) -- ^ /Required/ "bitterness"
  , getRecipeTasteByID200ResponseSavoriness :: !(Double) -- ^ /Required/ "savoriness"
  , getRecipeTasteByID200ResponseFattiness :: !(Double) -- ^ /Required/ "fattiness"
  , getRecipeTasteByID200ResponseSpiciness :: !(Double) -- ^ /Required/ "spiciness"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetRecipeTasteByID200Response
instance A.FromJSON GetRecipeTasteByID200Response where
  parseJSON = A.withObject "GetRecipeTasteByID200Response" $ \o ->
    GetRecipeTasteByID200Response
      <$> (o .:  "sweetness")
      <*> (o .:  "saltiness")
      <*> (o .:  "sourness")
      <*> (o .:  "bitterness")
      <*> (o .:  "savoriness")
      <*> (o .:  "fattiness")
      <*> (o .:  "spiciness")

-- | ToJSON GetRecipeTasteByID200Response
instance A.ToJSON GetRecipeTasteByID200Response where
  toJSON GetRecipeTasteByID200Response {..} =
   _omitNulls
      [ "sweetness" .= getRecipeTasteByID200ResponseSweetness
      , "saltiness" .= getRecipeTasteByID200ResponseSaltiness
      , "sourness" .= getRecipeTasteByID200ResponseSourness
      , "bitterness" .= getRecipeTasteByID200ResponseBitterness
      , "savoriness" .= getRecipeTasteByID200ResponseSavoriness
      , "fattiness" .= getRecipeTasteByID200ResponseFattiness
      , "spiciness" .= getRecipeTasteByID200ResponseSpiciness
      ]


-- | Construct a value of type 'GetRecipeTasteByID200Response' (by applying it's required fields, if any)
mkGetRecipeTasteByID200Response
  :: Double -- ^ 'getRecipeTasteByID200ResponseSweetness' 
  -> Double -- ^ 'getRecipeTasteByID200ResponseSaltiness' 
  -> Double -- ^ 'getRecipeTasteByID200ResponseSourness' 
  -> Double -- ^ 'getRecipeTasteByID200ResponseBitterness' 
  -> Double -- ^ 'getRecipeTasteByID200ResponseSavoriness' 
  -> Double -- ^ 'getRecipeTasteByID200ResponseFattiness' 
  -> Double -- ^ 'getRecipeTasteByID200ResponseSpiciness' 
  -> GetRecipeTasteByID200Response
mkGetRecipeTasteByID200Response getRecipeTasteByID200ResponseSweetness getRecipeTasteByID200ResponseSaltiness getRecipeTasteByID200ResponseSourness getRecipeTasteByID200ResponseBitterness getRecipeTasteByID200ResponseSavoriness getRecipeTasteByID200ResponseFattiness getRecipeTasteByID200ResponseSpiciness =
  GetRecipeTasteByID200Response
  { getRecipeTasteByID200ResponseSweetness
  , getRecipeTasteByID200ResponseSaltiness
  , getRecipeTasteByID200ResponseSourness
  , getRecipeTasteByID200ResponseBitterness
  , getRecipeTasteByID200ResponseSavoriness
  , getRecipeTasteByID200ResponseFattiness
  , getRecipeTasteByID200ResponseSpiciness
  }

-- ** GetShoppingList200Response
-- | GetShoppingList200Response
-- 
data GetShoppingList200Response = GetShoppingList200Response
  { getShoppingList200ResponseAisles :: !([GetShoppingList200ResponseAislesInner]) -- ^ /Required/ "aisles"
  , getShoppingList200ResponseCost :: !(Double) -- ^ /Required/ "cost"
  , getShoppingList200ResponseStartDate :: !(Double) -- ^ /Required/ "startDate"
  , getShoppingList200ResponseEndDate :: !(Double) -- ^ /Required/ "endDate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetShoppingList200Response
instance A.FromJSON GetShoppingList200Response where
  parseJSON = A.withObject "GetShoppingList200Response" $ \o ->
    GetShoppingList200Response
      <$> (o .:  "aisles")
      <*> (o .:  "cost")
      <*> (o .:  "startDate")
      <*> (o .:  "endDate")

-- | ToJSON GetShoppingList200Response
instance A.ToJSON GetShoppingList200Response where
  toJSON GetShoppingList200Response {..} =
   _omitNulls
      [ "aisles" .= getShoppingList200ResponseAisles
      , "cost" .= getShoppingList200ResponseCost
      , "startDate" .= getShoppingList200ResponseStartDate
      , "endDate" .= getShoppingList200ResponseEndDate
      ]


-- | Construct a value of type 'GetShoppingList200Response' (by applying it's required fields, if any)
mkGetShoppingList200Response
  :: [GetShoppingList200ResponseAislesInner] -- ^ 'getShoppingList200ResponseAisles' 
  -> Double -- ^ 'getShoppingList200ResponseCost' 
  -> Double -- ^ 'getShoppingList200ResponseStartDate' 
  -> Double -- ^ 'getShoppingList200ResponseEndDate' 
  -> GetShoppingList200Response
mkGetShoppingList200Response getShoppingList200ResponseAisles getShoppingList200ResponseCost getShoppingList200ResponseStartDate getShoppingList200ResponseEndDate =
  GetShoppingList200Response
  { getShoppingList200ResponseAisles
  , getShoppingList200ResponseCost
  , getShoppingList200ResponseStartDate
  , getShoppingList200ResponseEndDate
  }

-- ** GetShoppingList200ResponseAislesInner
-- | GetShoppingList200ResponseAislesInner
data GetShoppingList200ResponseAislesInner = GetShoppingList200ResponseAislesInner
  { getShoppingList200ResponseAislesInnerAisle :: !(Text) -- ^ /Required/ "aisle"
  , getShoppingList200ResponseAislesInnerItems :: !(Maybe [GetShoppingList200ResponseAislesInnerItemsInner]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetShoppingList200ResponseAislesInner
instance A.FromJSON GetShoppingList200ResponseAislesInner where
  parseJSON = A.withObject "GetShoppingList200ResponseAislesInner" $ \o ->
    GetShoppingList200ResponseAislesInner
      <$> (o .:  "aisle")
      <*> (o .:? "items")

-- | ToJSON GetShoppingList200ResponseAislesInner
instance A.ToJSON GetShoppingList200ResponseAislesInner where
  toJSON GetShoppingList200ResponseAislesInner {..} =
   _omitNulls
      [ "aisle" .= getShoppingList200ResponseAislesInnerAisle
      , "items" .= getShoppingList200ResponseAislesInnerItems
      ]


-- | Construct a value of type 'GetShoppingList200ResponseAislesInner' (by applying it's required fields, if any)
mkGetShoppingList200ResponseAislesInner
  :: Text -- ^ 'getShoppingList200ResponseAislesInnerAisle' 
  -> GetShoppingList200ResponseAislesInner
mkGetShoppingList200ResponseAislesInner getShoppingList200ResponseAislesInnerAisle =
  GetShoppingList200ResponseAislesInner
  { getShoppingList200ResponseAislesInnerAisle
  , getShoppingList200ResponseAislesInnerItems = Nothing
  }

-- ** GetShoppingList200ResponseAislesInnerItemsInner
-- | GetShoppingList200ResponseAislesInnerItemsInner
data GetShoppingList200ResponseAislesInnerItemsInner = GetShoppingList200ResponseAislesInnerItemsInner
  { getShoppingList200ResponseAislesInnerItemsInnerId :: !(Int) -- ^ /Required/ "id"
  , getShoppingList200ResponseAislesInnerItemsInnerName :: !(Text) -- ^ /Required/ "name"
  , getShoppingList200ResponseAislesInnerItemsInnerMeasures :: !(Maybe GetShoppingList200ResponseAislesInnerItemsInnerMeasures) -- ^ "measures"
  , getShoppingList200ResponseAislesInnerItemsInnerPantryItem :: !(Bool) -- ^ /Required/ "pantryItem"
  , getShoppingList200ResponseAislesInnerItemsInnerAisle :: !(Text) -- ^ /Required/ "aisle"
  , getShoppingList200ResponseAislesInnerItemsInnerCost :: !(Double) -- ^ /Required/ "cost"
  , getShoppingList200ResponseAislesInnerItemsInnerIngredientId :: !(Int) -- ^ /Required/ "ingredientId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetShoppingList200ResponseAislesInnerItemsInner
instance A.FromJSON GetShoppingList200ResponseAislesInnerItemsInner where
  parseJSON = A.withObject "GetShoppingList200ResponseAislesInnerItemsInner" $ \o ->
    GetShoppingList200ResponseAislesInnerItemsInner
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "measures")
      <*> (o .:  "pantryItem")
      <*> (o .:  "aisle")
      <*> (o .:  "cost")
      <*> (o .:  "ingredientId")

-- | ToJSON GetShoppingList200ResponseAislesInnerItemsInner
instance A.ToJSON GetShoppingList200ResponseAislesInnerItemsInner where
  toJSON GetShoppingList200ResponseAislesInnerItemsInner {..} =
   _omitNulls
      [ "id" .= getShoppingList200ResponseAislesInnerItemsInnerId
      , "name" .= getShoppingList200ResponseAislesInnerItemsInnerName
      , "measures" .= getShoppingList200ResponseAislesInnerItemsInnerMeasures
      , "pantryItem" .= getShoppingList200ResponseAislesInnerItemsInnerPantryItem
      , "aisle" .= getShoppingList200ResponseAislesInnerItemsInnerAisle
      , "cost" .= getShoppingList200ResponseAislesInnerItemsInnerCost
      , "ingredientId" .= getShoppingList200ResponseAislesInnerItemsInnerIngredientId
      ]


-- | Construct a value of type 'GetShoppingList200ResponseAislesInnerItemsInner' (by applying it's required fields, if any)
mkGetShoppingList200ResponseAislesInnerItemsInner
  :: Int -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerId' 
  -> Text -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerName' 
  -> Bool -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerPantryItem' 
  -> Text -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerAisle' 
  -> Double -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerCost' 
  -> Int -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerIngredientId' 
  -> GetShoppingList200ResponseAislesInnerItemsInner
mkGetShoppingList200ResponseAislesInnerItemsInner getShoppingList200ResponseAislesInnerItemsInnerId getShoppingList200ResponseAislesInnerItemsInnerName getShoppingList200ResponseAislesInnerItemsInnerPantryItem getShoppingList200ResponseAislesInnerItemsInnerAisle getShoppingList200ResponseAislesInnerItemsInnerCost getShoppingList200ResponseAislesInnerItemsInnerIngredientId =
  GetShoppingList200ResponseAislesInnerItemsInner
  { getShoppingList200ResponseAislesInnerItemsInnerId
  , getShoppingList200ResponseAislesInnerItemsInnerName
  , getShoppingList200ResponseAislesInnerItemsInnerMeasures = Nothing
  , getShoppingList200ResponseAislesInnerItemsInnerPantryItem
  , getShoppingList200ResponseAislesInnerItemsInnerAisle
  , getShoppingList200ResponseAislesInnerItemsInnerCost
  , getShoppingList200ResponseAislesInnerItemsInnerIngredientId
  }

-- ** GetShoppingList200ResponseAislesInnerItemsInnerMeasures
-- | GetShoppingList200ResponseAislesInnerItemsInnerMeasures
data GetShoppingList200ResponseAislesInnerItemsInnerMeasures = GetShoppingList200ResponseAislesInnerItemsInnerMeasures
  { getShoppingList200ResponseAislesInnerItemsInnerMeasuresOriginal :: !(ParseIngredients200ResponseInnerNutritionWeightPerServing) -- ^ /Required/ "original"
  , getShoppingList200ResponseAislesInnerItemsInnerMeasuresMetric :: !(ParseIngredients200ResponseInnerNutritionWeightPerServing) -- ^ /Required/ "metric"
  , getShoppingList200ResponseAislesInnerItemsInnerMeasuresUs :: !(ParseIngredients200ResponseInnerNutritionWeightPerServing) -- ^ /Required/ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetShoppingList200ResponseAislesInnerItemsInnerMeasures
instance A.FromJSON GetShoppingList200ResponseAislesInnerItemsInnerMeasures where
  parseJSON = A.withObject "GetShoppingList200ResponseAislesInnerItemsInnerMeasures" $ \o ->
    GetShoppingList200ResponseAislesInnerItemsInnerMeasures
      <$> (o .:  "original")
      <*> (o .:  "metric")
      <*> (o .:  "us")

-- | ToJSON GetShoppingList200ResponseAislesInnerItemsInnerMeasures
instance A.ToJSON GetShoppingList200ResponseAislesInnerItemsInnerMeasures where
  toJSON GetShoppingList200ResponseAislesInnerItemsInnerMeasures {..} =
   _omitNulls
      [ "original" .= getShoppingList200ResponseAislesInnerItemsInnerMeasuresOriginal
      , "metric" .= getShoppingList200ResponseAislesInnerItemsInnerMeasuresMetric
      , "us" .= getShoppingList200ResponseAislesInnerItemsInnerMeasuresUs
      ]


-- | Construct a value of type 'GetShoppingList200ResponseAislesInnerItemsInnerMeasures' (by applying it's required fields, if any)
mkGetShoppingList200ResponseAislesInnerItemsInnerMeasures
  :: ParseIngredients200ResponseInnerNutritionWeightPerServing -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerMeasuresOriginal' 
  -> ParseIngredients200ResponseInnerNutritionWeightPerServing -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerMeasuresMetric' 
  -> ParseIngredients200ResponseInnerNutritionWeightPerServing -- ^ 'getShoppingList200ResponseAislesInnerItemsInnerMeasuresUs' 
  -> GetShoppingList200ResponseAislesInnerItemsInnerMeasures
mkGetShoppingList200ResponseAislesInnerItemsInnerMeasures getShoppingList200ResponseAislesInnerItemsInnerMeasuresOriginal getShoppingList200ResponseAislesInnerItemsInnerMeasuresMetric getShoppingList200ResponseAislesInnerItemsInnerMeasuresUs =
  GetShoppingList200ResponseAislesInnerItemsInnerMeasures
  { getShoppingList200ResponseAislesInnerItemsInnerMeasuresOriginal
  , getShoppingList200ResponseAislesInnerItemsInnerMeasuresMetric
  , getShoppingList200ResponseAislesInnerItemsInnerMeasuresUs
  }

-- ** GetSimilarRecipes200ResponseInner
-- | GetSimilarRecipes200ResponseInner
data GetSimilarRecipes200ResponseInner = GetSimilarRecipes200ResponseInner
  { getSimilarRecipes200ResponseInnerId :: !(Int) -- ^ /Required/ "id"
  , getSimilarRecipes200ResponseInnerTitle :: !(Text) -- ^ /Required/ "title"
  , getSimilarRecipes200ResponseInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , getSimilarRecipes200ResponseInnerReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , getSimilarRecipes200ResponseInnerServings :: !(Double) -- ^ /Required/ "servings"
  , getSimilarRecipes200ResponseInnerSourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetSimilarRecipes200ResponseInner
instance A.FromJSON GetSimilarRecipes200ResponseInner where
  parseJSON = A.withObject "GetSimilarRecipes200ResponseInner" $ \o ->
    GetSimilarRecipes200ResponseInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "servings")
      <*> (o .:  "sourceUrl")

-- | ToJSON GetSimilarRecipes200ResponseInner
instance A.ToJSON GetSimilarRecipes200ResponseInner where
  toJSON GetSimilarRecipes200ResponseInner {..} =
   _omitNulls
      [ "id" .= getSimilarRecipes200ResponseInnerId
      , "title" .= getSimilarRecipes200ResponseInnerTitle
      , "imageType" .= getSimilarRecipes200ResponseInnerImageType
      , "readyInMinutes" .= getSimilarRecipes200ResponseInnerReadyInMinutes
      , "servings" .= getSimilarRecipes200ResponseInnerServings
      , "sourceUrl" .= getSimilarRecipes200ResponseInnerSourceUrl
      ]


-- | Construct a value of type 'GetSimilarRecipes200ResponseInner' (by applying it's required fields, if any)
mkGetSimilarRecipes200ResponseInner
  :: Int -- ^ 'getSimilarRecipes200ResponseInnerId' 
  -> Text -- ^ 'getSimilarRecipes200ResponseInnerTitle' 
  -> Text -- ^ 'getSimilarRecipes200ResponseInnerImageType' 
  -> Int -- ^ 'getSimilarRecipes200ResponseInnerReadyInMinutes' 
  -> Double -- ^ 'getSimilarRecipes200ResponseInnerServings' 
  -> Text -- ^ 'getSimilarRecipes200ResponseInnerSourceUrl' 
  -> GetSimilarRecipes200ResponseInner
mkGetSimilarRecipes200ResponseInner getSimilarRecipes200ResponseInnerId getSimilarRecipes200ResponseInnerTitle getSimilarRecipes200ResponseInnerImageType getSimilarRecipes200ResponseInnerReadyInMinutes getSimilarRecipes200ResponseInnerServings getSimilarRecipes200ResponseInnerSourceUrl =
  GetSimilarRecipes200ResponseInner
  { getSimilarRecipes200ResponseInnerId
  , getSimilarRecipes200ResponseInnerTitle
  , getSimilarRecipes200ResponseInnerImageType
  , getSimilarRecipes200ResponseInnerReadyInMinutes
  , getSimilarRecipes200ResponseInnerServings
  , getSimilarRecipes200ResponseInnerSourceUrl
  }

-- ** GetWineDescription200Response
-- | GetWineDescription200Response
-- 
data GetWineDescription200Response = GetWineDescription200Response
  { getWineDescription200ResponseWineDescription :: !(Text) -- ^ /Required/ "wineDescription"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWineDescription200Response
instance A.FromJSON GetWineDescription200Response where
  parseJSON = A.withObject "GetWineDescription200Response" $ \o ->
    GetWineDescription200Response
      <$> (o .:  "wineDescription")

-- | ToJSON GetWineDescription200Response
instance A.ToJSON GetWineDescription200Response where
  toJSON GetWineDescription200Response {..} =
   _omitNulls
      [ "wineDescription" .= getWineDescription200ResponseWineDescription
      ]


-- | Construct a value of type 'GetWineDescription200Response' (by applying it's required fields, if any)
mkGetWineDescription200Response
  :: Text -- ^ 'getWineDescription200ResponseWineDescription' 
  -> GetWineDescription200Response
mkGetWineDescription200Response getWineDescription200ResponseWineDescription =
  GetWineDescription200Response
  { getWineDescription200ResponseWineDescription
  }

-- ** GetWinePairing200Response
-- | GetWinePairing200Response
-- 
data GetWinePairing200Response = GetWinePairing200Response
  { getWinePairing200ResponsePairedWines :: !([Text]) -- ^ /Required/ "pairedWines"
  , getWinePairing200ResponsePairingText :: !(Text) -- ^ /Required/ "pairingText"
  , getWinePairing200ResponseProductMatches :: !([GetWinePairing200ResponseProductMatchesInner]) -- ^ /Required/ "productMatches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWinePairing200Response
instance A.FromJSON GetWinePairing200Response where
  parseJSON = A.withObject "GetWinePairing200Response" $ \o ->
    GetWinePairing200Response
      <$> (o .:  "pairedWines")
      <*> (o .:  "pairingText")
      <*> (o .:  "productMatches")

-- | ToJSON GetWinePairing200Response
instance A.ToJSON GetWinePairing200Response where
  toJSON GetWinePairing200Response {..} =
   _omitNulls
      [ "pairedWines" .= getWinePairing200ResponsePairedWines
      , "pairingText" .= getWinePairing200ResponsePairingText
      , "productMatches" .= getWinePairing200ResponseProductMatches
      ]


-- | Construct a value of type 'GetWinePairing200Response' (by applying it's required fields, if any)
mkGetWinePairing200Response
  :: [Text] -- ^ 'getWinePairing200ResponsePairedWines' 
  -> Text -- ^ 'getWinePairing200ResponsePairingText' 
  -> [GetWinePairing200ResponseProductMatchesInner] -- ^ 'getWinePairing200ResponseProductMatches' 
  -> GetWinePairing200Response
mkGetWinePairing200Response getWinePairing200ResponsePairedWines getWinePairing200ResponsePairingText getWinePairing200ResponseProductMatches =
  GetWinePairing200Response
  { getWinePairing200ResponsePairedWines
  , getWinePairing200ResponsePairingText
  , getWinePairing200ResponseProductMatches
  }

-- ** GetWinePairing200ResponseProductMatchesInner
-- | GetWinePairing200ResponseProductMatchesInner
data GetWinePairing200ResponseProductMatchesInner = GetWinePairing200ResponseProductMatchesInner
  { getWinePairing200ResponseProductMatchesInnerId :: !(Int) -- ^ /Required/ "id"
  , getWinePairing200ResponseProductMatchesInnerTitle :: !(Text) -- ^ /Required/ "title"
  , getWinePairing200ResponseProductMatchesInnerAverageRating :: !(Double) -- ^ /Required/ "averageRating"
  , getWinePairing200ResponseProductMatchesInnerDescription :: !(Maybe AnyType) -- ^ "description"
  , getWinePairing200ResponseProductMatchesInnerImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , getWinePairing200ResponseProductMatchesInnerLink :: !(Text) -- ^ /Required/ "link"
  , getWinePairing200ResponseProductMatchesInnerPrice :: !(Text) -- ^ /Required/ "price"
  , getWinePairing200ResponseProductMatchesInnerRatingCount :: !(Int) -- ^ /Required/ "ratingCount"
  , getWinePairing200ResponseProductMatchesInnerScore :: !(Double) -- ^ /Required/ "score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWinePairing200ResponseProductMatchesInner
instance A.FromJSON GetWinePairing200ResponseProductMatchesInner where
  parseJSON = A.withObject "GetWinePairing200ResponseProductMatchesInner" $ \o ->
    GetWinePairing200ResponseProductMatchesInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "averageRating")
      <*> (o .:? "description")
      <*> (o .:  "imageUrl")
      <*> (o .:  "link")
      <*> (o .:  "price")
      <*> (o .:  "ratingCount")
      <*> (o .:  "score")

-- | ToJSON GetWinePairing200ResponseProductMatchesInner
instance A.ToJSON GetWinePairing200ResponseProductMatchesInner where
  toJSON GetWinePairing200ResponseProductMatchesInner {..} =
   _omitNulls
      [ "id" .= getWinePairing200ResponseProductMatchesInnerId
      , "title" .= getWinePairing200ResponseProductMatchesInnerTitle
      , "averageRating" .= getWinePairing200ResponseProductMatchesInnerAverageRating
      , "description" .= getWinePairing200ResponseProductMatchesInnerDescription
      , "imageUrl" .= getWinePairing200ResponseProductMatchesInnerImageUrl
      , "link" .= getWinePairing200ResponseProductMatchesInnerLink
      , "price" .= getWinePairing200ResponseProductMatchesInnerPrice
      , "ratingCount" .= getWinePairing200ResponseProductMatchesInnerRatingCount
      , "score" .= getWinePairing200ResponseProductMatchesInnerScore
      ]


-- | Construct a value of type 'GetWinePairing200ResponseProductMatchesInner' (by applying it's required fields, if any)
mkGetWinePairing200ResponseProductMatchesInner
  :: Int -- ^ 'getWinePairing200ResponseProductMatchesInnerId' 
  -> Text -- ^ 'getWinePairing200ResponseProductMatchesInnerTitle' 
  -> Double -- ^ 'getWinePairing200ResponseProductMatchesInnerAverageRating' 
  -> Text -- ^ 'getWinePairing200ResponseProductMatchesInnerImageUrl' 
  -> Text -- ^ 'getWinePairing200ResponseProductMatchesInnerLink' 
  -> Text -- ^ 'getWinePairing200ResponseProductMatchesInnerPrice' 
  -> Int -- ^ 'getWinePairing200ResponseProductMatchesInnerRatingCount' 
  -> Double -- ^ 'getWinePairing200ResponseProductMatchesInnerScore' 
  -> GetWinePairing200ResponseProductMatchesInner
mkGetWinePairing200ResponseProductMatchesInner getWinePairing200ResponseProductMatchesInnerId getWinePairing200ResponseProductMatchesInnerTitle getWinePairing200ResponseProductMatchesInnerAverageRating getWinePairing200ResponseProductMatchesInnerImageUrl getWinePairing200ResponseProductMatchesInnerLink getWinePairing200ResponseProductMatchesInnerPrice getWinePairing200ResponseProductMatchesInnerRatingCount getWinePairing200ResponseProductMatchesInnerScore =
  GetWinePairing200ResponseProductMatchesInner
  { getWinePairing200ResponseProductMatchesInnerId
  , getWinePairing200ResponseProductMatchesInnerTitle
  , getWinePairing200ResponseProductMatchesInnerAverageRating
  , getWinePairing200ResponseProductMatchesInnerDescription = Nothing
  , getWinePairing200ResponseProductMatchesInnerImageUrl
  , getWinePairing200ResponseProductMatchesInnerLink
  , getWinePairing200ResponseProductMatchesInnerPrice
  , getWinePairing200ResponseProductMatchesInnerRatingCount
  , getWinePairing200ResponseProductMatchesInnerScore
  }

-- ** GetWineRecommendation200Response
-- | GetWineRecommendation200Response
-- 
data GetWineRecommendation200Response = GetWineRecommendation200Response
  { getWineRecommendation200ResponseRecommendedWines :: !([GetWineRecommendation200ResponseRecommendedWinesInner]) -- ^ /Required/ "recommendedWines"
  , getWineRecommendation200ResponseTotalFound :: !(Int) -- ^ /Required/ "totalFound"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWineRecommendation200Response
instance A.FromJSON GetWineRecommendation200Response where
  parseJSON = A.withObject "GetWineRecommendation200Response" $ \o ->
    GetWineRecommendation200Response
      <$> (o .:  "recommendedWines")
      <*> (o .:  "totalFound")

-- | ToJSON GetWineRecommendation200Response
instance A.ToJSON GetWineRecommendation200Response where
  toJSON GetWineRecommendation200Response {..} =
   _omitNulls
      [ "recommendedWines" .= getWineRecommendation200ResponseRecommendedWines
      , "totalFound" .= getWineRecommendation200ResponseTotalFound
      ]


-- | Construct a value of type 'GetWineRecommendation200Response' (by applying it's required fields, if any)
mkGetWineRecommendation200Response
  :: [GetWineRecommendation200ResponseRecommendedWinesInner] -- ^ 'getWineRecommendation200ResponseRecommendedWines' 
  -> Int -- ^ 'getWineRecommendation200ResponseTotalFound' 
  -> GetWineRecommendation200Response
mkGetWineRecommendation200Response getWineRecommendation200ResponseRecommendedWines getWineRecommendation200ResponseTotalFound =
  GetWineRecommendation200Response
  { getWineRecommendation200ResponseRecommendedWines
  , getWineRecommendation200ResponseTotalFound
  }

-- ** GetWineRecommendation200ResponseRecommendedWinesInner
-- | GetWineRecommendation200ResponseRecommendedWinesInner
data GetWineRecommendation200ResponseRecommendedWinesInner = GetWineRecommendation200ResponseRecommendedWinesInner
  { getWineRecommendation200ResponseRecommendedWinesInnerId :: !(Int) -- ^ /Required/ "id"
  , getWineRecommendation200ResponseRecommendedWinesInnerTitle :: !(Text) -- ^ /Required/ "title"
  , getWineRecommendation200ResponseRecommendedWinesInnerAverageRating :: !(Double) -- ^ /Required/ "averageRating"
  , getWineRecommendation200ResponseRecommendedWinesInnerDescription :: !(Text) -- ^ /Required/ "description"
  , getWineRecommendation200ResponseRecommendedWinesInnerImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , getWineRecommendation200ResponseRecommendedWinesInnerLink :: !(Text) -- ^ /Required/ "link"
  , getWineRecommendation200ResponseRecommendedWinesInnerPrice :: !(Text) -- ^ /Required/ "price"
  , getWineRecommendation200ResponseRecommendedWinesInnerRatingCount :: !(Int) -- ^ /Required/ "ratingCount"
  , getWineRecommendation200ResponseRecommendedWinesInnerScore :: !(Double) -- ^ /Required/ "score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetWineRecommendation200ResponseRecommendedWinesInner
instance A.FromJSON GetWineRecommendation200ResponseRecommendedWinesInner where
  parseJSON = A.withObject "GetWineRecommendation200ResponseRecommendedWinesInner" $ \o ->
    GetWineRecommendation200ResponseRecommendedWinesInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "averageRating")
      <*> (o .:  "description")
      <*> (o .:  "imageUrl")
      <*> (o .:  "link")
      <*> (o .:  "price")
      <*> (o .:  "ratingCount")
      <*> (o .:  "score")

-- | ToJSON GetWineRecommendation200ResponseRecommendedWinesInner
instance A.ToJSON GetWineRecommendation200ResponseRecommendedWinesInner where
  toJSON GetWineRecommendation200ResponseRecommendedWinesInner {..} =
   _omitNulls
      [ "id" .= getWineRecommendation200ResponseRecommendedWinesInnerId
      , "title" .= getWineRecommendation200ResponseRecommendedWinesInnerTitle
      , "averageRating" .= getWineRecommendation200ResponseRecommendedWinesInnerAverageRating
      , "description" .= getWineRecommendation200ResponseRecommendedWinesInnerDescription
      , "imageUrl" .= getWineRecommendation200ResponseRecommendedWinesInnerImageUrl
      , "link" .= getWineRecommendation200ResponseRecommendedWinesInnerLink
      , "price" .= getWineRecommendation200ResponseRecommendedWinesInnerPrice
      , "ratingCount" .= getWineRecommendation200ResponseRecommendedWinesInnerRatingCount
      , "score" .= getWineRecommendation200ResponseRecommendedWinesInnerScore
      ]


-- | Construct a value of type 'GetWineRecommendation200ResponseRecommendedWinesInner' (by applying it's required fields, if any)
mkGetWineRecommendation200ResponseRecommendedWinesInner
  :: Int -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerId' 
  -> Text -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerTitle' 
  -> Double -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerAverageRating' 
  -> Text -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerDescription' 
  -> Text -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerImageUrl' 
  -> Text -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerLink' 
  -> Text -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerPrice' 
  -> Int -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerRatingCount' 
  -> Double -- ^ 'getWineRecommendation200ResponseRecommendedWinesInnerScore' 
  -> GetWineRecommendation200ResponseRecommendedWinesInner
mkGetWineRecommendation200ResponseRecommendedWinesInner getWineRecommendation200ResponseRecommendedWinesInnerId getWineRecommendation200ResponseRecommendedWinesInnerTitle getWineRecommendation200ResponseRecommendedWinesInnerAverageRating getWineRecommendation200ResponseRecommendedWinesInnerDescription getWineRecommendation200ResponseRecommendedWinesInnerImageUrl getWineRecommendation200ResponseRecommendedWinesInnerLink getWineRecommendation200ResponseRecommendedWinesInnerPrice getWineRecommendation200ResponseRecommendedWinesInnerRatingCount getWineRecommendation200ResponseRecommendedWinesInnerScore =
  GetWineRecommendation200ResponseRecommendedWinesInner
  { getWineRecommendation200ResponseRecommendedWinesInnerId
  , getWineRecommendation200ResponseRecommendedWinesInnerTitle
  , getWineRecommendation200ResponseRecommendedWinesInnerAverageRating
  , getWineRecommendation200ResponseRecommendedWinesInnerDescription
  , getWineRecommendation200ResponseRecommendedWinesInnerImageUrl
  , getWineRecommendation200ResponseRecommendedWinesInnerLink
  , getWineRecommendation200ResponseRecommendedWinesInnerPrice
  , getWineRecommendation200ResponseRecommendedWinesInnerRatingCount
  , getWineRecommendation200ResponseRecommendedWinesInnerScore
  }

-- ** GuessNutritionByDishName200Response
-- | GuessNutritionByDishName200Response
-- 
data GuessNutritionByDishName200Response = GuessNutritionByDishName200Response
  { guessNutritionByDishName200ResponseCalories :: !(GuessNutritionByDishName200ResponseCalories) -- ^ /Required/ "calories"
  , guessNutritionByDishName200ResponseCarbs :: !(GuessNutritionByDishName200ResponseCalories) -- ^ /Required/ "carbs"
  , guessNutritionByDishName200ResponseFat :: !(GuessNutritionByDishName200ResponseCalories) -- ^ /Required/ "fat"
  , guessNutritionByDishName200ResponseProtein :: !(GuessNutritionByDishName200ResponseCalories) -- ^ /Required/ "protein"
  , guessNutritionByDishName200ResponseRecipesUsed :: !(Int) -- ^ /Required/ "recipesUsed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GuessNutritionByDishName200Response
instance A.FromJSON GuessNutritionByDishName200Response where
  parseJSON = A.withObject "GuessNutritionByDishName200Response" $ \o ->
    GuessNutritionByDishName200Response
      <$> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "protein")
      <*> (o .:  "recipesUsed")

-- | ToJSON GuessNutritionByDishName200Response
instance A.ToJSON GuessNutritionByDishName200Response where
  toJSON GuessNutritionByDishName200Response {..} =
   _omitNulls
      [ "calories" .= guessNutritionByDishName200ResponseCalories
      , "carbs" .= guessNutritionByDishName200ResponseCarbs
      , "fat" .= guessNutritionByDishName200ResponseFat
      , "protein" .= guessNutritionByDishName200ResponseProtein
      , "recipesUsed" .= guessNutritionByDishName200ResponseRecipesUsed
      ]


-- | Construct a value of type 'GuessNutritionByDishName200Response' (by applying it's required fields, if any)
mkGuessNutritionByDishName200Response
  :: GuessNutritionByDishName200ResponseCalories -- ^ 'guessNutritionByDishName200ResponseCalories' 
  -> GuessNutritionByDishName200ResponseCalories -- ^ 'guessNutritionByDishName200ResponseCarbs' 
  -> GuessNutritionByDishName200ResponseCalories -- ^ 'guessNutritionByDishName200ResponseFat' 
  -> GuessNutritionByDishName200ResponseCalories -- ^ 'guessNutritionByDishName200ResponseProtein' 
  -> Int -- ^ 'guessNutritionByDishName200ResponseRecipesUsed' 
  -> GuessNutritionByDishName200Response
mkGuessNutritionByDishName200Response guessNutritionByDishName200ResponseCalories guessNutritionByDishName200ResponseCarbs guessNutritionByDishName200ResponseFat guessNutritionByDishName200ResponseProtein guessNutritionByDishName200ResponseRecipesUsed =
  GuessNutritionByDishName200Response
  { guessNutritionByDishName200ResponseCalories
  , guessNutritionByDishName200ResponseCarbs
  , guessNutritionByDishName200ResponseFat
  , guessNutritionByDishName200ResponseProtein
  , guessNutritionByDishName200ResponseRecipesUsed
  }

-- ** GuessNutritionByDishName200ResponseCalories
-- | GuessNutritionByDishName200ResponseCalories
data GuessNutritionByDishName200ResponseCalories = GuessNutritionByDishName200ResponseCalories
  { guessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent :: !(GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent) -- ^ /Required/ "confidenceRange95Percent"
  , guessNutritionByDishName200ResponseCaloriesStandardDeviation :: !(Double) -- ^ /Required/ "standardDeviation"
  , guessNutritionByDishName200ResponseCaloriesUnit :: !(Text) -- ^ /Required/ "unit"
  , guessNutritionByDishName200ResponseCaloriesValue :: !(Double) -- ^ /Required/ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GuessNutritionByDishName200ResponseCalories
instance A.FromJSON GuessNutritionByDishName200ResponseCalories where
  parseJSON = A.withObject "GuessNutritionByDishName200ResponseCalories" $ \o ->
    GuessNutritionByDishName200ResponseCalories
      <$> (o .:  "confidenceRange95Percent")
      <*> (o .:  "standardDeviation")
      <*> (o .:  "unit")
      <*> (o .:  "value")

-- | ToJSON GuessNutritionByDishName200ResponseCalories
instance A.ToJSON GuessNutritionByDishName200ResponseCalories where
  toJSON GuessNutritionByDishName200ResponseCalories {..} =
   _omitNulls
      [ "confidenceRange95Percent" .= guessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
      , "standardDeviation" .= guessNutritionByDishName200ResponseCaloriesStandardDeviation
      , "unit" .= guessNutritionByDishName200ResponseCaloriesUnit
      , "value" .= guessNutritionByDishName200ResponseCaloriesValue
      ]


-- | Construct a value of type 'GuessNutritionByDishName200ResponseCalories' (by applying it's required fields, if any)
mkGuessNutritionByDishName200ResponseCalories
  :: GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent -- ^ 'guessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent' 
  -> Double -- ^ 'guessNutritionByDishName200ResponseCaloriesStandardDeviation' 
  -> Text -- ^ 'guessNutritionByDishName200ResponseCaloriesUnit' 
  -> Double -- ^ 'guessNutritionByDishName200ResponseCaloriesValue' 
  -> GuessNutritionByDishName200ResponseCalories
mkGuessNutritionByDishName200ResponseCalories guessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent guessNutritionByDishName200ResponseCaloriesStandardDeviation guessNutritionByDishName200ResponseCaloriesUnit guessNutritionByDishName200ResponseCaloriesValue =
  GuessNutritionByDishName200ResponseCalories
  { guessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
  , guessNutritionByDishName200ResponseCaloriesStandardDeviation
  , guessNutritionByDishName200ResponseCaloriesUnit
  , guessNutritionByDishName200ResponseCaloriesValue
  }

-- ** GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
-- | GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
data GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent = GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
  { guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMax :: !(Double) -- ^ /Required/ "max"
  , guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMin :: !(Double) -- ^ /Required/ "min"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
instance A.FromJSON GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent where
  parseJSON = A.withObject "GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent" $ \o ->
    GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
      <$> (o .:  "max")
      <*> (o .:  "min")

-- | ToJSON GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
instance A.ToJSON GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent where
  toJSON GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent {..} =
   _omitNulls
      [ "max" .= guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMax
      , "min" .= guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMin
      ]


-- | Construct a value of type 'GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent' (by applying it's required fields, if any)
mkGuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
  :: Double -- ^ 'guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMax' 
  -> Double -- ^ 'guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMin' 
  -> GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
mkGuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMax guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMin =
  GuessNutritionByDishName200ResponseCaloriesConfidenceRange95Percent
  { guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMax
  , guessNutritionByDishName200ResponseCaloriesConfidenceRange95PercentMin
  }

-- ** ImageAnalysisByURL200Response
-- | ImageAnalysisByURL200Response
-- 
data ImageAnalysisByURL200Response = ImageAnalysisByURL200Response
  { imageAnalysisByURL200ResponseNutrition :: !(ImageAnalysisByURL200ResponseNutrition) -- ^ /Required/ "nutrition"
  , imageAnalysisByURL200ResponseCategory :: !(ImageAnalysisByURL200ResponseCategory) -- ^ /Required/ "category"
  , imageAnalysisByURL200ResponseRecipes :: !([ImageAnalysisByURL200ResponseRecipesInner]) -- ^ /Required/ "recipes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageAnalysisByURL200Response
instance A.FromJSON ImageAnalysisByURL200Response where
  parseJSON = A.withObject "ImageAnalysisByURL200Response" $ \o ->
    ImageAnalysisByURL200Response
      <$> (o .:  "nutrition")
      <*> (o .:  "category")
      <*> (o .:  "recipes")

-- | ToJSON ImageAnalysisByURL200Response
instance A.ToJSON ImageAnalysisByURL200Response where
  toJSON ImageAnalysisByURL200Response {..} =
   _omitNulls
      [ "nutrition" .= imageAnalysisByURL200ResponseNutrition
      , "category" .= imageAnalysisByURL200ResponseCategory
      , "recipes" .= imageAnalysisByURL200ResponseRecipes
      ]


-- | Construct a value of type 'ImageAnalysisByURL200Response' (by applying it's required fields, if any)
mkImageAnalysisByURL200Response
  :: ImageAnalysisByURL200ResponseNutrition -- ^ 'imageAnalysisByURL200ResponseNutrition' 
  -> ImageAnalysisByURL200ResponseCategory -- ^ 'imageAnalysisByURL200ResponseCategory' 
  -> [ImageAnalysisByURL200ResponseRecipesInner] -- ^ 'imageAnalysisByURL200ResponseRecipes' 
  -> ImageAnalysisByURL200Response
mkImageAnalysisByURL200Response imageAnalysisByURL200ResponseNutrition imageAnalysisByURL200ResponseCategory imageAnalysisByURL200ResponseRecipes =
  ImageAnalysisByURL200Response
  { imageAnalysisByURL200ResponseNutrition
  , imageAnalysisByURL200ResponseCategory
  , imageAnalysisByURL200ResponseRecipes
  }

-- ** ImageAnalysisByURL200ResponseCategory
-- | ImageAnalysisByURL200ResponseCategory
data ImageAnalysisByURL200ResponseCategory = ImageAnalysisByURL200ResponseCategory
  { imageAnalysisByURL200ResponseCategoryName :: !(Text) -- ^ /Required/ "name"
  , imageAnalysisByURL200ResponseCategoryProbability :: !(Double) -- ^ /Required/ "probability"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageAnalysisByURL200ResponseCategory
instance A.FromJSON ImageAnalysisByURL200ResponseCategory where
  parseJSON = A.withObject "ImageAnalysisByURL200ResponseCategory" $ \o ->
    ImageAnalysisByURL200ResponseCategory
      <$> (o .:  "name")
      <*> (o .:  "probability")

-- | ToJSON ImageAnalysisByURL200ResponseCategory
instance A.ToJSON ImageAnalysisByURL200ResponseCategory where
  toJSON ImageAnalysisByURL200ResponseCategory {..} =
   _omitNulls
      [ "name" .= imageAnalysisByURL200ResponseCategoryName
      , "probability" .= imageAnalysisByURL200ResponseCategoryProbability
      ]


-- | Construct a value of type 'ImageAnalysisByURL200ResponseCategory' (by applying it's required fields, if any)
mkImageAnalysisByURL200ResponseCategory
  :: Text -- ^ 'imageAnalysisByURL200ResponseCategoryName' 
  -> Double -- ^ 'imageAnalysisByURL200ResponseCategoryProbability' 
  -> ImageAnalysisByURL200ResponseCategory
mkImageAnalysisByURL200ResponseCategory imageAnalysisByURL200ResponseCategoryName imageAnalysisByURL200ResponseCategoryProbability =
  ImageAnalysisByURL200ResponseCategory
  { imageAnalysisByURL200ResponseCategoryName
  , imageAnalysisByURL200ResponseCategoryProbability
  }

-- ** ImageAnalysisByURL200ResponseNutrition
-- | ImageAnalysisByURL200ResponseNutrition
data ImageAnalysisByURL200ResponseNutrition = ImageAnalysisByURL200ResponseNutrition
  { imageAnalysisByURL200ResponseNutritionRecipesUsed :: !(Int) -- ^ /Required/ "recipesUsed"
  , imageAnalysisByURL200ResponseNutritionCalories :: !(ImageAnalysisByURL200ResponseNutritionCalories) -- ^ /Required/ "calories"
  , imageAnalysisByURL200ResponseNutritionFat :: !(ImageAnalysisByURL200ResponseNutritionCalories) -- ^ /Required/ "fat"
  , imageAnalysisByURL200ResponseNutritionProtein :: !(ImageAnalysisByURL200ResponseNutritionCalories) -- ^ /Required/ "protein"
  , imageAnalysisByURL200ResponseNutritionCarbs :: !(ImageAnalysisByURL200ResponseNutritionCalories) -- ^ /Required/ "carbs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageAnalysisByURL200ResponseNutrition
instance A.FromJSON ImageAnalysisByURL200ResponseNutrition where
  parseJSON = A.withObject "ImageAnalysisByURL200ResponseNutrition" $ \o ->
    ImageAnalysisByURL200ResponseNutrition
      <$> (o .:  "recipesUsed")
      <*> (o .:  "calories")
      <*> (o .:  "fat")
      <*> (o .:  "protein")
      <*> (o .:  "carbs")

-- | ToJSON ImageAnalysisByURL200ResponseNutrition
instance A.ToJSON ImageAnalysisByURL200ResponseNutrition where
  toJSON ImageAnalysisByURL200ResponseNutrition {..} =
   _omitNulls
      [ "recipesUsed" .= imageAnalysisByURL200ResponseNutritionRecipesUsed
      , "calories" .= imageAnalysisByURL200ResponseNutritionCalories
      , "fat" .= imageAnalysisByURL200ResponseNutritionFat
      , "protein" .= imageAnalysisByURL200ResponseNutritionProtein
      , "carbs" .= imageAnalysisByURL200ResponseNutritionCarbs
      ]


-- | Construct a value of type 'ImageAnalysisByURL200ResponseNutrition' (by applying it's required fields, if any)
mkImageAnalysisByURL200ResponseNutrition
  :: Int -- ^ 'imageAnalysisByURL200ResponseNutritionRecipesUsed' 
  -> ImageAnalysisByURL200ResponseNutritionCalories -- ^ 'imageAnalysisByURL200ResponseNutritionCalories' 
  -> ImageAnalysisByURL200ResponseNutritionCalories -- ^ 'imageAnalysisByURL200ResponseNutritionFat' 
  -> ImageAnalysisByURL200ResponseNutritionCalories -- ^ 'imageAnalysisByURL200ResponseNutritionProtein' 
  -> ImageAnalysisByURL200ResponseNutritionCalories -- ^ 'imageAnalysisByURL200ResponseNutritionCarbs' 
  -> ImageAnalysisByURL200ResponseNutrition
mkImageAnalysisByURL200ResponseNutrition imageAnalysisByURL200ResponseNutritionRecipesUsed imageAnalysisByURL200ResponseNutritionCalories imageAnalysisByURL200ResponseNutritionFat imageAnalysisByURL200ResponseNutritionProtein imageAnalysisByURL200ResponseNutritionCarbs =
  ImageAnalysisByURL200ResponseNutrition
  { imageAnalysisByURL200ResponseNutritionRecipesUsed
  , imageAnalysisByURL200ResponseNutritionCalories
  , imageAnalysisByURL200ResponseNutritionFat
  , imageAnalysisByURL200ResponseNutritionProtein
  , imageAnalysisByURL200ResponseNutritionCarbs
  }

-- ** ImageAnalysisByURL200ResponseNutritionCalories
-- | ImageAnalysisByURL200ResponseNutritionCalories
data ImageAnalysisByURL200ResponseNutritionCalories = ImageAnalysisByURL200ResponseNutritionCalories
  { imageAnalysisByURL200ResponseNutritionCaloriesValue :: !(Double) -- ^ /Required/ "value"
  , imageAnalysisByURL200ResponseNutritionCaloriesUnit :: !(Text) -- ^ /Required/ "unit"
  , imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent :: !(ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent) -- ^ /Required/ "confidenceRange95Percent"
  , imageAnalysisByURL200ResponseNutritionCaloriesStandardDeviation :: !(Double) -- ^ /Required/ "standardDeviation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageAnalysisByURL200ResponseNutritionCalories
instance A.FromJSON ImageAnalysisByURL200ResponseNutritionCalories where
  parseJSON = A.withObject "ImageAnalysisByURL200ResponseNutritionCalories" $ \o ->
    ImageAnalysisByURL200ResponseNutritionCalories
      <$> (o .:  "value")
      <*> (o .:  "unit")
      <*> (o .:  "confidenceRange95Percent")
      <*> (o .:  "standardDeviation")

-- | ToJSON ImageAnalysisByURL200ResponseNutritionCalories
instance A.ToJSON ImageAnalysisByURL200ResponseNutritionCalories where
  toJSON ImageAnalysisByURL200ResponseNutritionCalories {..} =
   _omitNulls
      [ "value" .= imageAnalysisByURL200ResponseNutritionCaloriesValue
      , "unit" .= imageAnalysisByURL200ResponseNutritionCaloriesUnit
      , "confidenceRange95Percent" .= imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
      , "standardDeviation" .= imageAnalysisByURL200ResponseNutritionCaloriesStandardDeviation
      ]


-- | Construct a value of type 'ImageAnalysisByURL200ResponseNutritionCalories' (by applying it's required fields, if any)
mkImageAnalysisByURL200ResponseNutritionCalories
  :: Double -- ^ 'imageAnalysisByURL200ResponseNutritionCaloriesValue' 
  -> Text -- ^ 'imageAnalysisByURL200ResponseNutritionCaloriesUnit' 
  -> ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent -- ^ 'imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent' 
  -> Double -- ^ 'imageAnalysisByURL200ResponseNutritionCaloriesStandardDeviation' 
  -> ImageAnalysisByURL200ResponseNutritionCalories
mkImageAnalysisByURL200ResponseNutritionCalories imageAnalysisByURL200ResponseNutritionCaloriesValue imageAnalysisByURL200ResponseNutritionCaloriesUnit imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent imageAnalysisByURL200ResponseNutritionCaloriesStandardDeviation =
  ImageAnalysisByURL200ResponseNutritionCalories
  { imageAnalysisByURL200ResponseNutritionCaloriesValue
  , imageAnalysisByURL200ResponseNutritionCaloriesUnit
  , imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
  , imageAnalysisByURL200ResponseNutritionCaloriesStandardDeviation
  }

-- ** ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
-- | ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
data ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent = ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
  { imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMin :: !(Double) -- ^ /Required/ "min"
  , imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMax :: !(Double) -- ^ /Required/ "max"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
instance A.FromJSON ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent where
  parseJSON = A.withObject "ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent" $ \o ->
    ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
      <$> (o .:  "min")
      <*> (o .:  "max")

-- | ToJSON ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
instance A.ToJSON ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent where
  toJSON ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent {..} =
   _omitNulls
      [ "min" .= imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMin
      , "max" .= imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMax
      ]


-- | Construct a value of type 'ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent' (by applying it's required fields, if any)
mkImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
  :: Double -- ^ 'imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMin' 
  -> Double -- ^ 'imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMax' 
  -> ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
mkImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMin imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMax =
  ImageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95Percent
  { imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMin
  , imageAnalysisByURL200ResponseNutritionCaloriesConfidenceRange95PercentMax
  }

-- ** ImageAnalysisByURL200ResponseRecipesInner
-- | ImageAnalysisByURL200ResponseRecipesInner
data ImageAnalysisByURL200ResponseRecipesInner = ImageAnalysisByURL200ResponseRecipesInner
  { imageAnalysisByURL200ResponseRecipesInnerId :: !(Int) -- ^ /Required/ "id"
  , imageAnalysisByURL200ResponseRecipesInnerTitle :: !(Text) -- ^ /Required/ "title"
  , imageAnalysisByURL200ResponseRecipesInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , imageAnalysisByURL200ResponseRecipesInnerUrl :: !(Text) -- ^ /Required/ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageAnalysisByURL200ResponseRecipesInner
instance A.FromJSON ImageAnalysisByURL200ResponseRecipesInner where
  parseJSON = A.withObject "ImageAnalysisByURL200ResponseRecipesInner" $ \o ->
    ImageAnalysisByURL200ResponseRecipesInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")
      <*> (o .:  "url")

-- | ToJSON ImageAnalysisByURL200ResponseRecipesInner
instance A.ToJSON ImageAnalysisByURL200ResponseRecipesInner where
  toJSON ImageAnalysisByURL200ResponseRecipesInner {..} =
   _omitNulls
      [ "id" .= imageAnalysisByURL200ResponseRecipesInnerId
      , "title" .= imageAnalysisByURL200ResponseRecipesInnerTitle
      , "imageType" .= imageAnalysisByURL200ResponseRecipesInnerImageType
      , "url" .= imageAnalysisByURL200ResponseRecipesInnerUrl
      ]


-- | Construct a value of type 'ImageAnalysisByURL200ResponseRecipesInner' (by applying it's required fields, if any)
mkImageAnalysisByURL200ResponseRecipesInner
  :: Int -- ^ 'imageAnalysisByURL200ResponseRecipesInnerId' 
  -> Text -- ^ 'imageAnalysisByURL200ResponseRecipesInnerTitle' 
  -> Text -- ^ 'imageAnalysisByURL200ResponseRecipesInnerImageType' 
  -> Text -- ^ 'imageAnalysisByURL200ResponseRecipesInnerUrl' 
  -> ImageAnalysisByURL200ResponseRecipesInner
mkImageAnalysisByURL200ResponseRecipesInner imageAnalysisByURL200ResponseRecipesInnerId imageAnalysisByURL200ResponseRecipesInnerTitle imageAnalysisByURL200ResponseRecipesInnerImageType imageAnalysisByURL200ResponseRecipesInnerUrl =
  ImageAnalysisByURL200ResponseRecipesInner
  { imageAnalysisByURL200ResponseRecipesInnerId
  , imageAnalysisByURL200ResponseRecipesInnerTitle
  , imageAnalysisByURL200ResponseRecipesInnerImageType
  , imageAnalysisByURL200ResponseRecipesInnerUrl
  }

-- ** ImageClassificationByURL200Response
-- | ImageClassificationByURL200Response
-- 
data ImageClassificationByURL200Response = ImageClassificationByURL200Response
  { imageClassificationByURL200ResponseCategory :: !(Text) -- ^ /Required/ "category"
  , imageClassificationByURL200ResponseProbability :: !(Double) -- ^ /Required/ "probability"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageClassificationByURL200Response
instance A.FromJSON ImageClassificationByURL200Response where
  parseJSON = A.withObject "ImageClassificationByURL200Response" $ \o ->
    ImageClassificationByURL200Response
      <$> (o .:  "category")
      <*> (o .:  "probability")

-- | ToJSON ImageClassificationByURL200Response
instance A.ToJSON ImageClassificationByURL200Response where
  toJSON ImageClassificationByURL200Response {..} =
   _omitNulls
      [ "category" .= imageClassificationByURL200ResponseCategory
      , "probability" .= imageClassificationByURL200ResponseProbability
      ]


-- | Construct a value of type 'ImageClassificationByURL200Response' (by applying it's required fields, if any)
mkImageClassificationByURL200Response
  :: Text -- ^ 'imageClassificationByURL200ResponseCategory' 
  -> Double -- ^ 'imageClassificationByURL200ResponseProbability' 
  -> ImageClassificationByURL200Response
mkImageClassificationByURL200Response imageClassificationByURL200ResponseCategory imageClassificationByURL200ResponseProbability =
  ImageClassificationByURL200Response
  { imageClassificationByURL200ResponseCategory
  , imageClassificationByURL200ResponseProbability
  }

-- ** IngredientSearch200Response
-- | IngredientSearch200Response
-- 
data IngredientSearch200Response = IngredientSearch200Response
  { ingredientSearch200ResponseResults :: !([IngredientSearch200ResponseResultsInner]) -- ^ /Required/ "results"
  , ingredientSearch200ResponseOffset :: !(Int) -- ^ /Required/ "offset"
  , ingredientSearch200ResponseNumber :: !(Int) -- ^ /Required/ "number"
  , ingredientSearch200ResponseTotalResults :: !(Int) -- ^ /Required/ "totalResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IngredientSearch200Response
instance A.FromJSON IngredientSearch200Response where
  parseJSON = A.withObject "IngredientSearch200Response" $ \o ->
    IngredientSearch200Response
      <$> (o .:  "results")
      <*> (o .:  "offset")
      <*> (o .:  "number")
      <*> (o .:  "totalResults")

-- | ToJSON IngredientSearch200Response
instance A.ToJSON IngredientSearch200Response where
  toJSON IngredientSearch200Response {..} =
   _omitNulls
      [ "results" .= ingredientSearch200ResponseResults
      , "offset" .= ingredientSearch200ResponseOffset
      , "number" .= ingredientSearch200ResponseNumber
      , "totalResults" .= ingredientSearch200ResponseTotalResults
      ]


-- | Construct a value of type 'IngredientSearch200Response' (by applying it's required fields, if any)
mkIngredientSearch200Response
  :: [IngredientSearch200ResponseResultsInner] -- ^ 'ingredientSearch200ResponseResults' 
  -> Int -- ^ 'ingredientSearch200ResponseOffset' 
  -> Int -- ^ 'ingredientSearch200ResponseNumber' 
  -> Int -- ^ 'ingredientSearch200ResponseTotalResults' 
  -> IngredientSearch200Response
mkIngredientSearch200Response ingredientSearch200ResponseResults ingredientSearch200ResponseOffset ingredientSearch200ResponseNumber ingredientSearch200ResponseTotalResults =
  IngredientSearch200Response
  { ingredientSearch200ResponseResults
  , ingredientSearch200ResponseOffset
  , ingredientSearch200ResponseNumber
  , ingredientSearch200ResponseTotalResults
  }

-- ** IngredientSearch200ResponseResultsInner
-- | IngredientSearch200ResponseResultsInner
data IngredientSearch200ResponseResultsInner = IngredientSearch200ResponseResultsInner
  { ingredientSearch200ResponseResultsInnerId :: !(Int) -- ^ /Required/ "id"
  , ingredientSearch200ResponseResultsInnerName :: !(Text) -- ^ /Required/ "name"
  , ingredientSearch200ResponseResultsInnerImage :: !(Text) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IngredientSearch200ResponseResultsInner
instance A.FromJSON IngredientSearch200ResponseResultsInner where
  parseJSON = A.withObject "IngredientSearch200ResponseResultsInner" $ \o ->
    IngredientSearch200ResponseResultsInner
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "image")

-- | ToJSON IngredientSearch200ResponseResultsInner
instance A.ToJSON IngredientSearch200ResponseResultsInner where
  toJSON IngredientSearch200ResponseResultsInner {..} =
   _omitNulls
      [ "id" .= ingredientSearch200ResponseResultsInnerId
      , "name" .= ingredientSearch200ResponseResultsInnerName
      , "image" .= ingredientSearch200ResponseResultsInnerImage
      ]


-- | Construct a value of type 'IngredientSearch200ResponseResultsInner' (by applying it's required fields, if any)
mkIngredientSearch200ResponseResultsInner
  :: Int -- ^ 'ingredientSearch200ResponseResultsInnerId' 
  -> Text -- ^ 'ingredientSearch200ResponseResultsInnerName' 
  -> Text -- ^ 'ingredientSearch200ResponseResultsInnerImage' 
  -> IngredientSearch200ResponseResultsInner
mkIngredientSearch200ResponseResultsInner ingredientSearch200ResponseResultsInnerId ingredientSearch200ResponseResultsInnerName ingredientSearch200ResponseResultsInnerImage =
  IngredientSearch200ResponseResultsInner
  { ingredientSearch200ResponseResultsInnerId
  , ingredientSearch200ResponseResultsInnerName
  , ingredientSearch200ResponseResultsInnerImage
  }

-- ** MapIngredientsToGroceryProducts200ResponseInner
-- | MapIngredientsToGroceryProducts200ResponseInner
data MapIngredientsToGroceryProducts200ResponseInner = MapIngredientsToGroceryProducts200ResponseInner
  { mapIngredientsToGroceryProducts200ResponseInnerOriginal :: !(Text) -- ^ /Required/ "original"
  , mapIngredientsToGroceryProducts200ResponseInnerOriginalName :: !(Text) -- ^ /Required/ "originalName"
  , mapIngredientsToGroceryProducts200ResponseInnerIngredientImage :: !(Text) -- ^ /Required/ "ingredientImage"
  , mapIngredientsToGroceryProducts200ResponseInnerMeta :: !([Text]) -- ^ /Required/ "meta"
  , mapIngredientsToGroceryProducts200ResponseInnerProducts :: !([MapIngredientsToGroceryProducts200ResponseInnerProductsInner]) -- ^ /Required/ "products"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MapIngredientsToGroceryProducts200ResponseInner
instance A.FromJSON MapIngredientsToGroceryProducts200ResponseInner where
  parseJSON = A.withObject "MapIngredientsToGroceryProducts200ResponseInner" $ \o ->
    MapIngredientsToGroceryProducts200ResponseInner
      <$> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "ingredientImage")
      <*> (o .:  "meta")
      <*> (o .:  "products")

-- | ToJSON MapIngredientsToGroceryProducts200ResponseInner
instance A.ToJSON MapIngredientsToGroceryProducts200ResponseInner where
  toJSON MapIngredientsToGroceryProducts200ResponseInner {..} =
   _omitNulls
      [ "original" .= mapIngredientsToGroceryProducts200ResponseInnerOriginal
      , "originalName" .= mapIngredientsToGroceryProducts200ResponseInnerOriginalName
      , "ingredientImage" .= mapIngredientsToGroceryProducts200ResponseInnerIngredientImage
      , "meta" .= mapIngredientsToGroceryProducts200ResponseInnerMeta
      , "products" .= mapIngredientsToGroceryProducts200ResponseInnerProducts
      ]


-- | Construct a value of type 'MapIngredientsToGroceryProducts200ResponseInner' (by applying it's required fields, if any)
mkMapIngredientsToGroceryProducts200ResponseInner
  :: Text -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerOriginal' 
  -> Text -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerOriginalName' 
  -> Text -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerIngredientImage' 
  -> [Text] -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerMeta' 
  -> [MapIngredientsToGroceryProducts200ResponseInnerProductsInner] -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerProducts' 
  -> MapIngredientsToGroceryProducts200ResponseInner
mkMapIngredientsToGroceryProducts200ResponseInner mapIngredientsToGroceryProducts200ResponseInnerOriginal mapIngredientsToGroceryProducts200ResponseInnerOriginalName mapIngredientsToGroceryProducts200ResponseInnerIngredientImage mapIngredientsToGroceryProducts200ResponseInnerMeta mapIngredientsToGroceryProducts200ResponseInnerProducts =
  MapIngredientsToGroceryProducts200ResponseInner
  { mapIngredientsToGroceryProducts200ResponseInnerOriginal
  , mapIngredientsToGroceryProducts200ResponseInnerOriginalName
  , mapIngredientsToGroceryProducts200ResponseInnerIngredientImage
  , mapIngredientsToGroceryProducts200ResponseInnerMeta
  , mapIngredientsToGroceryProducts200ResponseInnerProducts
  }

-- ** MapIngredientsToGroceryProducts200ResponseInnerProductsInner
-- | MapIngredientsToGroceryProducts200ResponseInnerProductsInner
data MapIngredientsToGroceryProducts200ResponseInnerProductsInner = MapIngredientsToGroceryProducts200ResponseInnerProductsInner
  { mapIngredientsToGroceryProducts200ResponseInnerProductsInnerId :: !(Int) -- ^ /Required/ "id"
  , mapIngredientsToGroceryProducts200ResponseInnerProductsInnerTitle :: !(Text) -- ^ /Required/ "title"
  , mapIngredientsToGroceryProducts200ResponseInnerProductsInnerUpc :: !(Text) -- ^ /Required/ "upc"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MapIngredientsToGroceryProducts200ResponseInnerProductsInner
instance A.FromJSON MapIngredientsToGroceryProducts200ResponseInnerProductsInner where
  parseJSON = A.withObject "MapIngredientsToGroceryProducts200ResponseInnerProductsInner" $ \o ->
    MapIngredientsToGroceryProducts200ResponseInnerProductsInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "upc")

-- | ToJSON MapIngredientsToGroceryProducts200ResponseInnerProductsInner
instance A.ToJSON MapIngredientsToGroceryProducts200ResponseInnerProductsInner where
  toJSON MapIngredientsToGroceryProducts200ResponseInnerProductsInner {..} =
   _omitNulls
      [ "id" .= mapIngredientsToGroceryProducts200ResponseInnerProductsInnerId
      , "title" .= mapIngredientsToGroceryProducts200ResponseInnerProductsInnerTitle
      , "upc" .= mapIngredientsToGroceryProducts200ResponseInnerProductsInnerUpc
      ]


-- | Construct a value of type 'MapIngredientsToGroceryProducts200ResponseInnerProductsInner' (by applying it's required fields, if any)
mkMapIngredientsToGroceryProducts200ResponseInnerProductsInner
  :: Int -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerProductsInnerId' 
  -> Text -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerProductsInnerTitle' 
  -> Text -- ^ 'mapIngredientsToGroceryProducts200ResponseInnerProductsInnerUpc' 
  -> MapIngredientsToGroceryProducts200ResponseInnerProductsInner
mkMapIngredientsToGroceryProducts200ResponseInnerProductsInner mapIngredientsToGroceryProducts200ResponseInnerProductsInnerId mapIngredientsToGroceryProducts200ResponseInnerProductsInnerTitle mapIngredientsToGroceryProducts200ResponseInnerProductsInnerUpc =
  MapIngredientsToGroceryProducts200ResponseInnerProductsInner
  { mapIngredientsToGroceryProducts200ResponseInnerProductsInnerId
  , mapIngredientsToGroceryProducts200ResponseInnerProductsInnerTitle
  , mapIngredientsToGroceryProducts200ResponseInnerProductsInnerUpc
  }

-- ** MapIngredientsToGroceryProductsRequest
-- | MapIngredientsToGroceryProductsRequest
-- 
data MapIngredientsToGroceryProductsRequest = MapIngredientsToGroceryProductsRequest
  { mapIngredientsToGroceryProductsRequestIngredients :: !([Text]) -- ^ /Required/ "ingredients"
  , mapIngredientsToGroceryProductsRequestServings :: !(Double) -- ^ /Required/ "servings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MapIngredientsToGroceryProductsRequest
instance A.FromJSON MapIngredientsToGroceryProductsRequest where
  parseJSON = A.withObject "MapIngredientsToGroceryProductsRequest" $ \o ->
    MapIngredientsToGroceryProductsRequest
      <$> (o .:  "ingredients")
      <*> (o .:  "servings")

-- | ToJSON MapIngredientsToGroceryProductsRequest
instance A.ToJSON MapIngredientsToGroceryProductsRequest where
  toJSON MapIngredientsToGroceryProductsRequest {..} =
   _omitNulls
      [ "ingredients" .= mapIngredientsToGroceryProductsRequestIngredients
      , "servings" .= mapIngredientsToGroceryProductsRequestServings
      ]


-- | Construct a value of type 'MapIngredientsToGroceryProductsRequest' (by applying it's required fields, if any)
mkMapIngredientsToGroceryProductsRequest
  :: [Text] -- ^ 'mapIngredientsToGroceryProductsRequestIngredients' 
  -> Double -- ^ 'mapIngredientsToGroceryProductsRequestServings' 
  -> MapIngredientsToGroceryProductsRequest
mkMapIngredientsToGroceryProductsRequest mapIngredientsToGroceryProductsRequestIngredients mapIngredientsToGroceryProductsRequestServings =
  MapIngredientsToGroceryProductsRequest
  { mapIngredientsToGroceryProductsRequestIngredients
  , mapIngredientsToGroceryProductsRequestServings
  }

-- ** ParseIngredients200ResponseInner
-- | ParseIngredients200ResponseInner
data ParseIngredients200ResponseInner = ParseIngredients200ResponseInner
  { parseIngredients200ResponseInnerId :: !(Int) -- ^ /Required/ "id"
  , parseIngredients200ResponseInnerOriginal :: !(Text) -- ^ /Required/ "original"
  , parseIngredients200ResponseInnerOriginalName :: !(Text) -- ^ /Required/ "originalName"
  , parseIngredients200ResponseInnerName :: !(Text) -- ^ /Required/ "name"
  , parseIngredients200ResponseInnerNameClean :: !(Text) -- ^ /Required/ "nameClean"
  , parseIngredients200ResponseInnerAmount :: !(Double) -- ^ /Required/ "amount"
  , parseIngredients200ResponseInnerUnit :: !(Text) -- ^ /Required/ "unit"
  , parseIngredients200ResponseInnerUnitShort :: !(Text) -- ^ /Required/ "unitShort"
  , parseIngredients200ResponseInnerUnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , parseIngredients200ResponseInnerPossibleUnits :: !([Text]) -- ^ /Required/ "possibleUnits"
  , parseIngredients200ResponseInnerEstimatedCost :: !(ParseIngredients200ResponseInnerEstimatedCost) -- ^ /Required/ "estimatedCost"
  , parseIngredients200ResponseInnerConsistency :: !(Text) -- ^ /Required/ "consistency"
  , parseIngredients200ResponseInnerAisle :: !(Text) -- ^ /Required/ "aisle"
  , parseIngredients200ResponseInnerImage :: !(Text) -- ^ /Required/ "image"
  , parseIngredients200ResponseInnerMeta :: !([Text]) -- ^ /Required/ "meta"
  , parseIngredients200ResponseInnerNutrition :: !(ParseIngredients200ResponseInnerNutrition) -- ^ /Required/ "nutrition"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParseIngredients200ResponseInner
instance A.FromJSON ParseIngredients200ResponseInner where
  parseJSON = A.withObject "ParseIngredients200ResponseInner" $ \o ->
    ParseIngredients200ResponseInner
      <$> (o .:  "id")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "name")
      <*> (o .:  "nameClean")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "unitShort")
      <*> (o .:  "unitLong")
      <*> (o .:  "possibleUnits")
      <*> (o .:  "estimatedCost")
      <*> (o .:  "consistency")
      <*> (o .:  "aisle")
      <*> (o .:  "image")
      <*> (o .:  "meta")
      <*> (o .:  "nutrition")

-- | ToJSON ParseIngredients200ResponseInner
instance A.ToJSON ParseIngredients200ResponseInner where
  toJSON ParseIngredients200ResponseInner {..} =
   _omitNulls
      [ "id" .= parseIngredients200ResponseInnerId
      , "original" .= parseIngredients200ResponseInnerOriginal
      , "originalName" .= parseIngredients200ResponseInnerOriginalName
      , "name" .= parseIngredients200ResponseInnerName
      , "nameClean" .= parseIngredients200ResponseInnerNameClean
      , "amount" .= parseIngredients200ResponseInnerAmount
      , "unit" .= parseIngredients200ResponseInnerUnit
      , "unitShort" .= parseIngredients200ResponseInnerUnitShort
      , "unitLong" .= parseIngredients200ResponseInnerUnitLong
      , "possibleUnits" .= parseIngredients200ResponseInnerPossibleUnits
      , "estimatedCost" .= parseIngredients200ResponseInnerEstimatedCost
      , "consistency" .= parseIngredients200ResponseInnerConsistency
      , "aisle" .= parseIngredients200ResponseInnerAisle
      , "image" .= parseIngredients200ResponseInnerImage
      , "meta" .= parseIngredients200ResponseInnerMeta
      , "nutrition" .= parseIngredients200ResponseInnerNutrition
      ]


-- | Construct a value of type 'ParseIngredients200ResponseInner' (by applying it's required fields, if any)
mkParseIngredients200ResponseInner
  :: Int -- ^ 'parseIngredients200ResponseInnerId' 
  -> Text -- ^ 'parseIngredients200ResponseInnerOriginal' 
  -> Text -- ^ 'parseIngredients200ResponseInnerOriginalName' 
  -> Text -- ^ 'parseIngredients200ResponseInnerName' 
  -> Text -- ^ 'parseIngredients200ResponseInnerNameClean' 
  -> Double -- ^ 'parseIngredients200ResponseInnerAmount' 
  -> Text -- ^ 'parseIngredients200ResponseInnerUnit' 
  -> Text -- ^ 'parseIngredients200ResponseInnerUnitShort' 
  -> Text -- ^ 'parseIngredients200ResponseInnerUnitLong' 
  -> [Text] -- ^ 'parseIngredients200ResponseInnerPossibleUnits' 
  -> ParseIngredients200ResponseInnerEstimatedCost -- ^ 'parseIngredients200ResponseInnerEstimatedCost' 
  -> Text -- ^ 'parseIngredients200ResponseInnerConsistency' 
  -> Text -- ^ 'parseIngredients200ResponseInnerAisle' 
  -> Text -- ^ 'parseIngredients200ResponseInnerImage' 
  -> [Text] -- ^ 'parseIngredients200ResponseInnerMeta' 
  -> ParseIngredients200ResponseInnerNutrition -- ^ 'parseIngredients200ResponseInnerNutrition' 
  -> ParseIngredients200ResponseInner
mkParseIngredients200ResponseInner parseIngredients200ResponseInnerId parseIngredients200ResponseInnerOriginal parseIngredients200ResponseInnerOriginalName parseIngredients200ResponseInnerName parseIngredients200ResponseInnerNameClean parseIngredients200ResponseInnerAmount parseIngredients200ResponseInnerUnit parseIngredients200ResponseInnerUnitShort parseIngredients200ResponseInnerUnitLong parseIngredients200ResponseInnerPossibleUnits parseIngredients200ResponseInnerEstimatedCost parseIngredients200ResponseInnerConsistency parseIngredients200ResponseInnerAisle parseIngredients200ResponseInnerImage parseIngredients200ResponseInnerMeta parseIngredients200ResponseInnerNutrition =
  ParseIngredients200ResponseInner
  { parseIngredients200ResponseInnerId
  , parseIngredients200ResponseInnerOriginal
  , parseIngredients200ResponseInnerOriginalName
  , parseIngredients200ResponseInnerName
  , parseIngredients200ResponseInnerNameClean
  , parseIngredients200ResponseInnerAmount
  , parseIngredients200ResponseInnerUnit
  , parseIngredients200ResponseInnerUnitShort
  , parseIngredients200ResponseInnerUnitLong
  , parseIngredients200ResponseInnerPossibleUnits
  , parseIngredients200ResponseInnerEstimatedCost
  , parseIngredients200ResponseInnerConsistency
  , parseIngredients200ResponseInnerAisle
  , parseIngredients200ResponseInnerImage
  , parseIngredients200ResponseInnerMeta
  , parseIngredients200ResponseInnerNutrition
  }

-- ** ParseIngredients200ResponseInnerEstimatedCost
-- | ParseIngredients200ResponseInnerEstimatedCost
data ParseIngredients200ResponseInnerEstimatedCost = ParseIngredients200ResponseInnerEstimatedCost
  { parseIngredients200ResponseInnerEstimatedCostValue :: !(Double) -- ^ /Required/ "value"
  , parseIngredients200ResponseInnerEstimatedCostUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParseIngredients200ResponseInnerEstimatedCost
instance A.FromJSON ParseIngredients200ResponseInnerEstimatedCost where
  parseJSON = A.withObject "ParseIngredients200ResponseInnerEstimatedCost" $ \o ->
    ParseIngredients200ResponseInnerEstimatedCost
      <$> (o .:  "value")
      <*> (o .:  "unit")

-- | ToJSON ParseIngredients200ResponseInnerEstimatedCost
instance A.ToJSON ParseIngredients200ResponseInnerEstimatedCost where
  toJSON ParseIngredients200ResponseInnerEstimatedCost {..} =
   _omitNulls
      [ "value" .= parseIngredients200ResponseInnerEstimatedCostValue
      , "unit" .= parseIngredients200ResponseInnerEstimatedCostUnit
      ]


-- | Construct a value of type 'ParseIngredients200ResponseInnerEstimatedCost' (by applying it's required fields, if any)
mkParseIngredients200ResponseInnerEstimatedCost
  :: Double -- ^ 'parseIngredients200ResponseInnerEstimatedCostValue' 
  -> Text -- ^ 'parseIngredients200ResponseInnerEstimatedCostUnit' 
  -> ParseIngredients200ResponseInnerEstimatedCost
mkParseIngredients200ResponseInnerEstimatedCost parseIngredients200ResponseInnerEstimatedCostValue parseIngredients200ResponseInnerEstimatedCostUnit =
  ParseIngredients200ResponseInnerEstimatedCost
  { parseIngredients200ResponseInnerEstimatedCostValue
  , parseIngredients200ResponseInnerEstimatedCostUnit
  }

-- ** ParseIngredients200ResponseInnerNutrition
-- | ParseIngredients200ResponseInnerNutrition
data ParseIngredients200ResponseInnerNutrition = ParseIngredients200ResponseInnerNutrition
  { parseIngredients200ResponseInnerNutritionNutrients :: !([ParseIngredients200ResponseInnerNutritionNutrientsInner]) -- ^ /Required/ "nutrients"
  , parseIngredients200ResponseInnerNutritionProperties :: !([ParseIngredients200ResponseInnerNutritionPropertiesInner]) -- ^ /Required/ "properties"
  , parseIngredients200ResponseInnerNutritionFlavonoids :: !([ParseIngredients200ResponseInnerNutritionPropertiesInner]) -- ^ /Required/ "flavonoids"
  , parseIngredients200ResponseInnerNutritionCaloricBreakdown :: !(ParseIngredients200ResponseInnerNutritionCaloricBreakdown) -- ^ /Required/ "caloricBreakdown"
  , parseIngredients200ResponseInnerNutritionWeightPerServing :: !(ParseIngredients200ResponseInnerNutritionWeightPerServing) -- ^ /Required/ "weightPerServing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParseIngredients200ResponseInnerNutrition
instance A.FromJSON ParseIngredients200ResponseInnerNutrition where
  parseJSON = A.withObject "ParseIngredients200ResponseInnerNutrition" $ \o ->
    ParseIngredients200ResponseInnerNutrition
      <$> (o .:  "nutrients")
      <*> (o .:  "properties")
      <*> (o .:  "flavonoids")
      <*> (o .:  "caloricBreakdown")
      <*> (o .:  "weightPerServing")

-- | ToJSON ParseIngredients200ResponseInnerNutrition
instance A.ToJSON ParseIngredients200ResponseInnerNutrition where
  toJSON ParseIngredients200ResponseInnerNutrition {..} =
   _omitNulls
      [ "nutrients" .= parseIngredients200ResponseInnerNutritionNutrients
      , "properties" .= parseIngredients200ResponseInnerNutritionProperties
      , "flavonoids" .= parseIngredients200ResponseInnerNutritionFlavonoids
      , "caloricBreakdown" .= parseIngredients200ResponseInnerNutritionCaloricBreakdown
      , "weightPerServing" .= parseIngredients200ResponseInnerNutritionWeightPerServing
      ]


-- | Construct a value of type 'ParseIngredients200ResponseInnerNutrition' (by applying it's required fields, if any)
mkParseIngredients200ResponseInnerNutrition
  :: [ParseIngredients200ResponseInnerNutritionNutrientsInner] -- ^ 'parseIngredients200ResponseInnerNutritionNutrients' 
  -> [ParseIngredients200ResponseInnerNutritionPropertiesInner] -- ^ 'parseIngredients200ResponseInnerNutritionProperties' 
  -> [ParseIngredients200ResponseInnerNutritionPropertiesInner] -- ^ 'parseIngredients200ResponseInnerNutritionFlavonoids' 
  -> ParseIngredients200ResponseInnerNutritionCaloricBreakdown -- ^ 'parseIngredients200ResponseInnerNutritionCaloricBreakdown' 
  -> ParseIngredients200ResponseInnerNutritionWeightPerServing -- ^ 'parseIngredients200ResponseInnerNutritionWeightPerServing' 
  -> ParseIngredients200ResponseInnerNutrition
mkParseIngredients200ResponseInnerNutrition parseIngredients200ResponseInnerNutritionNutrients parseIngredients200ResponseInnerNutritionProperties parseIngredients200ResponseInnerNutritionFlavonoids parseIngredients200ResponseInnerNutritionCaloricBreakdown parseIngredients200ResponseInnerNutritionWeightPerServing =
  ParseIngredients200ResponseInnerNutrition
  { parseIngredients200ResponseInnerNutritionNutrients
  , parseIngredients200ResponseInnerNutritionProperties
  , parseIngredients200ResponseInnerNutritionFlavonoids
  , parseIngredients200ResponseInnerNutritionCaloricBreakdown
  , parseIngredients200ResponseInnerNutritionWeightPerServing
  }

-- ** ParseIngredients200ResponseInnerNutritionCaloricBreakdown
-- | ParseIngredients200ResponseInnerNutritionCaloricBreakdown
data ParseIngredients200ResponseInnerNutritionCaloricBreakdown = ParseIngredients200ResponseInnerNutritionCaloricBreakdown
  { parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentProtein :: !(Double) -- ^ /Required/ "percentProtein"
  , parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentFat :: !(Double) -- ^ /Required/ "percentFat"
  , parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentCarbs :: !(Double) -- ^ /Required/ "percentCarbs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParseIngredients200ResponseInnerNutritionCaloricBreakdown
instance A.FromJSON ParseIngredients200ResponseInnerNutritionCaloricBreakdown where
  parseJSON = A.withObject "ParseIngredients200ResponseInnerNutritionCaloricBreakdown" $ \o ->
    ParseIngredients200ResponseInnerNutritionCaloricBreakdown
      <$> (o .:  "percentProtein")
      <*> (o .:  "percentFat")
      <*> (o .:  "percentCarbs")

-- | ToJSON ParseIngredients200ResponseInnerNutritionCaloricBreakdown
instance A.ToJSON ParseIngredients200ResponseInnerNutritionCaloricBreakdown where
  toJSON ParseIngredients200ResponseInnerNutritionCaloricBreakdown {..} =
   _omitNulls
      [ "percentProtein" .= parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentProtein
      , "percentFat" .= parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentFat
      , "percentCarbs" .= parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentCarbs
      ]


-- | Construct a value of type 'ParseIngredients200ResponseInnerNutritionCaloricBreakdown' (by applying it's required fields, if any)
mkParseIngredients200ResponseInnerNutritionCaloricBreakdown
  :: Double -- ^ 'parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentProtein' 
  -> Double -- ^ 'parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentFat' 
  -> Double -- ^ 'parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentCarbs' 
  -> ParseIngredients200ResponseInnerNutritionCaloricBreakdown
mkParseIngredients200ResponseInnerNutritionCaloricBreakdown parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentProtein parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentFat parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentCarbs =
  ParseIngredients200ResponseInnerNutritionCaloricBreakdown
  { parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentProtein
  , parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentFat
  , parseIngredients200ResponseInnerNutritionCaloricBreakdownPercentCarbs
  }

-- ** ParseIngredients200ResponseInnerNutritionNutrientsInner
-- | ParseIngredients200ResponseInnerNutritionNutrientsInner
data ParseIngredients200ResponseInnerNutritionNutrientsInner = ParseIngredients200ResponseInnerNutritionNutrientsInner
  { parseIngredients200ResponseInnerNutritionNutrientsInnerName :: !(Text) -- ^ /Required/ "name"
  , parseIngredients200ResponseInnerNutritionNutrientsInnerAmount :: !(Double) -- ^ /Required/ "amount"
  , parseIngredients200ResponseInnerNutritionNutrientsInnerUnit :: !(Text) -- ^ /Required/ "unit"
  , parseIngredients200ResponseInnerNutritionNutrientsInnerPercentOfDailyNeeds :: !(Double) -- ^ /Required/ "percentOfDailyNeeds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParseIngredients200ResponseInnerNutritionNutrientsInner
instance A.FromJSON ParseIngredients200ResponseInnerNutritionNutrientsInner where
  parseJSON = A.withObject "ParseIngredients200ResponseInnerNutritionNutrientsInner" $ \o ->
    ParseIngredients200ResponseInnerNutritionNutrientsInner
      <$> (o .:  "name")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "percentOfDailyNeeds")

-- | ToJSON ParseIngredients200ResponseInnerNutritionNutrientsInner
instance A.ToJSON ParseIngredients200ResponseInnerNutritionNutrientsInner where
  toJSON ParseIngredients200ResponseInnerNutritionNutrientsInner {..} =
   _omitNulls
      [ "name" .= parseIngredients200ResponseInnerNutritionNutrientsInnerName
      , "amount" .= parseIngredients200ResponseInnerNutritionNutrientsInnerAmount
      , "unit" .= parseIngredients200ResponseInnerNutritionNutrientsInnerUnit
      , "percentOfDailyNeeds" .= parseIngredients200ResponseInnerNutritionNutrientsInnerPercentOfDailyNeeds
      ]


-- | Construct a value of type 'ParseIngredients200ResponseInnerNutritionNutrientsInner' (by applying it's required fields, if any)
mkParseIngredients200ResponseInnerNutritionNutrientsInner
  :: Text -- ^ 'parseIngredients200ResponseInnerNutritionNutrientsInnerName' 
  -> Double -- ^ 'parseIngredients200ResponseInnerNutritionNutrientsInnerAmount' 
  -> Text -- ^ 'parseIngredients200ResponseInnerNutritionNutrientsInnerUnit' 
  -> Double -- ^ 'parseIngredients200ResponseInnerNutritionNutrientsInnerPercentOfDailyNeeds' 
  -> ParseIngredients200ResponseInnerNutritionNutrientsInner
mkParseIngredients200ResponseInnerNutritionNutrientsInner parseIngredients200ResponseInnerNutritionNutrientsInnerName parseIngredients200ResponseInnerNutritionNutrientsInnerAmount parseIngredients200ResponseInnerNutritionNutrientsInnerUnit parseIngredients200ResponseInnerNutritionNutrientsInnerPercentOfDailyNeeds =
  ParseIngredients200ResponseInnerNutritionNutrientsInner
  { parseIngredients200ResponseInnerNutritionNutrientsInnerName
  , parseIngredients200ResponseInnerNutritionNutrientsInnerAmount
  , parseIngredients200ResponseInnerNutritionNutrientsInnerUnit
  , parseIngredients200ResponseInnerNutritionNutrientsInnerPercentOfDailyNeeds
  }

-- ** ParseIngredients200ResponseInnerNutritionPropertiesInner
-- | ParseIngredients200ResponseInnerNutritionPropertiesInner
data ParseIngredients200ResponseInnerNutritionPropertiesInner = ParseIngredients200ResponseInnerNutritionPropertiesInner
  { parseIngredients200ResponseInnerNutritionPropertiesInnerName :: !(Text) -- ^ /Required/ "name"
  , parseIngredients200ResponseInnerNutritionPropertiesInnerAmount :: !(Double) -- ^ /Required/ "amount"
  , parseIngredients200ResponseInnerNutritionPropertiesInnerUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParseIngredients200ResponseInnerNutritionPropertiesInner
instance A.FromJSON ParseIngredients200ResponseInnerNutritionPropertiesInner where
  parseJSON = A.withObject "ParseIngredients200ResponseInnerNutritionPropertiesInner" $ \o ->
    ParseIngredients200ResponseInnerNutritionPropertiesInner
      <$> (o .:  "name")
      <*> (o .:  "amount")
      <*> (o .:  "unit")

-- | ToJSON ParseIngredients200ResponseInnerNutritionPropertiesInner
instance A.ToJSON ParseIngredients200ResponseInnerNutritionPropertiesInner where
  toJSON ParseIngredients200ResponseInnerNutritionPropertiesInner {..} =
   _omitNulls
      [ "name" .= parseIngredients200ResponseInnerNutritionPropertiesInnerName
      , "amount" .= parseIngredients200ResponseInnerNutritionPropertiesInnerAmount
      , "unit" .= parseIngredients200ResponseInnerNutritionPropertiesInnerUnit
      ]


-- | Construct a value of type 'ParseIngredients200ResponseInnerNutritionPropertiesInner' (by applying it's required fields, if any)
mkParseIngredients200ResponseInnerNutritionPropertiesInner
  :: Text -- ^ 'parseIngredients200ResponseInnerNutritionPropertiesInnerName' 
  -> Double -- ^ 'parseIngredients200ResponseInnerNutritionPropertiesInnerAmount' 
  -> Text -- ^ 'parseIngredients200ResponseInnerNutritionPropertiesInnerUnit' 
  -> ParseIngredients200ResponseInnerNutritionPropertiesInner
mkParseIngredients200ResponseInnerNutritionPropertiesInner parseIngredients200ResponseInnerNutritionPropertiesInnerName parseIngredients200ResponseInnerNutritionPropertiesInnerAmount parseIngredients200ResponseInnerNutritionPropertiesInnerUnit =
  ParseIngredients200ResponseInnerNutritionPropertiesInner
  { parseIngredients200ResponseInnerNutritionPropertiesInnerName
  , parseIngredients200ResponseInnerNutritionPropertiesInnerAmount
  , parseIngredients200ResponseInnerNutritionPropertiesInnerUnit
  }

-- ** ParseIngredients200ResponseInnerNutritionWeightPerServing
-- | ParseIngredients200ResponseInnerNutritionWeightPerServing
data ParseIngredients200ResponseInnerNutritionWeightPerServing = ParseIngredients200ResponseInnerNutritionWeightPerServing
  { parseIngredients200ResponseInnerNutritionWeightPerServingAmount :: !(Double) -- ^ /Required/ "amount"
  , parseIngredients200ResponseInnerNutritionWeightPerServingUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ParseIngredients200ResponseInnerNutritionWeightPerServing
instance A.FromJSON ParseIngredients200ResponseInnerNutritionWeightPerServing where
  parseJSON = A.withObject "ParseIngredients200ResponseInnerNutritionWeightPerServing" $ \o ->
    ParseIngredients200ResponseInnerNutritionWeightPerServing
      <$> (o .:  "amount")
      <*> (o .:  "unit")

-- | ToJSON ParseIngredients200ResponseInnerNutritionWeightPerServing
instance A.ToJSON ParseIngredients200ResponseInnerNutritionWeightPerServing where
  toJSON ParseIngredients200ResponseInnerNutritionWeightPerServing {..} =
   _omitNulls
      [ "amount" .= parseIngredients200ResponseInnerNutritionWeightPerServingAmount
      , "unit" .= parseIngredients200ResponseInnerNutritionWeightPerServingUnit
      ]


-- | Construct a value of type 'ParseIngredients200ResponseInnerNutritionWeightPerServing' (by applying it's required fields, if any)
mkParseIngredients200ResponseInnerNutritionWeightPerServing
  :: Double -- ^ 'parseIngredients200ResponseInnerNutritionWeightPerServingAmount' 
  -> Text -- ^ 'parseIngredients200ResponseInnerNutritionWeightPerServingUnit' 
  -> ParseIngredients200ResponseInnerNutritionWeightPerServing
mkParseIngredients200ResponseInnerNutritionWeightPerServing parseIngredients200ResponseInnerNutritionWeightPerServingAmount parseIngredients200ResponseInnerNutritionWeightPerServingUnit =
  ParseIngredients200ResponseInnerNutritionWeightPerServing
  { parseIngredients200ResponseInnerNutritionWeightPerServingAmount
  , parseIngredients200ResponseInnerNutritionWeightPerServingUnit
  }

-- ** QuickAnswer200Response
-- | QuickAnswer200Response
-- 
data QuickAnswer200Response = QuickAnswer200Response
  { quickAnswer200ResponseAnswer :: !(Text) -- ^ /Required/ "answer"
  , quickAnswer200ResponseImage :: !(Text) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QuickAnswer200Response
instance A.FromJSON QuickAnswer200Response where
  parseJSON = A.withObject "QuickAnswer200Response" $ \o ->
    QuickAnswer200Response
      <$> (o .:  "answer")
      <*> (o .:  "image")

-- | ToJSON QuickAnswer200Response
instance A.ToJSON QuickAnswer200Response where
  toJSON QuickAnswer200Response {..} =
   _omitNulls
      [ "answer" .= quickAnswer200ResponseAnswer
      , "image" .= quickAnswer200ResponseImage
      ]


-- | Construct a value of type 'QuickAnswer200Response' (by applying it's required fields, if any)
mkQuickAnswer200Response
  :: Text -- ^ 'quickAnswer200ResponseAnswer' 
  -> Text -- ^ 'quickAnswer200ResponseImage' 
  -> QuickAnswer200Response
mkQuickAnswer200Response quickAnswer200ResponseAnswer quickAnswer200ResponseImage =
  QuickAnswer200Response
  { quickAnswer200ResponseAnswer
  , quickAnswer200ResponseImage
  }

-- ** SearchAllFood200Response
-- | SearchAllFood200Response
-- 
data SearchAllFood200Response = SearchAllFood200Response
  { searchAllFood200ResponseQuery :: !(Text) -- ^ /Required/ "query"
  , searchAllFood200ResponseTotalResults :: !(Int) -- ^ /Required/ "totalResults"
  , searchAllFood200ResponseLimit :: !(Int) -- ^ /Required/ "limit"
  , searchAllFood200ResponseOffset :: !(Int) -- ^ /Required/ "offset"
  , searchAllFood200ResponseSearchResults :: !([SearchAllFood200ResponseSearchResultsInner]) -- ^ /Required/ "searchResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchAllFood200Response
instance A.FromJSON SearchAllFood200Response where
  parseJSON = A.withObject "SearchAllFood200Response" $ \o ->
    SearchAllFood200Response
      <$> (o .:  "query")
      <*> (o .:  "totalResults")
      <*> (o .:  "limit")
      <*> (o .:  "offset")
      <*> (o .:  "searchResults")

-- | ToJSON SearchAllFood200Response
instance A.ToJSON SearchAllFood200Response where
  toJSON SearchAllFood200Response {..} =
   _omitNulls
      [ "query" .= searchAllFood200ResponseQuery
      , "totalResults" .= searchAllFood200ResponseTotalResults
      , "limit" .= searchAllFood200ResponseLimit
      , "offset" .= searchAllFood200ResponseOffset
      , "searchResults" .= searchAllFood200ResponseSearchResults
      ]


-- | Construct a value of type 'SearchAllFood200Response' (by applying it's required fields, if any)
mkSearchAllFood200Response
  :: Text -- ^ 'searchAllFood200ResponseQuery' 
  -> Int -- ^ 'searchAllFood200ResponseTotalResults' 
  -> Int -- ^ 'searchAllFood200ResponseLimit' 
  -> Int -- ^ 'searchAllFood200ResponseOffset' 
  -> [SearchAllFood200ResponseSearchResultsInner] -- ^ 'searchAllFood200ResponseSearchResults' 
  -> SearchAllFood200Response
mkSearchAllFood200Response searchAllFood200ResponseQuery searchAllFood200ResponseTotalResults searchAllFood200ResponseLimit searchAllFood200ResponseOffset searchAllFood200ResponseSearchResults =
  SearchAllFood200Response
  { searchAllFood200ResponseQuery
  , searchAllFood200ResponseTotalResults
  , searchAllFood200ResponseLimit
  , searchAllFood200ResponseOffset
  , searchAllFood200ResponseSearchResults
  }

-- ** SearchAllFood200ResponseSearchResultsInner
-- | SearchAllFood200ResponseSearchResultsInner
data SearchAllFood200ResponseSearchResultsInner = SearchAllFood200ResponseSearchResultsInner
  { searchAllFood200ResponseSearchResultsInnerName :: !(Text) -- ^ /Required/ "name"
  , searchAllFood200ResponseSearchResultsInnerTotalResults :: !(Int) -- ^ /Required/ "totalResults"
  , searchAllFood200ResponseSearchResultsInnerResults :: !(Maybe [SearchAllFood200ResponseSearchResultsInnerResultsInner]) -- ^ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchAllFood200ResponseSearchResultsInner
instance A.FromJSON SearchAllFood200ResponseSearchResultsInner where
  parseJSON = A.withObject "SearchAllFood200ResponseSearchResultsInner" $ \o ->
    SearchAllFood200ResponseSearchResultsInner
      <$> (o .:  "name")
      <*> (o .:  "totalResults")
      <*> (o .:? "results")

-- | ToJSON SearchAllFood200ResponseSearchResultsInner
instance A.ToJSON SearchAllFood200ResponseSearchResultsInner where
  toJSON SearchAllFood200ResponseSearchResultsInner {..} =
   _omitNulls
      [ "name" .= searchAllFood200ResponseSearchResultsInnerName
      , "totalResults" .= searchAllFood200ResponseSearchResultsInnerTotalResults
      , "results" .= searchAllFood200ResponseSearchResultsInnerResults
      ]


-- | Construct a value of type 'SearchAllFood200ResponseSearchResultsInner' (by applying it's required fields, if any)
mkSearchAllFood200ResponseSearchResultsInner
  :: Text -- ^ 'searchAllFood200ResponseSearchResultsInnerName' 
  -> Int -- ^ 'searchAllFood200ResponseSearchResultsInnerTotalResults' 
  -> SearchAllFood200ResponseSearchResultsInner
mkSearchAllFood200ResponseSearchResultsInner searchAllFood200ResponseSearchResultsInnerName searchAllFood200ResponseSearchResultsInnerTotalResults =
  SearchAllFood200ResponseSearchResultsInner
  { searchAllFood200ResponseSearchResultsInnerName
  , searchAllFood200ResponseSearchResultsInnerTotalResults
  , searchAllFood200ResponseSearchResultsInnerResults = Nothing
  }

-- ** SearchAllFood200ResponseSearchResultsInnerResultsInner
-- | SearchAllFood200ResponseSearchResultsInnerResultsInner
data SearchAllFood200ResponseSearchResultsInnerResultsInner = SearchAllFood200ResponseSearchResultsInnerResultsInner
  { searchAllFood200ResponseSearchResultsInnerResultsInnerId :: !(Text) -- ^ /Required/ "id"
  , searchAllFood200ResponseSearchResultsInnerResultsInnerName :: !(Text) -- ^ /Required/ "name"
  , searchAllFood200ResponseSearchResultsInnerResultsInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchAllFood200ResponseSearchResultsInnerResultsInnerLink :: !(Text) -- ^ /Required/ "link"
  , searchAllFood200ResponseSearchResultsInnerResultsInnerType :: !(Text) -- ^ /Required/ "type"
  , searchAllFood200ResponseSearchResultsInnerResultsInnerRelevance :: !(Double) -- ^ /Required/ "relevance"
  , searchAllFood200ResponseSearchResultsInnerResultsInnerContent :: !(Text) -- ^ /Required/ "content"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchAllFood200ResponseSearchResultsInnerResultsInner
instance A.FromJSON SearchAllFood200ResponseSearchResultsInnerResultsInner where
  parseJSON = A.withObject "SearchAllFood200ResponseSearchResultsInnerResultsInner" $ \o ->
    SearchAllFood200ResponseSearchResultsInnerResultsInner
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "image")
      <*> (o .:  "link")
      <*> (o .:  "type")
      <*> (o .:  "relevance")
      <*> (o .:  "content")

-- | ToJSON SearchAllFood200ResponseSearchResultsInnerResultsInner
instance A.ToJSON SearchAllFood200ResponseSearchResultsInnerResultsInner where
  toJSON SearchAllFood200ResponseSearchResultsInnerResultsInner {..} =
   _omitNulls
      [ "id" .= searchAllFood200ResponseSearchResultsInnerResultsInnerId
      , "name" .= searchAllFood200ResponseSearchResultsInnerResultsInnerName
      , "image" .= searchAllFood200ResponseSearchResultsInnerResultsInnerImage
      , "link" .= searchAllFood200ResponseSearchResultsInnerResultsInnerLink
      , "type" .= searchAllFood200ResponseSearchResultsInnerResultsInnerType
      , "relevance" .= searchAllFood200ResponseSearchResultsInnerResultsInnerRelevance
      , "content" .= searchAllFood200ResponseSearchResultsInnerResultsInnerContent
      ]


-- | Construct a value of type 'SearchAllFood200ResponseSearchResultsInnerResultsInner' (by applying it's required fields, if any)
mkSearchAllFood200ResponseSearchResultsInnerResultsInner
  :: Text -- ^ 'searchAllFood200ResponseSearchResultsInnerResultsInnerId' 
  -> Text -- ^ 'searchAllFood200ResponseSearchResultsInnerResultsInnerName' 
  -> Text -- ^ 'searchAllFood200ResponseSearchResultsInnerResultsInnerImage' 
  -> Text -- ^ 'searchAllFood200ResponseSearchResultsInnerResultsInnerLink' 
  -> Text -- ^ 'searchAllFood200ResponseSearchResultsInnerResultsInnerType' 
  -> Double -- ^ 'searchAllFood200ResponseSearchResultsInnerResultsInnerRelevance' 
  -> Text -- ^ 'searchAllFood200ResponseSearchResultsInnerResultsInnerContent' 
  -> SearchAllFood200ResponseSearchResultsInnerResultsInner
mkSearchAllFood200ResponseSearchResultsInnerResultsInner searchAllFood200ResponseSearchResultsInnerResultsInnerId searchAllFood200ResponseSearchResultsInnerResultsInnerName searchAllFood200ResponseSearchResultsInnerResultsInnerImage searchAllFood200ResponseSearchResultsInnerResultsInnerLink searchAllFood200ResponseSearchResultsInnerResultsInnerType searchAllFood200ResponseSearchResultsInnerResultsInnerRelevance searchAllFood200ResponseSearchResultsInnerResultsInnerContent =
  SearchAllFood200ResponseSearchResultsInnerResultsInner
  { searchAllFood200ResponseSearchResultsInnerResultsInnerId
  , searchAllFood200ResponseSearchResultsInnerResultsInnerName
  , searchAllFood200ResponseSearchResultsInnerResultsInnerImage
  , searchAllFood200ResponseSearchResultsInnerResultsInnerLink
  , searchAllFood200ResponseSearchResultsInnerResultsInnerType
  , searchAllFood200ResponseSearchResultsInnerResultsInnerRelevance
  , searchAllFood200ResponseSearchResultsInnerResultsInnerContent
  }

-- ** SearchCustomFoods200Response
-- | SearchCustomFoods200Response
-- 
data SearchCustomFoods200Response = SearchCustomFoods200Response
  { searchCustomFoods200ResponseCustomFoods :: !([SearchCustomFoods200ResponseCustomFoodsInner]) -- ^ /Required/ "customFoods"
  , searchCustomFoods200ResponseType :: !(Text) -- ^ /Required/ "type"
  , searchCustomFoods200ResponseOffset :: !(Int) -- ^ /Required/ "offset"
  , searchCustomFoods200ResponseNumber :: !(Int) -- ^ /Required/ "number"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchCustomFoods200Response
instance A.FromJSON SearchCustomFoods200Response where
  parseJSON = A.withObject "SearchCustomFoods200Response" $ \o ->
    SearchCustomFoods200Response
      <$> (o .:  "customFoods")
      <*> (o .:  "type")
      <*> (o .:  "offset")
      <*> (o .:  "number")

-- | ToJSON SearchCustomFoods200Response
instance A.ToJSON SearchCustomFoods200Response where
  toJSON SearchCustomFoods200Response {..} =
   _omitNulls
      [ "customFoods" .= searchCustomFoods200ResponseCustomFoods
      , "type" .= searchCustomFoods200ResponseType
      , "offset" .= searchCustomFoods200ResponseOffset
      , "number" .= searchCustomFoods200ResponseNumber
      ]


-- | Construct a value of type 'SearchCustomFoods200Response' (by applying it's required fields, if any)
mkSearchCustomFoods200Response
  :: [SearchCustomFoods200ResponseCustomFoodsInner] -- ^ 'searchCustomFoods200ResponseCustomFoods' 
  -> Text -- ^ 'searchCustomFoods200ResponseType' 
  -> Int -- ^ 'searchCustomFoods200ResponseOffset' 
  -> Int -- ^ 'searchCustomFoods200ResponseNumber' 
  -> SearchCustomFoods200Response
mkSearchCustomFoods200Response searchCustomFoods200ResponseCustomFoods searchCustomFoods200ResponseType searchCustomFoods200ResponseOffset searchCustomFoods200ResponseNumber =
  SearchCustomFoods200Response
  { searchCustomFoods200ResponseCustomFoods
  , searchCustomFoods200ResponseType
  , searchCustomFoods200ResponseOffset
  , searchCustomFoods200ResponseNumber
  }

-- ** SearchCustomFoods200ResponseCustomFoodsInner
-- | SearchCustomFoods200ResponseCustomFoodsInner
data SearchCustomFoods200ResponseCustomFoodsInner = SearchCustomFoods200ResponseCustomFoodsInner
  { searchCustomFoods200ResponseCustomFoodsInnerId :: !(Int) -- ^ /Required/ "id"
  , searchCustomFoods200ResponseCustomFoodsInnerTitle :: !(Text) -- ^ /Required/ "title"
  , searchCustomFoods200ResponseCustomFoodsInnerServings :: !(Double) -- ^ /Required/ "servings"
  , searchCustomFoods200ResponseCustomFoodsInnerImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , searchCustomFoods200ResponseCustomFoodsInnerPrice :: !(Double) -- ^ /Required/ "price"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchCustomFoods200ResponseCustomFoodsInner
instance A.FromJSON SearchCustomFoods200ResponseCustomFoodsInner where
  parseJSON = A.withObject "SearchCustomFoods200ResponseCustomFoodsInner" $ \o ->
    SearchCustomFoods200ResponseCustomFoodsInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "servings")
      <*> (o .:  "imageUrl")
      <*> (o .:  "price")

-- | ToJSON SearchCustomFoods200ResponseCustomFoodsInner
instance A.ToJSON SearchCustomFoods200ResponseCustomFoodsInner where
  toJSON SearchCustomFoods200ResponseCustomFoodsInner {..} =
   _omitNulls
      [ "id" .= searchCustomFoods200ResponseCustomFoodsInnerId
      , "title" .= searchCustomFoods200ResponseCustomFoodsInnerTitle
      , "servings" .= searchCustomFoods200ResponseCustomFoodsInnerServings
      , "imageUrl" .= searchCustomFoods200ResponseCustomFoodsInnerImageUrl
      , "price" .= searchCustomFoods200ResponseCustomFoodsInnerPrice
      ]


-- | Construct a value of type 'SearchCustomFoods200ResponseCustomFoodsInner' (by applying it's required fields, if any)
mkSearchCustomFoods200ResponseCustomFoodsInner
  :: Int -- ^ 'searchCustomFoods200ResponseCustomFoodsInnerId' 
  -> Text -- ^ 'searchCustomFoods200ResponseCustomFoodsInnerTitle' 
  -> Double -- ^ 'searchCustomFoods200ResponseCustomFoodsInnerServings' 
  -> Text -- ^ 'searchCustomFoods200ResponseCustomFoodsInnerImageUrl' 
  -> Double -- ^ 'searchCustomFoods200ResponseCustomFoodsInnerPrice' 
  -> SearchCustomFoods200ResponseCustomFoodsInner
mkSearchCustomFoods200ResponseCustomFoodsInner searchCustomFoods200ResponseCustomFoodsInnerId searchCustomFoods200ResponseCustomFoodsInnerTitle searchCustomFoods200ResponseCustomFoodsInnerServings searchCustomFoods200ResponseCustomFoodsInnerImageUrl searchCustomFoods200ResponseCustomFoodsInnerPrice =
  SearchCustomFoods200ResponseCustomFoodsInner
  { searchCustomFoods200ResponseCustomFoodsInnerId
  , searchCustomFoods200ResponseCustomFoodsInnerTitle
  , searchCustomFoods200ResponseCustomFoodsInnerServings
  , searchCustomFoods200ResponseCustomFoodsInnerImageUrl
  , searchCustomFoods200ResponseCustomFoodsInnerPrice
  }

-- ** SearchFoodVideos200Response
-- | SearchFoodVideos200Response
-- 
data SearchFoodVideos200Response = SearchFoodVideos200Response
  { searchFoodVideos200ResponseVideos :: !([SearchFoodVideos200ResponseVideosInner]) -- ^ /Required/ "videos"
  , searchFoodVideos200ResponseTotalResults :: !(Int) -- ^ /Required/ "totalResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchFoodVideos200Response
instance A.FromJSON SearchFoodVideos200Response where
  parseJSON = A.withObject "SearchFoodVideos200Response" $ \o ->
    SearchFoodVideos200Response
      <$> (o .:  "videos")
      <*> (o .:  "totalResults")

-- | ToJSON SearchFoodVideos200Response
instance A.ToJSON SearchFoodVideos200Response where
  toJSON SearchFoodVideos200Response {..} =
   _omitNulls
      [ "videos" .= searchFoodVideos200ResponseVideos
      , "totalResults" .= searchFoodVideos200ResponseTotalResults
      ]


-- | Construct a value of type 'SearchFoodVideos200Response' (by applying it's required fields, if any)
mkSearchFoodVideos200Response
  :: [SearchFoodVideos200ResponseVideosInner] -- ^ 'searchFoodVideos200ResponseVideos' 
  -> Int -- ^ 'searchFoodVideos200ResponseTotalResults' 
  -> SearchFoodVideos200Response
mkSearchFoodVideos200Response searchFoodVideos200ResponseVideos searchFoodVideos200ResponseTotalResults =
  SearchFoodVideos200Response
  { searchFoodVideos200ResponseVideos
  , searchFoodVideos200ResponseTotalResults
  }

-- ** SearchFoodVideos200ResponseVideosInner
-- | SearchFoodVideos200ResponseVideosInner
data SearchFoodVideos200ResponseVideosInner = SearchFoodVideos200ResponseVideosInner
  { searchFoodVideos200ResponseVideosInnerTitle :: !(Text) -- ^ /Required/ "title"
  , searchFoodVideos200ResponseVideosInnerLength :: !(Int) -- ^ /Required/ "length"
  , searchFoodVideos200ResponseVideosInnerRating :: !(Double) -- ^ /Required/ "rating"
  , searchFoodVideos200ResponseVideosInnerShortTitle :: !(Text) -- ^ /Required/ "shortTitle"
  , searchFoodVideos200ResponseVideosInnerThumbnail :: !(Text) -- ^ /Required/ "thumbnail"
  , searchFoodVideos200ResponseVideosInnerViews :: !(Int) -- ^ /Required/ "views"
  , searchFoodVideos200ResponseVideosInnerYouTubeId :: !(Text) -- ^ /Required/ "youTubeId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchFoodVideos200ResponseVideosInner
instance A.FromJSON SearchFoodVideos200ResponseVideosInner where
  parseJSON = A.withObject "SearchFoodVideos200ResponseVideosInner" $ \o ->
    SearchFoodVideos200ResponseVideosInner
      <$> (o .:  "title")
      <*> (o .:  "length")
      <*> (o .:  "rating")
      <*> (o .:  "shortTitle")
      <*> (o .:  "thumbnail")
      <*> (o .:  "views")
      <*> (o .:  "youTubeId")

-- | ToJSON SearchFoodVideos200ResponseVideosInner
instance A.ToJSON SearchFoodVideos200ResponseVideosInner where
  toJSON SearchFoodVideos200ResponseVideosInner {..} =
   _omitNulls
      [ "title" .= searchFoodVideos200ResponseVideosInnerTitle
      , "length" .= searchFoodVideos200ResponseVideosInnerLength
      , "rating" .= searchFoodVideos200ResponseVideosInnerRating
      , "shortTitle" .= searchFoodVideos200ResponseVideosInnerShortTitle
      , "thumbnail" .= searchFoodVideos200ResponseVideosInnerThumbnail
      , "views" .= searchFoodVideos200ResponseVideosInnerViews
      , "youTubeId" .= searchFoodVideos200ResponseVideosInnerYouTubeId
      ]


-- | Construct a value of type 'SearchFoodVideos200ResponseVideosInner' (by applying it's required fields, if any)
mkSearchFoodVideos200ResponseVideosInner
  :: Text -- ^ 'searchFoodVideos200ResponseVideosInnerTitle' 
  -> Int -- ^ 'searchFoodVideos200ResponseVideosInnerLength' 
  -> Double -- ^ 'searchFoodVideos200ResponseVideosInnerRating' 
  -> Text -- ^ 'searchFoodVideos200ResponseVideosInnerShortTitle' 
  -> Text -- ^ 'searchFoodVideos200ResponseVideosInnerThumbnail' 
  -> Int -- ^ 'searchFoodVideos200ResponseVideosInnerViews' 
  -> Text -- ^ 'searchFoodVideos200ResponseVideosInnerYouTubeId' 
  -> SearchFoodVideos200ResponseVideosInner
mkSearchFoodVideos200ResponseVideosInner searchFoodVideos200ResponseVideosInnerTitle searchFoodVideos200ResponseVideosInnerLength searchFoodVideos200ResponseVideosInnerRating searchFoodVideos200ResponseVideosInnerShortTitle searchFoodVideos200ResponseVideosInnerThumbnail searchFoodVideos200ResponseVideosInnerViews searchFoodVideos200ResponseVideosInnerYouTubeId =
  SearchFoodVideos200ResponseVideosInner
  { searchFoodVideos200ResponseVideosInnerTitle
  , searchFoodVideos200ResponseVideosInnerLength
  , searchFoodVideos200ResponseVideosInnerRating
  , searchFoodVideos200ResponseVideosInnerShortTitle
  , searchFoodVideos200ResponseVideosInnerThumbnail
  , searchFoodVideos200ResponseVideosInnerViews
  , searchFoodVideos200ResponseVideosInnerYouTubeId
  }

-- ** SearchGroceryProducts200Response
-- | SearchGroceryProducts200Response
-- 
data SearchGroceryProducts200Response = SearchGroceryProducts200Response
  { searchGroceryProducts200ResponseProducts :: !([AutocompleteRecipeSearch200ResponseInner]) -- ^ /Required/ "products"
  , searchGroceryProducts200ResponseTotalProducts :: !(Int) -- ^ /Required/ "totalProducts"
  , searchGroceryProducts200ResponseType :: !(Text) -- ^ /Required/ "type"
  , searchGroceryProducts200ResponseOffset :: !(Int) -- ^ /Required/ "offset"
  , searchGroceryProducts200ResponseNumber :: !(Int) -- ^ /Required/ "number"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGroceryProducts200Response
instance A.FromJSON SearchGroceryProducts200Response where
  parseJSON = A.withObject "SearchGroceryProducts200Response" $ \o ->
    SearchGroceryProducts200Response
      <$> (o .:  "products")
      <*> (o .:  "totalProducts")
      <*> (o .:  "type")
      <*> (o .:  "offset")
      <*> (o .:  "number")

-- | ToJSON SearchGroceryProducts200Response
instance A.ToJSON SearchGroceryProducts200Response where
  toJSON SearchGroceryProducts200Response {..} =
   _omitNulls
      [ "products" .= searchGroceryProducts200ResponseProducts
      , "totalProducts" .= searchGroceryProducts200ResponseTotalProducts
      , "type" .= searchGroceryProducts200ResponseType
      , "offset" .= searchGroceryProducts200ResponseOffset
      , "number" .= searchGroceryProducts200ResponseNumber
      ]


-- | Construct a value of type 'SearchGroceryProducts200Response' (by applying it's required fields, if any)
mkSearchGroceryProducts200Response
  :: [AutocompleteRecipeSearch200ResponseInner] -- ^ 'searchGroceryProducts200ResponseProducts' 
  -> Int -- ^ 'searchGroceryProducts200ResponseTotalProducts' 
  -> Text -- ^ 'searchGroceryProducts200ResponseType' 
  -> Int -- ^ 'searchGroceryProducts200ResponseOffset' 
  -> Int -- ^ 'searchGroceryProducts200ResponseNumber' 
  -> SearchGroceryProducts200Response
mkSearchGroceryProducts200Response searchGroceryProducts200ResponseProducts searchGroceryProducts200ResponseTotalProducts searchGroceryProducts200ResponseType searchGroceryProducts200ResponseOffset searchGroceryProducts200ResponseNumber =
  SearchGroceryProducts200Response
  { searchGroceryProducts200ResponseProducts
  , searchGroceryProducts200ResponseTotalProducts
  , searchGroceryProducts200ResponseType
  , searchGroceryProducts200ResponseOffset
  , searchGroceryProducts200ResponseNumber
  }

-- ** SearchGroceryProductsByUPC200Response
-- | SearchGroceryProductsByUPC200Response
-- 
data SearchGroceryProductsByUPC200Response = SearchGroceryProductsByUPC200Response
  { searchGroceryProductsByUPC200ResponseId :: !(Int) -- ^ /Required/ "id"
  , searchGroceryProductsByUPC200ResponseTitle :: !(Text) -- ^ /Required/ "title"
  , searchGroceryProductsByUPC200ResponseBadges :: !([Text]) -- ^ /Required/ "badges"
  , searchGroceryProductsByUPC200ResponseImportantBadges :: !([Text]) -- ^ /Required/ "importantBadges"
  , searchGroceryProductsByUPC200ResponseBreadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , searchGroceryProductsByUPC200ResponseGeneratedText :: !(Text) -- ^ /Required/ "generatedText"
  , searchGroceryProductsByUPC200ResponseImageType :: !(Text) -- ^ /Required/ "imageType"
  , searchGroceryProductsByUPC200ResponseIngredientCount :: !(Maybe Int) -- ^ "ingredientCount"
  , searchGroceryProductsByUPC200ResponseIngredientList :: !(Text) -- ^ /Required/ "ingredientList"
  , searchGroceryProductsByUPC200ResponseIngredients :: !([SearchGroceryProductsByUPC200ResponseIngredientsInner]) -- ^ /Required/ "ingredients"
  , searchGroceryProductsByUPC200ResponseLikes :: !(Double) -- ^ /Required/ "likes"
  , searchGroceryProductsByUPC200ResponseNutrition :: !(SearchGroceryProductsByUPC200ResponseNutrition) -- ^ /Required/ "nutrition"
  , searchGroceryProductsByUPC200ResponsePrice :: !(Double) -- ^ /Required/ "price"
  , searchGroceryProductsByUPC200ResponseServings :: !(SearchGroceryProductsByUPC200ResponseServings) -- ^ /Required/ "servings"
  , searchGroceryProductsByUPC200ResponseSpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGroceryProductsByUPC200Response
instance A.FromJSON SearchGroceryProductsByUPC200Response where
  parseJSON = A.withObject "SearchGroceryProductsByUPC200Response" $ \o ->
    SearchGroceryProductsByUPC200Response
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "badges")
      <*> (o .:  "importantBadges")
      <*> (o .:  "breadcrumbs")
      <*> (o .:  "generatedText")
      <*> (o .:  "imageType")
      <*> (o .:? "ingredientCount")
      <*> (o .:  "ingredientList")
      <*> (o .:  "ingredients")
      <*> (o .:  "likes")
      <*> (o .:  "nutrition")
      <*> (o .:  "price")
      <*> (o .:  "servings")
      <*> (o .:  "spoonacularScore")

-- | ToJSON SearchGroceryProductsByUPC200Response
instance A.ToJSON SearchGroceryProductsByUPC200Response where
  toJSON SearchGroceryProductsByUPC200Response {..} =
   _omitNulls
      [ "id" .= searchGroceryProductsByUPC200ResponseId
      , "title" .= searchGroceryProductsByUPC200ResponseTitle
      , "badges" .= searchGroceryProductsByUPC200ResponseBadges
      , "importantBadges" .= searchGroceryProductsByUPC200ResponseImportantBadges
      , "breadcrumbs" .= searchGroceryProductsByUPC200ResponseBreadcrumbs
      , "generatedText" .= searchGroceryProductsByUPC200ResponseGeneratedText
      , "imageType" .= searchGroceryProductsByUPC200ResponseImageType
      , "ingredientCount" .= searchGroceryProductsByUPC200ResponseIngredientCount
      , "ingredientList" .= searchGroceryProductsByUPC200ResponseIngredientList
      , "ingredients" .= searchGroceryProductsByUPC200ResponseIngredients
      , "likes" .= searchGroceryProductsByUPC200ResponseLikes
      , "nutrition" .= searchGroceryProductsByUPC200ResponseNutrition
      , "price" .= searchGroceryProductsByUPC200ResponsePrice
      , "servings" .= searchGroceryProductsByUPC200ResponseServings
      , "spoonacularScore" .= searchGroceryProductsByUPC200ResponseSpoonacularScore
      ]


-- | Construct a value of type 'SearchGroceryProductsByUPC200Response' (by applying it's required fields, if any)
mkSearchGroceryProductsByUPC200Response
  :: Int -- ^ 'searchGroceryProductsByUPC200ResponseId' 
  -> Text -- ^ 'searchGroceryProductsByUPC200ResponseTitle' 
  -> [Text] -- ^ 'searchGroceryProductsByUPC200ResponseBadges' 
  -> [Text] -- ^ 'searchGroceryProductsByUPC200ResponseImportantBadges' 
  -> [Text] -- ^ 'searchGroceryProductsByUPC200ResponseBreadcrumbs' 
  -> Text -- ^ 'searchGroceryProductsByUPC200ResponseGeneratedText' 
  -> Text -- ^ 'searchGroceryProductsByUPC200ResponseImageType' 
  -> Text -- ^ 'searchGroceryProductsByUPC200ResponseIngredientList' 
  -> [SearchGroceryProductsByUPC200ResponseIngredientsInner] -- ^ 'searchGroceryProductsByUPC200ResponseIngredients' 
  -> Double -- ^ 'searchGroceryProductsByUPC200ResponseLikes' 
  -> SearchGroceryProductsByUPC200ResponseNutrition -- ^ 'searchGroceryProductsByUPC200ResponseNutrition' 
  -> Double -- ^ 'searchGroceryProductsByUPC200ResponsePrice' 
  -> SearchGroceryProductsByUPC200ResponseServings -- ^ 'searchGroceryProductsByUPC200ResponseServings' 
  -> Double -- ^ 'searchGroceryProductsByUPC200ResponseSpoonacularScore' 
  -> SearchGroceryProductsByUPC200Response
mkSearchGroceryProductsByUPC200Response searchGroceryProductsByUPC200ResponseId searchGroceryProductsByUPC200ResponseTitle searchGroceryProductsByUPC200ResponseBadges searchGroceryProductsByUPC200ResponseImportantBadges searchGroceryProductsByUPC200ResponseBreadcrumbs searchGroceryProductsByUPC200ResponseGeneratedText searchGroceryProductsByUPC200ResponseImageType searchGroceryProductsByUPC200ResponseIngredientList searchGroceryProductsByUPC200ResponseIngredients searchGroceryProductsByUPC200ResponseLikes searchGroceryProductsByUPC200ResponseNutrition searchGroceryProductsByUPC200ResponsePrice searchGroceryProductsByUPC200ResponseServings searchGroceryProductsByUPC200ResponseSpoonacularScore =
  SearchGroceryProductsByUPC200Response
  { searchGroceryProductsByUPC200ResponseId
  , searchGroceryProductsByUPC200ResponseTitle
  , searchGroceryProductsByUPC200ResponseBadges
  , searchGroceryProductsByUPC200ResponseImportantBadges
  , searchGroceryProductsByUPC200ResponseBreadcrumbs
  , searchGroceryProductsByUPC200ResponseGeneratedText
  , searchGroceryProductsByUPC200ResponseImageType
  , searchGroceryProductsByUPC200ResponseIngredientCount = Nothing
  , searchGroceryProductsByUPC200ResponseIngredientList
  , searchGroceryProductsByUPC200ResponseIngredients
  , searchGroceryProductsByUPC200ResponseLikes
  , searchGroceryProductsByUPC200ResponseNutrition
  , searchGroceryProductsByUPC200ResponsePrice
  , searchGroceryProductsByUPC200ResponseServings
  , searchGroceryProductsByUPC200ResponseSpoonacularScore
  }

-- ** SearchGroceryProductsByUPC200ResponseIngredientsInner
-- | SearchGroceryProductsByUPC200ResponseIngredientsInner
data SearchGroceryProductsByUPC200ResponseIngredientsInner = SearchGroceryProductsByUPC200ResponseIngredientsInner
  { searchGroceryProductsByUPC200ResponseIngredientsInnerDescription :: !(Maybe AnyType) -- ^ "description"
  , searchGroceryProductsByUPC200ResponseIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  , searchGroceryProductsByUPC200ResponseIngredientsInnerSafetyLevel :: !(Maybe AnyType) -- ^ "safety_level"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGroceryProductsByUPC200ResponseIngredientsInner
instance A.FromJSON SearchGroceryProductsByUPC200ResponseIngredientsInner where
  parseJSON = A.withObject "SearchGroceryProductsByUPC200ResponseIngredientsInner" $ \o ->
    SearchGroceryProductsByUPC200ResponseIngredientsInner
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "safety_level")

-- | ToJSON SearchGroceryProductsByUPC200ResponseIngredientsInner
instance A.ToJSON SearchGroceryProductsByUPC200ResponseIngredientsInner where
  toJSON SearchGroceryProductsByUPC200ResponseIngredientsInner {..} =
   _omitNulls
      [ "description" .= searchGroceryProductsByUPC200ResponseIngredientsInnerDescription
      , "name" .= searchGroceryProductsByUPC200ResponseIngredientsInnerName
      , "safety_level" .= searchGroceryProductsByUPC200ResponseIngredientsInnerSafetyLevel
      ]


-- | Construct a value of type 'SearchGroceryProductsByUPC200ResponseIngredientsInner' (by applying it's required fields, if any)
mkSearchGroceryProductsByUPC200ResponseIngredientsInner
  :: Text -- ^ 'searchGroceryProductsByUPC200ResponseIngredientsInnerName' 
  -> SearchGroceryProductsByUPC200ResponseIngredientsInner
mkSearchGroceryProductsByUPC200ResponseIngredientsInner searchGroceryProductsByUPC200ResponseIngredientsInnerName =
  SearchGroceryProductsByUPC200ResponseIngredientsInner
  { searchGroceryProductsByUPC200ResponseIngredientsInnerDescription = Nothing
  , searchGroceryProductsByUPC200ResponseIngredientsInnerName
  , searchGroceryProductsByUPC200ResponseIngredientsInnerSafetyLevel = Nothing
  }

-- ** SearchGroceryProductsByUPC200ResponseNutrition
-- | SearchGroceryProductsByUPC200ResponseNutrition
data SearchGroceryProductsByUPC200ResponseNutrition = SearchGroceryProductsByUPC200ResponseNutrition
  { searchGroceryProductsByUPC200ResponseNutritionNutrients :: !([ParseIngredients200ResponseInnerNutritionNutrientsInner]) -- ^ /Required/ "nutrients"
  , searchGroceryProductsByUPC200ResponseNutritionCaloricBreakdown :: !(ParseIngredients200ResponseInnerNutritionCaloricBreakdown) -- ^ /Required/ "caloricBreakdown"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGroceryProductsByUPC200ResponseNutrition
instance A.FromJSON SearchGroceryProductsByUPC200ResponseNutrition where
  parseJSON = A.withObject "SearchGroceryProductsByUPC200ResponseNutrition" $ \o ->
    SearchGroceryProductsByUPC200ResponseNutrition
      <$> (o .:  "nutrients")
      <*> (o .:  "caloricBreakdown")

-- | ToJSON SearchGroceryProductsByUPC200ResponseNutrition
instance A.ToJSON SearchGroceryProductsByUPC200ResponseNutrition where
  toJSON SearchGroceryProductsByUPC200ResponseNutrition {..} =
   _omitNulls
      [ "nutrients" .= searchGroceryProductsByUPC200ResponseNutritionNutrients
      , "caloricBreakdown" .= searchGroceryProductsByUPC200ResponseNutritionCaloricBreakdown
      ]


-- | Construct a value of type 'SearchGroceryProductsByUPC200ResponseNutrition' (by applying it's required fields, if any)
mkSearchGroceryProductsByUPC200ResponseNutrition
  :: [ParseIngredients200ResponseInnerNutritionNutrientsInner] -- ^ 'searchGroceryProductsByUPC200ResponseNutritionNutrients' 
  -> ParseIngredients200ResponseInnerNutritionCaloricBreakdown -- ^ 'searchGroceryProductsByUPC200ResponseNutritionCaloricBreakdown' 
  -> SearchGroceryProductsByUPC200ResponseNutrition
mkSearchGroceryProductsByUPC200ResponseNutrition searchGroceryProductsByUPC200ResponseNutritionNutrients searchGroceryProductsByUPC200ResponseNutritionCaloricBreakdown =
  SearchGroceryProductsByUPC200ResponseNutrition
  { searchGroceryProductsByUPC200ResponseNutritionNutrients
  , searchGroceryProductsByUPC200ResponseNutritionCaloricBreakdown
  }

-- ** SearchGroceryProductsByUPC200ResponseServings
-- | SearchGroceryProductsByUPC200ResponseServings
data SearchGroceryProductsByUPC200ResponseServings = SearchGroceryProductsByUPC200ResponseServings
  { searchGroceryProductsByUPC200ResponseServingsNumber :: !(Double) -- ^ /Required/ "number"
  , searchGroceryProductsByUPC200ResponseServingsSize :: !(Double) -- ^ /Required/ "size"
  , searchGroceryProductsByUPC200ResponseServingsUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGroceryProductsByUPC200ResponseServings
instance A.FromJSON SearchGroceryProductsByUPC200ResponseServings where
  parseJSON = A.withObject "SearchGroceryProductsByUPC200ResponseServings" $ \o ->
    SearchGroceryProductsByUPC200ResponseServings
      <$> (o .:  "number")
      <*> (o .:  "size")
      <*> (o .:  "unit")

-- | ToJSON SearchGroceryProductsByUPC200ResponseServings
instance A.ToJSON SearchGroceryProductsByUPC200ResponseServings where
  toJSON SearchGroceryProductsByUPC200ResponseServings {..} =
   _omitNulls
      [ "number" .= searchGroceryProductsByUPC200ResponseServingsNumber
      , "size" .= searchGroceryProductsByUPC200ResponseServingsSize
      , "unit" .= searchGroceryProductsByUPC200ResponseServingsUnit
      ]


-- | Construct a value of type 'SearchGroceryProductsByUPC200ResponseServings' (by applying it's required fields, if any)
mkSearchGroceryProductsByUPC200ResponseServings
  :: Double -- ^ 'searchGroceryProductsByUPC200ResponseServingsNumber' 
  -> Double -- ^ 'searchGroceryProductsByUPC200ResponseServingsSize' 
  -> Text -- ^ 'searchGroceryProductsByUPC200ResponseServingsUnit' 
  -> SearchGroceryProductsByUPC200ResponseServings
mkSearchGroceryProductsByUPC200ResponseServings searchGroceryProductsByUPC200ResponseServingsNumber searchGroceryProductsByUPC200ResponseServingsSize searchGroceryProductsByUPC200ResponseServingsUnit =
  SearchGroceryProductsByUPC200ResponseServings
  { searchGroceryProductsByUPC200ResponseServingsNumber
  , searchGroceryProductsByUPC200ResponseServingsSize
  , searchGroceryProductsByUPC200ResponseServingsUnit
  }

-- ** SearchMenuItems200Response
-- | SearchMenuItems200Response
-- 
data SearchMenuItems200Response = SearchMenuItems200Response
  { searchMenuItems200ResponseMenuItems :: !([SearchMenuItems200ResponseMenuItemsInner]) -- ^ /Required/ "menuItems"
  , searchMenuItems200ResponseTotalMenuItems :: !(Int) -- ^ /Required/ "totalMenuItems"
  , searchMenuItems200ResponseType :: !(Text) -- ^ /Required/ "type"
  , searchMenuItems200ResponseOffset :: !(Int) -- ^ /Required/ "offset"
  , searchMenuItems200ResponseNumber :: !(Int) -- ^ /Required/ "number"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMenuItems200Response
instance A.FromJSON SearchMenuItems200Response where
  parseJSON = A.withObject "SearchMenuItems200Response" $ \o ->
    SearchMenuItems200Response
      <$> (o .:  "menuItems")
      <*> (o .:  "totalMenuItems")
      <*> (o .:  "type")
      <*> (o .:  "offset")
      <*> (o .:  "number")

-- | ToJSON SearchMenuItems200Response
instance A.ToJSON SearchMenuItems200Response where
  toJSON SearchMenuItems200Response {..} =
   _omitNulls
      [ "menuItems" .= searchMenuItems200ResponseMenuItems
      , "totalMenuItems" .= searchMenuItems200ResponseTotalMenuItems
      , "type" .= searchMenuItems200ResponseType
      , "offset" .= searchMenuItems200ResponseOffset
      , "number" .= searchMenuItems200ResponseNumber
      ]


-- | Construct a value of type 'SearchMenuItems200Response' (by applying it's required fields, if any)
mkSearchMenuItems200Response
  :: [SearchMenuItems200ResponseMenuItemsInner] -- ^ 'searchMenuItems200ResponseMenuItems' 
  -> Int -- ^ 'searchMenuItems200ResponseTotalMenuItems' 
  -> Text -- ^ 'searchMenuItems200ResponseType' 
  -> Int -- ^ 'searchMenuItems200ResponseOffset' 
  -> Int -- ^ 'searchMenuItems200ResponseNumber' 
  -> SearchMenuItems200Response
mkSearchMenuItems200Response searchMenuItems200ResponseMenuItems searchMenuItems200ResponseTotalMenuItems searchMenuItems200ResponseType searchMenuItems200ResponseOffset searchMenuItems200ResponseNumber =
  SearchMenuItems200Response
  { searchMenuItems200ResponseMenuItems
  , searchMenuItems200ResponseTotalMenuItems
  , searchMenuItems200ResponseType
  , searchMenuItems200ResponseOffset
  , searchMenuItems200ResponseNumber
  }

-- ** SearchMenuItems200ResponseMenuItemsInner
-- | SearchMenuItems200ResponseMenuItemsInner
data SearchMenuItems200ResponseMenuItemsInner = SearchMenuItems200ResponseMenuItemsInner
  { searchMenuItems200ResponseMenuItemsInnerId :: !(Int) -- ^ /Required/ "id"
  , searchMenuItems200ResponseMenuItemsInnerTitle :: !(Text) -- ^ /Required/ "title"
  , searchMenuItems200ResponseMenuItemsInnerRestaurantChain :: !(Text) -- ^ /Required/ "restaurantChain"
  , searchMenuItems200ResponseMenuItemsInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchMenuItems200ResponseMenuItemsInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , searchMenuItems200ResponseMenuItemsInnerServings :: !(Maybe SearchGroceryProductsByUPC200ResponseServings) -- ^ "servings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMenuItems200ResponseMenuItemsInner
instance A.FromJSON SearchMenuItems200ResponseMenuItemsInner where
  parseJSON = A.withObject "SearchMenuItems200ResponseMenuItemsInner" $ \o ->
    SearchMenuItems200ResponseMenuItemsInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "restaurantChain")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:? "servings")

-- | ToJSON SearchMenuItems200ResponseMenuItemsInner
instance A.ToJSON SearchMenuItems200ResponseMenuItemsInner where
  toJSON SearchMenuItems200ResponseMenuItemsInner {..} =
   _omitNulls
      [ "id" .= searchMenuItems200ResponseMenuItemsInnerId
      , "title" .= searchMenuItems200ResponseMenuItemsInnerTitle
      , "restaurantChain" .= searchMenuItems200ResponseMenuItemsInnerRestaurantChain
      , "image" .= searchMenuItems200ResponseMenuItemsInnerImage
      , "imageType" .= searchMenuItems200ResponseMenuItemsInnerImageType
      , "servings" .= searchMenuItems200ResponseMenuItemsInnerServings
      ]


-- | Construct a value of type 'SearchMenuItems200ResponseMenuItemsInner' (by applying it's required fields, if any)
mkSearchMenuItems200ResponseMenuItemsInner
  :: Int -- ^ 'searchMenuItems200ResponseMenuItemsInnerId' 
  -> Text -- ^ 'searchMenuItems200ResponseMenuItemsInnerTitle' 
  -> Text -- ^ 'searchMenuItems200ResponseMenuItemsInnerRestaurantChain' 
  -> Text -- ^ 'searchMenuItems200ResponseMenuItemsInnerImage' 
  -> Text -- ^ 'searchMenuItems200ResponseMenuItemsInnerImageType' 
  -> SearchMenuItems200ResponseMenuItemsInner
mkSearchMenuItems200ResponseMenuItemsInner searchMenuItems200ResponseMenuItemsInnerId searchMenuItems200ResponseMenuItemsInnerTitle searchMenuItems200ResponseMenuItemsInnerRestaurantChain searchMenuItems200ResponseMenuItemsInnerImage searchMenuItems200ResponseMenuItemsInnerImageType =
  SearchMenuItems200ResponseMenuItemsInner
  { searchMenuItems200ResponseMenuItemsInnerId
  , searchMenuItems200ResponseMenuItemsInnerTitle
  , searchMenuItems200ResponseMenuItemsInnerRestaurantChain
  , searchMenuItems200ResponseMenuItemsInnerImage
  , searchMenuItems200ResponseMenuItemsInnerImageType
  , searchMenuItems200ResponseMenuItemsInnerServings = Nothing
  }

-- ** SearchRecipes200Response
-- | SearchRecipes200Response
-- 
data SearchRecipes200Response = SearchRecipes200Response
  { searchRecipes200ResponseOffset :: !(Int) -- ^ /Required/ "offset"
  , searchRecipes200ResponseNumber :: !(Int) -- ^ /Required/ "number"
  , searchRecipes200ResponseResults :: !([SearchRecipes200ResponseResultsInner]) -- ^ /Required/ "results"
  , searchRecipes200ResponseTotalResults :: !(Int) -- ^ /Required/ "totalResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipes200Response
instance A.FromJSON SearchRecipes200Response where
  parseJSON = A.withObject "SearchRecipes200Response" $ \o ->
    SearchRecipes200Response
      <$> (o .:  "offset")
      <*> (o .:  "number")
      <*> (o .:  "results")
      <*> (o .:  "totalResults")

-- | ToJSON SearchRecipes200Response
instance A.ToJSON SearchRecipes200Response where
  toJSON SearchRecipes200Response {..} =
   _omitNulls
      [ "offset" .= searchRecipes200ResponseOffset
      , "number" .= searchRecipes200ResponseNumber
      , "results" .= searchRecipes200ResponseResults
      , "totalResults" .= searchRecipes200ResponseTotalResults
      ]


-- | Construct a value of type 'SearchRecipes200Response' (by applying it's required fields, if any)
mkSearchRecipes200Response
  :: Int -- ^ 'searchRecipes200ResponseOffset' 
  -> Int -- ^ 'searchRecipes200ResponseNumber' 
  -> [SearchRecipes200ResponseResultsInner] -- ^ 'searchRecipes200ResponseResults' 
  -> Int -- ^ 'searchRecipes200ResponseTotalResults' 
  -> SearchRecipes200Response
mkSearchRecipes200Response searchRecipes200ResponseOffset searchRecipes200ResponseNumber searchRecipes200ResponseResults searchRecipes200ResponseTotalResults =
  SearchRecipes200Response
  { searchRecipes200ResponseOffset
  , searchRecipes200ResponseNumber
  , searchRecipes200ResponseResults
  , searchRecipes200ResponseTotalResults
  }

-- ** SearchRecipes200ResponseResultsInner
-- | SearchRecipes200ResponseResultsInner
data SearchRecipes200ResponseResultsInner = SearchRecipes200ResponseResultsInner
  { searchRecipes200ResponseResultsInnerId :: !(Int) -- ^ /Required/ "id"
  , searchRecipes200ResponseResultsInnerTitle :: !(Text) -- ^ /Required/ "title"
  , searchRecipes200ResponseResultsInnerCalories :: !(Double) -- ^ /Required/ "calories"
  , searchRecipes200ResponseResultsInnerCarbs :: !(Text) -- ^ /Required/ "carbs"
  , searchRecipes200ResponseResultsInnerFat :: !(Text) -- ^ /Required/ "fat"
  , searchRecipes200ResponseResultsInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchRecipes200ResponseResultsInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , searchRecipes200ResponseResultsInnerProtein :: !(Text) -- ^ /Required/ "protein"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipes200ResponseResultsInner
instance A.FromJSON SearchRecipes200ResponseResultsInner where
  parseJSON = A.withObject "SearchRecipes200ResponseResultsInner" $ \o ->
    SearchRecipes200ResponseResultsInner
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "protein")

-- | ToJSON SearchRecipes200ResponseResultsInner
instance A.ToJSON SearchRecipes200ResponseResultsInner where
  toJSON SearchRecipes200ResponseResultsInner {..} =
   _omitNulls
      [ "id" .= searchRecipes200ResponseResultsInnerId
      , "title" .= searchRecipes200ResponseResultsInnerTitle
      , "calories" .= searchRecipes200ResponseResultsInnerCalories
      , "carbs" .= searchRecipes200ResponseResultsInnerCarbs
      , "fat" .= searchRecipes200ResponseResultsInnerFat
      , "image" .= searchRecipes200ResponseResultsInnerImage
      , "imageType" .= searchRecipes200ResponseResultsInnerImageType
      , "protein" .= searchRecipes200ResponseResultsInnerProtein
      ]


-- | Construct a value of type 'SearchRecipes200ResponseResultsInner' (by applying it's required fields, if any)
mkSearchRecipes200ResponseResultsInner
  :: Int -- ^ 'searchRecipes200ResponseResultsInnerId' 
  -> Text -- ^ 'searchRecipes200ResponseResultsInnerTitle' 
  -> Double -- ^ 'searchRecipes200ResponseResultsInnerCalories' 
  -> Text -- ^ 'searchRecipes200ResponseResultsInnerCarbs' 
  -> Text -- ^ 'searchRecipes200ResponseResultsInnerFat' 
  -> Text -- ^ 'searchRecipes200ResponseResultsInnerImage' 
  -> Text -- ^ 'searchRecipes200ResponseResultsInnerImageType' 
  -> Text -- ^ 'searchRecipes200ResponseResultsInnerProtein' 
  -> SearchRecipes200ResponseResultsInner
mkSearchRecipes200ResponseResultsInner searchRecipes200ResponseResultsInnerId searchRecipes200ResponseResultsInnerTitle searchRecipes200ResponseResultsInnerCalories searchRecipes200ResponseResultsInnerCarbs searchRecipes200ResponseResultsInnerFat searchRecipes200ResponseResultsInnerImage searchRecipes200ResponseResultsInnerImageType searchRecipes200ResponseResultsInnerProtein =
  SearchRecipes200ResponseResultsInner
  { searchRecipes200ResponseResultsInnerId
  , searchRecipes200ResponseResultsInnerTitle
  , searchRecipes200ResponseResultsInnerCalories
  , searchRecipes200ResponseResultsInnerCarbs
  , searchRecipes200ResponseResultsInnerFat
  , searchRecipes200ResponseResultsInnerImage
  , searchRecipes200ResponseResultsInnerImageType
  , searchRecipes200ResponseResultsInnerProtein
  }

-- ** SearchRecipesByIngredients200ResponseInner
-- | SearchRecipesByIngredients200ResponseInner
data SearchRecipesByIngredients200ResponseInner = SearchRecipesByIngredients200ResponseInner
  { searchRecipesByIngredients200ResponseInnerId :: !(Int) -- ^ /Required/ "id"
  , searchRecipesByIngredients200ResponseInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchRecipesByIngredients200ResponseInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , searchRecipesByIngredients200ResponseInnerLikes :: !(Int) -- ^ /Required/ "likes"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientCount :: !(Int) -- ^ /Required/ "missedIngredientCount"
  , searchRecipesByIngredients200ResponseInnerMissedIngredients :: !([SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner]) -- ^ /Required/ "missedIngredients"
  , searchRecipesByIngredients200ResponseInnerTitle :: !(Text) -- ^ /Required/ "title"
  , searchRecipesByIngredients200ResponseInnerUnusedIngredients :: !([A.Value]) -- ^ /Required/ "unusedIngredients"
  , searchRecipesByIngredients200ResponseInnerUsedIngredientCount :: !(Double) -- ^ /Required/ "usedIngredientCount"
  , searchRecipesByIngredients200ResponseInnerUsedIngredients :: !([SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner]) -- ^ /Required/ "usedIngredients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipesByIngredients200ResponseInner
instance A.FromJSON SearchRecipesByIngredients200ResponseInner where
  parseJSON = A.withObject "SearchRecipesByIngredients200ResponseInner" $ \o ->
    SearchRecipesByIngredients200ResponseInner
      <$> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "likes")
      <*> (o .:  "missedIngredientCount")
      <*> (o .:  "missedIngredients")
      <*> (o .:  "title")
      <*> (o .:  "unusedIngredients")
      <*> (o .:  "usedIngredientCount")
      <*> (o .:  "usedIngredients")

-- | ToJSON SearchRecipesByIngredients200ResponseInner
instance A.ToJSON SearchRecipesByIngredients200ResponseInner where
  toJSON SearchRecipesByIngredients200ResponseInner {..} =
   _omitNulls
      [ "id" .= searchRecipesByIngredients200ResponseInnerId
      , "image" .= searchRecipesByIngredients200ResponseInnerImage
      , "imageType" .= searchRecipesByIngredients200ResponseInnerImageType
      , "likes" .= searchRecipesByIngredients200ResponseInnerLikes
      , "missedIngredientCount" .= searchRecipesByIngredients200ResponseInnerMissedIngredientCount
      , "missedIngredients" .= searchRecipesByIngredients200ResponseInnerMissedIngredients
      , "title" .= searchRecipesByIngredients200ResponseInnerTitle
      , "unusedIngredients" .= searchRecipesByIngredients200ResponseInnerUnusedIngredients
      , "usedIngredientCount" .= searchRecipesByIngredients200ResponseInnerUsedIngredientCount
      , "usedIngredients" .= searchRecipesByIngredients200ResponseInnerUsedIngredients
      ]


-- | Construct a value of type 'SearchRecipesByIngredients200ResponseInner' (by applying it's required fields, if any)
mkSearchRecipesByIngredients200ResponseInner
  :: Int -- ^ 'searchRecipesByIngredients200ResponseInnerId' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerImage' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerImageType' 
  -> Int -- ^ 'searchRecipesByIngredients200ResponseInnerLikes' 
  -> Int -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientCount' 
  -> [SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner] -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredients' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerTitle' 
  -> [A.Value] -- ^ 'searchRecipesByIngredients200ResponseInnerUnusedIngredients' 
  -> Double -- ^ 'searchRecipesByIngredients200ResponseInnerUsedIngredientCount' 
  -> [SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner] -- ^ 'searchRecipesByIngredients200ResponseInnerUsedIngredients' 
  -> SearchRecipesByIngredients200ResponseInner
mkSearchRecipesByIngredients200ResponseInner searchRecipesByIngredients200ResponseInnerId searchRecipesByIngredients200ResponseInnerImage searchRecipesByIngredients200ResponseInnerImageType searchRecipesByIngredients200ResponseInnerLikes searchRecipesByIngredients200ResponseInnerMissedIngredientCount searchRecipesByIngredients200ResponseInnerMissedIngredients searchRecipesByIngredients200ResponseInnerTitle searchRecipesByIngredients200ResponseInnerUnusedIngredients searchRecipesByIngredients200ResponseInnerUsedIngredientCount searchRecipesByIngredients200ResponseInnerUsedIngredients =
  SearchRecipesByIngredients200ResponseInner
  { searchRecipesByIngredients200ResponseInnerId
  , searchRecipesByIngredients200ResponseInnerImage
  , searchRecipesByIngredients200ResponseInnerImageType
  , searchRecipesByIngredients200ResponseInnerLikes
  , searchRecipesByIngredients200ResponseInnerMissedIngredientCount
  , searchRecipesByIngredients200ResponseInnerMissedIngredients
  , searchRecipesByIngredients200ResponseInnerTitle
  , searchRecipesByIngredients200ResponseInnerUnusedIngredients
  , searchRecipesByIngredients200ResponseInnerUsedIngredientCount
  , searchRecipesByIngredients200ResponseInnerUsedIngredients
  }

-- ** SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
-- | SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
data SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner = SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
  { searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAisle :: !(Text) -- ^ /Required/ "aisle"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAmount :: !(Double) -- ^ /Required/ "amount"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerId :: !(Int) -- ^ /Required/ "id"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerMeta :: !(Maybe [Text]) -- ^ "meta"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerName :: !(Text) -- ^ /Required/ "name"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginal :: !(Text) -- ^ /Required/ "original"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginalName :: !(Text) -- ^ /Required/ "originalName"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnit :: !(Text) -- ^ /Required/ "unit"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitShort :: !(Text) -- ^ /Required/ "unitShort"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
instance A.FromJSON SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner where
  parseJSON = A.withObject "SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner" $ \o ->
    SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
      <$> (o .:  "aisle")
      <*> (o .:  "amount")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:? "meta")
      <*> (o .:  "name")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "unit")
      <*> (o .:  "unitLong")
      <*> (o .:  "unitShort")

-- | ToJSON SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
instance A.ToJSON SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner where
  toJSON SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner {..} =
   _omitNulls
      [ "aisle" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAisle
      , "amount" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAmount
      , "id" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerId
      , "image" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerImage
      , "meta" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerMeta
      , "name" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerName
      , "original" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginal
      , "originalName" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginalName
      , "unit" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnit
      , "unitLong" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitLong
      , "unitShort" .= searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitShort
      ]


-- | Construct a value of type 'SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner' (by applying it's required fields, if any)
mkSearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
  :: Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAisle' 
  -> Double -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAmount' 
  -> Int -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerId' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerImage' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerName' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginal' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginalName' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnit' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitLong' 
  -> Text -- ^ 'searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitShort' 
  -> SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
mkSearchRecipesByIngredients200ResponseInnerMissedIngredientsInner searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAisle searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAmount searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerId searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerImage searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerName searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginal searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginalName searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnit searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitLong searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitShort =
  SearchRecipesByIngredients200ResponseInnerMissedIngredientsInner
  { searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAisle
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerAmount
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerId
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerImage
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerMeta = Nothing
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerName
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginal
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerOriginalName
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnit
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitLong
  , searchRecipesByIngredients200ResponseInnerMissedIngredientsInnerUnitShort
  }

-- ** SearchRecipesByNutrients200ResponseInner
-- | SearchRecipesByNutrients200ResponseInner
data SearchRecipesByNutrients200ResponseInner = SearchRecipesByNutrients200ResponseInner
  { searchRecipesByNutrients200ResponseInnerCalories :: !(Double) -- ^ /Required/ "calories"
  , searchRecipesByNutrients200ResponseInnerCarbs :: !(Text) -- ^ /Required/ "carbs"
  , searchRecipesByNutrients200ResponseInnerFat :: !(Text) -- ^ /Required/ "fat"
  , searchRecipesByNutrients200ResponseInnerId :: !(Int) -- ^ /Required/ "id"
  , searchRecipesByNutrients200ResponseInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchRecipesByNutrients200ResponseInnerImageType :: !(Text) -- ^ /Required/ "imageType"
  , searchRecipesByNutrients200ResponseInnerProtein :: !(Text) -- ^ /Required/ "protein"
  , searchRecipesByNutrients200ResponseInnerTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchRecipesByNutrients200ResponseInner
instance A.FromJSON SearchRecipesByNutrients200ResponseInner where
  parseJSON = A.withObject "SearchRecipesByNutrients200ResponseInner" $ \o ->
    SearchRecipesByNutrients200ResponseInner
      <$> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "protein")
      <*> (o .:  "title")

-- | ToJSON SearchRecipesByNutrients200ResponseInner
instance A.ToJSON SearchRecipesByNutrients200ResponseInner where
  toJSON SearchRecipesByNutrients200ResponseInner {..} =
   _omitNulls
      [ "calories" .= searchRecipesByNutrients200ResponseInnerCalories
      , "carbs" .= searchRecipesByNutrients200ResponseInnerCarbs
      , "fat" .= searchRecipesByNutrients200ResponseInnerFat
      , "id" .= searchRecipesByNutrients200ResponseInnerId
      , "image" .= searchRecipesByNutrients200ResponseInnerImage
      , "imageType" .= searchRecipesByNutrients200ResponseInnerImageType
      , "protein" .= searchRecipesByNutrients200ResponseInnerProtein
      , "title" .= searchRecipesByNutrients200ResponseInnerTitle
      ]


-- | Construct a value of type 'SearchRecipesByNutrients200ResponseInner' (by applying it's required fields, if any)
mkSearchRecipesByNutrients200ResponseInner
  :: Double -- ^ 'searchRecipesByNutrients200ResponseInnerCalories' 
  -> Text -- ^ 'searchRecipesByNutrients200ResponseInnerCarbs' 
  -> Text -- ^ 'searchRecipesByNutrients200ResponseInnerFat' 
  -> Int -- ^ 'searchRecipesByNutrients200ResponseInnerId' 
  -> Text -- ^ 'searchRecipesByNutrients200ResponseInnerImage' 
  -> Text -- ^ 'searchRecipesByNutrients200ResponseInnerImageType' 
  -> Text -- ^ 'searchRecipesByNutrients200ResponseInnerProtein' 
  -> Text -- ^ 'searchRecipesByNutrients200ResponseInnerTitle' 
  -> SearchRecipesByNutrients200ResponseInner
mkSearchRecipesByNutrients200ResponseInner searchRecipesByNutrients200ResponseInnerCalories searchRecipesByNutrients200ResponseInnerCarbs searchRecipesByNutrients200ResponseInnerFat searchRecipesByNutrients200ResponseInnerId searchRecipesByNutrients200ResponseInnerImage searchRecipesByNutrients200ResponseInnerImageType searchRecipesByNutrients200ResponseInnerProtein searchRecipesByNutrients200ResponseInnerTitle =
  SearchRecipesByNutrients200ResponseInner
  { searchRecipesByNutrients200ResponseInnerCalories
  , searchRecipesByNutrients200ResponseInnerCarbs
  , searchRecipesByNutrients200ResponseInnerFat
  , searchRecipesByNutrients200ResponseInnerId
  , searchRecipesByNutrients200ResponseInnerImage
  , searchRecipesByNutrients200ResponseInnerImageType
  , searchRecipesByNutrients200ResponseInnerProtein
  , searchRecipesByNutrients200ResponseInnerTitle
  }

-- ** SearchSiteContent200Response
-- | SearchSiteContent200Response
-- 
data SearchSiteContent200Response = SearchSiteContent200Response
  { searchSiteContent200ResponseArticles :: !([SearchSiteContent200ResponseArticlesInner]) -- ^ /Required/ "Articles"
  , searchSiteContent200ResponseGroceryProducts :: !([SearchSiteContent200ResponseGroceryProductsInner]) -- ^ /Required/ "Grocery Products"
  , searchSiteContent200ResponseMenuItems :: !([SearchSiteContent200ResponseGroceryProductsInner]) -- ^ /Required/ "Menu Items"
  , searchSiteContent200ResponseRecipes :: !([SearchSiteContent200ResponseGroceryProductsInner]) -- ^ /Required/ "Recipes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchSiteContent200Response
instance A.FromJSON SearchSiteContent200Response where
  parseJSON = A.withObject "SearchSiteContent200Response" $ \o ->
    SearchSiteContent200Response
      <$> (o .:  "Articles")
      <*> (o .:  "Grocery Products")
      <*> (o .:  "Menu Items")
      <*> (o .:  "Recipes")

-- | ToJSON SearchSiteContent200Response
instance A.ToJSON SearchSiteContent200Response where
  toJSON SearchSiteContent200Response {..} =
   _omitNulls
      [ "Articles" .= searchSiteContent200ResponseArticles
      , "Grocery Products" .= searchSiteContent200ResponseGroceryProducts
      , "Menu Items" .= searchSiteContent200ResponseMenuItems
      , "Recipes" .= searchSiteContent200ResponseRecipes
      ]


-- | Construct a value of type 'SearchSiteContent200Response' (by applying it's required fields, if any)
mkSearchSiteContent200Response
  :: [SearchSiteContent200ResponseArticlesInner] -- ^ 'searchSiteContent200ResponseArticles' 
  -> [SearchSiteContent200ResponseGroceryProductsInner] -- ^ 'searchSiteContent200ResponseGroceryProducts' 
  -> [SearchSiteContent200ResponseGroceryProductsInner] -- ^ 'searchSiteContent200ResponseMenuItems' 
  -> [SearchSiteContent200ResponseGroceryProductsInner] -- ^ 'searchSiteContent200ResponseRecipes' 
  -> SearchSiteContent200Response
mkSearchSiteContent200Response searchSiteContent200ResponseArticles searchSiteContent200ResponseGroceryProducts searchSiteContent200ResponseMenuItems searchSiteContent200ResponseRecipes =
  SearchSiteContent200Response
  { searchSiteContent200ResponseArticles
  , searchSiteContent200ResponseGroceryProducts
  , searchSiteContent200ResponseMenuItems
  , searchSiteContent200ResponseRecipes
  }

-- ** SearchSiteContent200ResponseArticlesInner
-- | SearchSiteContent200ResponseArticlesInner
data SearchSiteContent200ResponseArticlesInner = SearchSiteContent200ResponseArticlesInner
  { searchSiteContent200ResponseArticlesInnerDataPoints :: !(Maybe [AnyType]) -- ^ "dataPoints"
  , searchSiteContent200ResponseArticlesInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchSiteContent200ResponseArticlesInnerLink :: !(Text) -- ^ /Required/ "link"
  , searchSiteContent200ResponseArticlesInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchSiteContent200ResponseArticlesInner
instance A.FromJSON SearchSiteContent200ResponseArticlesInner where
  parseJSON = A.withObject "SearchSiteContent200ResponseArticlesInner" $ \o ->
    SearchSiteContent200ResponseArticlesInner
      <$> (o .:? "dataPoints")
      <*> (o .:  "image")
      <*> (o .:  "link")
      <*> (o .:  "name")

-- | ToJSON SearchSiteContent200ResponseArticlesInner
instance A.ToJSON SearchSiteContent200ResponseArticlesInner where
  toJSON SearchSiteContent200ResponseArticlesInner {..} =
   _omitNulls
      [ "dataPoints" .= searchSiteContent200ResponseArticlesInnerDataPoints
      , "image" .= searchSiteContent200ResponseArticlesInnerImage
      , "link" .= searchSiteContent200ResponseArticlesInnerLink
      , "name" .= searchSiteContent200ResponseArticlesInnerName
      ]


-- | Construct a value of type 'SearchSiteContent200ResponseArticlesInner' (by applying it's required fields, if any)
mkSearchSiteContent200ResponseArticlesInner
  :: Text -- ^ 'searchSiteContent200ResponseArticlesInnerImage' 
  -> Text -- ^ 'searchSiteContent200ResponseArticlesInnerLink' 
  -> Text -- ^ 'searchSiteContent200ResponseArticlesInnerName' 
  -> SearchSiteContent200ResponseArticlesInner
mkSearchSiteContent200ResponseArticlesInner searchSiteContent200ResponseArticlesInnerImage searchSiteContent200ResponseArticlesInnerLink searchSiteContent200ResponseArticlesInnerName =
  SearchSiteContent200ResponseArticlesInner
  { searchSiteContent200ResponseArticlesInnerDataPoints = Nothing
  , searchSiteContent200ResponseArticlesInnerImage
  , searchSiteContent200ResponseArticlesInnerLink
  , searchSiteContent200ResponseArticlesInnerName
  }

-- ** SearchSiteContent200ResponseGroceryProductsInner
-- | SearchSiteContent200ResponseGroceryProductsInner
data SearchSiteContent200ResponseGroceryProductsInner = SearchSiteContent200ResponseGroceryProductsInner
  { searchSiteContent200ResponseGroceryProductsInnerDataPoints :: !(Maybe [SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner]) -- ^ "dataPoints"
  , searchSiteContent200ResponseGroceryProductsInnerImage :: !(Text) -- ^ /Required/ "image"
  , searchSiteContent200ResponseGroceryProductsInnerLink :: !(Text) -- ^ /Required/ "link"
  , searchSiteContent200ResponseGroceryProductsInnerName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchSiteContent200ResponseGroceryProductsInner
instance A.FromJSON SearchSiteContent200ResponseGroceryProductsInner where
  parseJSON = A.withObject "SearchSiteContent200ResponseGroceryProductsInner" $ \o ->
    SearchSiteContent200ResponseGroceryProductsInner
      <$> (o .:? "dataPoints")
      <*> (o .:  "image")
      <*> (o .:  "link")
      <*> (o .:  "name")

-- | ToJSON SearchSiteContent200ResponseGroceryProductsInner
instance A.ToJSON SearchSiteContent200ResponseGroceryProductsInner where
  toJSON SearchSiteContent200ResponseGroceryProductsInner {..} =
   _omitNulls
      [ "dataPoints" .= searchSiteContent200ResponseGroceryProductsInnerDataPoints
      , "image" .= searchSiteContent200ResponseGroceryProductsInnerImage
      , "link" .= searchSiteContent200ResponseGroceryProductsInnerLink
      , "name" .= searchSiteContent200ResponseGroceryProductsInnerName
      ]


-- | Construct a value of type 'SearchSiteContent200ResponseGroceryProductsInner' (by applying it's required fields, if any)
mkSearchSiteContent200ResponseGroceryProductsInner
  :: Text -- ^ 'searchSiteContent200ResponseGroceryProductsInnerImage' 
  -> Text -- ^ 'searchSiteContent200ResponseGroceryProductsInnerLink' 
  -> Text -- ^ 'searchSiteContent200ResponseGroceryProductsInnerName' 
  -> SearchSiteContent200ResponseGroceryProductsInner
mkSearchSiteContent200ResponseGroceryProductsInner searchSiteContent200ResponseGroceryProductsInnerImage searchSiteContent200ResponseGroceryProductsInnerLink searchSiteContent200ResponseGroceryProductsInnerName =
  SearchSiteContent200ResponseGroceryProductsInner
  { searchSiteContent200ResponseGroceryProductsInnerDataPoints = Nothing
  , searchSiteContent200ResponseGroceryProductsInnerImage
  , searchSiteContent200ResponseGroceryProductsInnerLink
  , searchSiteContent200ResponseGroceryProductsInnerName
  }

-- ** SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
-- | SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
data SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner = SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
  { searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerKey :: !(Text) -- ^ /Required/ "key"
  , searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerValue :: !(Text) -- ^ /Required/ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
instance A.FromJSON SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner where
  parseJSON = A.withObject "SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner" $ \o ->
    SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
      <$> (o .:  "key")
      <*> (o .:  "value")

-- | ToJSON SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
instance A.ToJSON SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner where
  toJSON SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner {..} =
   _omitNulls
      [ "key" .= searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerKey
      , "value" .= searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerValue
      ]


-- | Construct a value of type 'SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner' (by applying it's required fields, if any)
mkSearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
  :: Text -- ^ 'searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerKey' 
  -> Text -- ^ 'searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerValue' 
  -> SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
mkSearchSiteContent200ResponseGroceryProductsInnerDataPointsInner searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerKey searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerValue =
  SearchSiteContent200ResponseGroceryProductsInnerDataPointsInner
  { searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerKey
  , searchSiteContent200ResponseGroceryProductsInnerDataPointsInnerValue
  }

-- ** SummarizeRecipe200Response
-- | SummarizeRecipe200Response
-- 
data SummarizeRecipe200Response = SummarizeRecipe200Response
  { summarizeRecipe200ResponseId :: !(Int) -- ^ /Required/ "id"
  , summarizeRecipe200ResponseSummary :: !(Text) -- ^ /Required/ "summary"
  , summarizeRecipe200ResponseTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SummarizeRecipe200Response
instance A.FromJSON SummarizeRecipe200Response where
  parseJSON = A.withObject "SummarizeRecipe200Response" $ \o ->
    SummarizeRecipe200Response
      <$> (o .:  "id")
      <*> (o .:  "summary")
      <*> (o .:  "title")

-- | ToJSON SummarizeRecipe200Response
instance A.ToJSON SummarizeRecipe200Response where
  toJSON SummarizeRecipe200Response {..} =
   _omitNulls
      [ "id" .= summarizeRecipe200ResponseId
      , "summary" .= summarizeRecipe200ResponseSummary
      , "title" .= summarizeRecipe200ResponseTitle
      ]


-- | Construct a value of type 'SummarizeRecipe200Response' (by applying it's required fields, if any)
mkSummarizeRecipe200Response
  :: Int -- ^ 'summarizeRecipe200ResponseId' 
  -> Text -- ^ 'summarizeRecipe200ResponseSummary' 
  -> Text -- ^ 'summarizeRecipe200ResponseTitle' 
  -> SummarizeRecipe200Response
mkSummarizeRecipe200Response summarizeRecipe200ResponseId summarizeRecipe200ResponseSummary summarizeRecipe200ResponseTitle =
  SummarizeRecipe200Response
  { summarizeRecipe200ResponseId
  , summarizeRecipe200ResponseSummary
  , summarizeRecipe200ResponseTitle
  }

-- ** TalkToChatbot200Response
-- | TalkToChatbot200Response
-- 
data TalkToChatbot200Response = TalkToChatbot200Response
  { talkToChatbot200ResponseAnswerText :: !(Text) -- ^ /Required/ "answerText"
  , talkToChatbot200ResponseMedia :: !([AnyType]) -- ^ /Required/ "media"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TalkToChatbot200Response
instance A.FromJSON TalkToChatbot200Response where
  parseJSON = A.withObject "TalkToChatbot200Response" $ \o ->
    TalkToChatbot200Response
      <$> (o .:  "answerText")
      <*> (o .:  "media")

-- | ToJSON TalkToChatbot200Response
instance A.ToJSON TalkToChatbot200Response where
  toJSON TalkToChatbot200Response {..} =
   _omitNulls
      [ "answerText" .= talkToChatbot200ResponseAnswerText
      , "media" .= talkToChatbot200ResponseMedia
      ]


-- | Construct a value of type 'TalkToChatbot200Response' (by applying it's required fields, if any)
mkTalkToChatbot200Response
  :: Text -- ^ 'talkToChatbot200ResponseAnswerText' 
  -> [AnyType] -- ^ 'talkToChatbot200ResponseMedia' 
  -> TalkToChatbot200Response
mkTalkToChatbot200Response talkToChatbot200ResponseAnswerText talkToChatbot200ResponseMedia =
  TalkToChatbot200Response
  { talkToChatbot200ResponseAnswerText
  , talkToChatbot200ResponseMedia
  }


-- * Enums


-- ** E'Accept

-- | Enum of 'Text'
data E'Accept
  = E'Accept'Application_json -- ^ @"application/json"@
  | E'Accept'Text_html -- ^ @"text/html"@
  | E'Accept'Media_ -- ^ @"media/*"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Accept where toJSON = A.toJSON . fromE'Accept
instance A.FromJSON E'Accept where parseJSON o = P.either P.fail (pure . P.id) . toE'Accept =<< A.parseJSON o
instance WH.ToHttpApiData E'Accept where toQueryParam = WH.toQueryParam . fromE'Accept
instance WH.FromHttpApiData E'Accept where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Accept
instance MimeRender MimeMultipartFormData E'Accept where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Accept' enum
fromE'Accept :: E'Accept -> Text
fromE'Accept = \case
  E'Accept'Application_json -> "application/json"
  E'Accept'Text_html -> "text/html"
  E'Accept'Media_ -> "media/*"

-- | parse 'E'Accept' enum
toE'Accept :: Text -> P.Either String E'Accept
toE'Accept = \case
  "application/json" -> P.Right E'Accept'Application_json
  "text/html" -> P.Right E'Accept'Text_html
  "media/*" -> P.Right E'Accept'Media_
  s -> P.Left $ "toE'Accept: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text'
data E'ContentType
  = E'ContentType'Application_x_www_form_urlencoded -- ^ @"application/x-www-form-urlencoded"@
  | E'ContentType'Application_json -- ^ @"application/json"@
  | E'ContentType'Multipart_form_data -- ^ @"multipart/form-data"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Application_x_www_form_urlencoded -> "application/x-www-form-urlencoded"
  E'ContentType'Application_json -> "application/json"
  E'ContentType'Multipart_form_data -> "multipart/form-data"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "application/x-www-form-urlencoded" -> P.Right E'ContentType'Application_x_www_form_urlencoded
  "application/json" -> P.Right E'ContentType'Application_json
  "multipart/form-data" -> P.Right E'ContentType'Multipart_form_data
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'Language

-- | Enum of 'Text'
data E'Language
  = E'Language'En -- ^ @"en"@
  | E'Language'De -- ^ @"de"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Language where toJSON = A.toJSON . fromE'Language
instance A.FromJSON E'Language where parseJSON o = P.either P.fail (pure . P.id) . toE'Language =<< A.parseJSON o
instance WH.ToHttpApiData E'Language where toQueryParam = WH.toQueryParam . fromE'Language
instance WH.FromHttpApiData E'Language where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Language
instance MimeRender MimeMultipartFormData E'Language where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Language' enum
fromE'Language :: E'Language -> Text
fromE'Language = \case
  E'Language'En -> "en"
  E'Language'De -> "de"

-- | parse 'E'Language' enum
toE'Language :: Text -> P.Either String E'Language
toE'Language = \case
  "en" -> P.Right E'Language'En
  "de" -> P.Right E'Language'De
  s -> P.Left $ "toE'Language: enum parse failure: " P.++ P.show s


-- ** E'Locale

-- | Enum of 'Text'
data E'Locale
  = E'Locale'US -- ^ @"en_US"@
  | E'Locale'GB -- ^ @"en_GB"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Locale where toJSON = A.toJSON . fromE'Locale
instance A.FromJSON E'Locale where parseJSON o = P.either P.fail (pure . P.id) . toE'Locale =<< A.parseJSON o
instance WH.ToHttpApiData E'Locale where toQueryParam = WH.toQueryParam . fromE'Locale
instance WH.FromHttpApiData E'Locale where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Locale
instance MimeRender MimeMultipartFormData E'Locale where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Locale' enum
fromE'Locale :: E'Locale -> Text
fromE'Locale = \case
  E'Locale'US -> "en_US"
  E'Locale'GB -> "en_GB"

-- | parse 'E'Locale' enum
toE'Locale :: Text -> P.Either String E'Locale
toE'Locale = \case
  "en_US" -> P.Right E'Locale'US
  "en_GB" -> P.Right E'Locale'GB
  s -> P.Left $ "toE'Locale: enum parse failure: " P.++ P.show s


-- ** E'Measure

-- | Enum of 'Text'
data E'Measure
  = E'Measure'Us -- ^ @"us"@
  | E'Measure'Metric -- ^ @"metric"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Measure where toJSON = A.toJSON . fromE'Measure
instance A.FromJSON E'Measure where parseJSON o = P.either P.fail (pure . P.id) . toE'Measure =<< A.parseJSON o
instance WH.ToHttpApiData E'Measure where toQueryParam = WH.toQueryParam . fromE'Measure
instance WH.FromHttpApiData E'Measure where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Measure
instance MimeRender MimeMultipartFormData E'Measure where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Measure' enum
fromE'Measure :: E'Measure -> Text
fromE'Measure = \case
  E'Measure'Us -> "us"
  E'Measure'Metric -> "metric"

-- | parse 'E'Measure' enum
toE'Measure :: Text -> P.Either String E'Measure
toE'Measure = \case
  "us" -> P.Right E'Measure'Us
  "metric" -> P.Right E'Measure'Metric
  s -> P.Left $ "toE'Measure: enum parse failure: " P.++ P.show s


-- ** E'Normalize

-- | Enum of 'Bool'
data E'Normalize
  = E'Normalize'False -- ^ @"false"@
  | E'Normalize'True -- ^ @"true"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Normalize where toJSON = A.toJSON . fromE'Normalize
instance A.FromJSON E'Normalize where parseJSON o = P.either P.fail (pure . P.id) . toE'Normalize =<< A.parseJSON o
instance WH.ToHttpApiData E'Normalize where toQueryParam = WH.toQueryParam . fromE'Normalize
instance WH.FromHttpApiData E'Normalize where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Normalize
instance MimeRender MimeMultipartFormData E'Normalize where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Normalize' enum
fromE'Normalize :: E'Normalize -> Bool
fromE'Normalize = \case
  E'Normalize'False -> "false"
  E'Normalize'True -> "true"

-- | parse 'E'Normalize' enum
toE'Normalize :: Bool -> P.Either String E'Normalize
toE'Normalize = \case
  "false" -> P.Right E'Normalize'False
  "true" -> P.Right E'Normalize'True
  s -> P.Left $ "toE'Normalize: enum parse failure: " P.++ P.show s


-- ** E'Normalize2

-- | Enum of 'Bool'
data E'Normalize2
  = E'Normalize2'True -- ^ @"true"@
  | E'Normalize2'False -- ^ @"false"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Normalize2 where toJSON = A.toJSON . fromE'Normalize2
instance A.FromJSON E'Normalize2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Normalize2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Normalize2 where toQueryParam = WH.toQueryParam . fromE'Normalize2
instance WH.FromHttpApiData E'Normalize2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Normalize2
instance MimeRender MimeMultipartFormData E'Normalize2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Normalize2' enum
fromE'Normalize2 :: E'Normalize2 -> Bool
fromE'Normalize2 = \case
  E'Normalize2'True -> "true"
  E'Normalize2'False -> "false"

-- | parse 'E'Normalize2' enum
toE'Normalize2 :: Bool -> P.Either String E'Normalize2
toE'Normalize2 = \case
  "true" -> P.Right E'Normalize2'True
  "false" -> P.Right E'Normalize2'False
  s -> P.Left $ "toE'Normalize2: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKeyScheme
data AuthApiKeyApiKeyScheme =
  AuthApiKeyApiKeyScheme Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyScheme where
  applyAuthMethod _ a@(AuthApiKeyApiKeyScheme secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


