<?php
/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.7.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'analyzeRecipe' => [
            'application/json',
        ],
        'createRecipeCardGet' => [
            'application/json',
        ],
        'searchRestaurants' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation analyzeRecipe
     *
     * Analyze Recipe
     *
     * @param  \OpenAPI\Client\Model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipe'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function analyzeRecipe($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null, string $contentType = self::contentTypes['analyzeRecipe'][0])
    {
        list($response) = $this->analyzeRecipeWithHttpInfo($analyze_recipe_request, $language, $include_nutrition, $include_taste, $contentType);
        return $response;
    }

    /**
     * Operation analyzeRecipeWithHttpInfo
     *
     * Analyze Recipe
     *
     * @param  \OpenAPI\Client\Model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipe'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeRecipeWithHttpInfo($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null, string $contentType = self::contentTypes['analyzeRecipe'][0])
    {
        $request = $this->analyzeRecipeRequest($analyze_recipe_request, $language, $include_nutrition, $include_taste, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeRecipeAsync
     *
     * Analyze Recipe
     *
     * @param  \OpenAPI\Client\Model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeAsync($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null, string $contentType = self::contentTypes['analyzeRecipe'][0])
    {
        return $this->analyzeRecipeAsyncWithHttpInfo($analyze_recipe_request, $language, $include_nutrition, $include_taste, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeRecipeAsyncWithHttpInfo
     *
     * Analyze Recipe
     *
     * @param  \OpenAPI\Client\Model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeAsyncWithHttpInfo($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null, string $contentType = self::contentTypes['analyzeRecipe'][0])
    {
        $returnType = 'object';
        $request = $this->analyzeRecipeRequest($analyze_recipe_request, $language, $include_nutrition, $include_taste, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeRecipe'
     *
     * @param  \OpenAPI\Client\Model\AnalyzeRecipeRequest $analyze_recipe_request Example request body. (required)
     * @param  string $language The input language, either \&quot;en\&quot; or \&quot;de\&quot;. (optional)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['analyzeRecipe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function analyzeRecipeRequest($analyze_recipe_request, $language = null, $include_nutrition = null, $include_taste = null, string $contentType = self::contentTypes['analyzeRecipe'][0])
    {

        // verify the required parameter 'analyze_recipe_request' is set
        if ($analyze_recipe_request === null || (is_array($analyze_recipe_request) && count($analyze_recipe_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $analyze_recipe_request when calling analyzeRecipe'
            );
        }





        $resourcePath = '/recipes/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_taste,
            'includeTaste', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($analyze_recipe_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($analyze_recipe_request));
            } else {
                $httpBody = $analyze_recipe_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRecipeCardGet
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCardGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createRecipeCardGet($id, $mask = null, $background_image = null, $background_color = null, $font_color = null, string $contentType = self::contentTypes['createRecipeCardGet'][0])
    {
        list($response) = $this->createRecipeCardGetWithHttpInfo($id, $mask, $background_image, $background_color, $font_color, $contentType);
        return $response;
    }

    /**
     * Operation createRecipeCardGetWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCardGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRecipeCardGetWithHttpInfo($id, $mask = null, $background_image = null, $background_color = null, $font_color = null, string $contentType = self::contentTypes['createRecipeCardGet'][0])
    {
        $request = $this->createRecipeCardGetRequest($id, $mask, $background_image, $background_color, $font_color, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRecipeCardGetAsync
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCardGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardGetAsync($id, $mask = null, $background_image = null, $background_color = null, $font_color = null, string $contentType = self::contentTypes['createRecipeCardGet'][0])
    {
        return $this->createRecipeCardGetAsyncWithHttpInfo($id, $mask, $background_image, $background_color, $font_color, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRecipeCardGetAsyncWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCardGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardGetAsyncWithHttpInfo($id, $mask = null, $background_image = null, $background_color = null, $font_color = null, string $contentType = self::contentTypes['createRecipeCardGet'][0])
    {
        $returnType = 'object';
        $request = $this->createRecipeCardGetRequest($id, $mask, $background_image, $background_color, $font_color, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRecipeCardGet'
     *
     * @param  float $id The recipe id. (required)
     * @param  string $mask The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;). (optional)
     * @param  string $background_image The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;). (optional)
     * @param  string $background_color The background color for the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color for the recipe card as a hex-string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRecipeCardGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRecipeCardGetRequest($id, $mask = null, $background_image = null, $background_color = null, $font_color = null, string $contentType = self::contentTypes['createRecipeCardGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createRecipeCardGet'
            );
        }






        $resourcePath = '/recipes/{id}/card';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask,
            'mask', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_image,
            'backgroundImage', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $font_color,
            'fontColor', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRestaurants
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRestaurants'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchRestaurants200Response
     */
    public function searchRestaurants($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null, string $contentType = self::contentTypes['searchRestaurants'][0])
    {
        list($response) = $this->searchRestaurantsWithHttpInfo($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page, $contentType);
        return $response;
    }

    /**
     * Operation searchRestaurantsWithHttpInfo
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRestaurants'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchRestaurants200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRestaurantsWithHttpInfo($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null, string $contentType = self::contentTypes['searchRestaurants'][0])
    {
        $request = $this->searchRestaurantsRequest($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchRestaurants200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchRestaurants200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchRestaurants200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SearchRestaurants200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchRestaurants200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRestaurantsAsync
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRestaurants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantsAsync($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null, string $contentType = self::contentTypes['searchRestaurants'][0])
    {
        return $this->searchRestaurantsAsyncWithHttpInfo($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRestaurantsAsyncWithHttpInfo
     *
     * Search Restaurants
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRestaurants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRestaurantsAsyncWithHttpInfo($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null, string $contentType = self::contentTypes['searchRestaurants'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchRestaurants200Response';
        $request = $this->searchRestaurantsRequest($query, $lat, $lng, $distance, $budget, $cuisine, $min_rating, $is_open, $sort, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRestaurants'
     *
     * @param  string $query The search query. (optional)
     * @param  float $lat The latitude of the user&#39;s location. (optional)
     * @param  float $lng The longitude of the user&#39;s location.\&quot;. (optional)
     * @param  float $distance The distance around the location in miles. (optional)
     * @param  float $budget The user&#39;s budget for a meal in USD. (optional)
     * @param  string $cuisine The cuisine of the restaurant. (optional)
     * @param  float $min_rating The minimum rating of the restaurant between 0 and 5. (optional)
     * @param  bool $is_open Whether the restaurant must be open at the time of search. (optional)
     * @param  string $sort How to sort the results, one of the following &#39;cheapest&#39;, &#39;fastest&#39;, &#39;rating&#39;, &#39;distance&#39; or the default &#39;relevance&#39;. (optional)
     * @param  float $page The page number of results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchRestaurants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRestaurantsRequest($query = null, $lat = null, $lng = null, $distance = null, $budget = null, $cuisine = null, $min_rating = null, $is_open = null, $sort = null, $page = null, string $contentType = self::contentTypes['searchRestaurants'][0])
    {












        $resourcePath = '/food/restaurants/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lat,
            'lat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lng,
            'lng', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance,
            'distance', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $budget,
            'budget', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cuisine,
            'cuisine', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_rating,
            'min-rating', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_open,
            'is-open', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
