--[[
  spoonacular API

  The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 800,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

  The version of the OpenAPI document: 1.1
  Contact: mail@spoonacular.com
  Generated by: https://openapi-generator.tech
]]

--package openapiclient

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local openapiclient_todo_object_mapping = require "openapiclient.model.todo_object_mapping"
local openapiclient_analyze_a_recipe_search_query_200_response = require "openapiclient.model.analyze_a_recipe_search_query_200_response"
local openapiclient_analyze_recipe_instructions_200_response = require "openapiclient.model.analyze_recipe_instructions_200_response"
local openapiclient_autocomplete_recipe_search_200_response_inner = require "openapiclient.model.autocomplete_recipe_search_200_response_inner"
local openapiclient_classify_cuisine_200_response = require "openapiclient.model.classify_cuisine_200_response"
local openapiclient_compute_glycemic_load_200_response = require "openapiclient.model.compute_glycemic_load_200_response"
local openapiclient_compute_glycemic_load_request = require "openapiclient.model.compute_glycemic_load_request"
local openapiclient_convert_amounts_200_response = require "openapiclient.model.convert_amounts_200_response"
local openapiclient_create_recipe_card_200_response = require "openapiclient.model.create_recipe_card_200_response"
local openapiclient_get_analyzed_recipe_instructions_200_response = require "openapiclient.model.get_analyzed_recipe_instructions_200_response"
local openapiclient_get_random_recipes_200_response = require "openapiclient.model.get_random_recipes_200_response"
local openapiclient_get_recipe_equipment_by_id_200_response = require "openapiclient.model.get_recipe_equipment_by_id_200_response"
local openapiclient_get_recipe_information_bulk_200_response_inner = require "openapiclient.model.get_recipe_information_bulk_200_response_inner"
local openapiclient_get_recipe_information_200_response = require "openapiclient.model.get_recipe_information_200_response"
local openapiclient_get_recipe_ingredients_by_id_200_response = require "openapiclient.model.get_recipe_ingredients_by_id_200_response"
local openapiclient_get_recipe_nutrition_widget_by_id_200_response = require "openapiclient.model.get_recipe_nutrition_widget_by_id_200_response"
local openapiclient_get_recipe_price_breakdown_by_id_200_response = require "openapiclient.model.get_recipe_price_breakdown_by_id_200_response"
local openapiclient_get_recipe_taste_by_id_200_response = require "openapiclient.model.get_recipe_taste_by_id_200_response"
local openapiclient_get_similar_recipes_200_response_inner = require "openapiclient.model.get_similar_recipes_200_response_inner"
local openapiclient_guess_nutrition_by_dish_name_200_response = require "openapiclient.model.guess_nutrition_by_dish_name_200_response"
local openapiclient_parse_ingredients_200_response_inner = require "openapiclient.model.parse_ingredients_200_response_inner"
local openapiclient_quick_answer_200_response = require "openapiclient.model.quick_answer_200_response"
local openapiclient_search_recipes_by_ingredients_200_response_inner = require "openapiclient.model.search_recipes_by_ingredients_200_response_inner"
local openapiclient_search_recipes_by_nutrients_200_response_inner = require "openapiclient.model.search_recipes_by_nutrients_200_response_inner"
local openapiclient_search_recipes_200_response = require "openapiclient.model.search_recipes_200_response"
local openapiclient_summarize_recipe_200_response = require "openapiclient.model.summarize_recipe_200_response"

local recipes_api = {}
local recipes_api_mt = {
	__name = "recipes_api";
	__index = recipes_api;
}

local function new_recipes_api(authority, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	local host, port = http_util.split_authority(authority, default_scheme)
	return setmetatable({
		host = host;
		port = port;
		basePath = basePath or "https://api.spoonacular.com";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, recipes_api_mt)
end

function recipes_api:analyze_a_recipe_search_query(q)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/queries/analyze?q=%s",
			self.basePath, http_util.encodeURIComponent(q));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_analyze_a_recipe_search_query_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:analyze_recipe_instructions(content_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/analyzeInstructions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_analyze_recipe_instructions_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:autocomplete_recipe_search(query, Number_)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/autocomplete?query=%s&number=%s",
			self.basePath, http_util.encodeURIComponent(query), http_util.encodeURIComponent(Number_));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			openapiclient_autocomplete_recipe_search_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:classify_cuisine(content_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/cuisine",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_classify_cuisine_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:compute_glycemic_load(compute_glycemic_load_request, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/food/ingredients/glycemicLoad?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(compute_glycemic_load_request))

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_compute_glycemic_load_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:convert_amounts(ingredient_name, source_amount, source_unit, target_unit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/convert?ingredientName=%s&sourceAmount=%s&sourceUnit=%s&targetUnit=%s",
			self.basePath, http_util.encodeURIComponent(ingredient_name), http_util.encodeURIComponent(source_amount), http_util.encodeURIComponent(source_unit), http_util.encodeURIComponent(target_unit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_convert_amounts_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:create_recipe_card(content_type)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeRecipe",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_create_recipe_card_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:equipment_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:extract_recipe_from_website(url, force_extraction, analyze, include_nutrition, include_taste)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/extract?url=%s&forceExtraction=%s&analyze=%s&includeNutrition=%s&includeTaste=%s",
			self.basePath, http_util.encodeURIComponent(url), http_util.encodeURIComponent(force_extraction), http_util.encodeURIComponent(analyze), http_util.encodeURIComponent(include_nutrition), http_util.encodeURIComponent(include_taste));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_recipe_information_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_analyzed_recipe_instructions(id, step_breakdown)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/analyzedInstructions?stepBreakdown=%s",
			self.basePath, id, http_util.encodeURIComponent(step_breakdown));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_analyzed_recipe_instructions_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_random_recipes(limit_license, tags, Number_)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/random?limitLicense=%s&tags=%s&number=%s",
			self.basePath, http_util.encodeURIComponent(limit_license), http_util.encodeURIComponent(tags), http_util.encodeURIComponent(Number_));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_random_recipes_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_equipment_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_recipe_equipment_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_information(id, include_nutrition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/information?includeNutrition=%s",
			self.basePath, id, http_util.encodeURIComponent(include_nutrition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_recipe_information_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_information_bulk(ids, include_nutrition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/informationBulk?ids=%s&includeNutrition=%s",
			self.basePath, http_util.encodeURIComponent(ids), http_util.encodeURIComponent(include_nutrition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			openapiclient_get_recipe_information_bulk_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_ingredients_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_recipe_ingredients_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_nutrition_widget_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_recipe_nutrition_widget_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_price_breakdown_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_recipe_price_breakdown_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_taste_by_id(id, normalize)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget.json?normalize=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_get_recipe_taste_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_similar_recipes(id, Number_, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/similar?number=%s&limitLicense=%s",
			self.basePath, id, http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			openapiclient_get_similar_recipes_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:guess_nutrition_by_dish_name(title)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/guessNutrition?title=%s",
			self.basePath, http_util.encodeURIComponent(title));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_guess_nutrition_by_dish_name_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:ingredients_by_id_image(id, measure)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget.png?measure=%s",
			self.basePath, id, http_util.encodeURIComponent(measure));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:parse_ingredients(content_type, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/parseIngredients?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			openapiclient_parse_ingredients_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:price_breakdown_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:quick_answer(q)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/quickAnswer?q=%s",
			self.basePath, http_util.encodeURIComponent(q));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_quick_answer_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_label_image(id, show_optional_nutrients, show_zero_values, show_ingredients)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionLabel.png?showOptionalNutrients=%s&showZeroValues=%s&showIngredients=%s",
			self.basePath, id, http_util.encodeURIComponent(show_optional_nutrients), http_util.encodeURIComponent(show_zero_values), http_util.encodeURIComponent(show_ingredients));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_label_widget(id, default_css, show_optional_nutrients, show_zero_values, show_ingredients)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionLabel?defaultCss=%s&showOptionalNutrients=%s&showZeroValues=%s&showIngredients=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css), http_util.encodeURIComponent(show_optional_nutrients), http_util.encodeURIComponent(show_zero_values), http_util.encodeURIComponent(show_ingredients));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_taste_by_id_image(id, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget.png?normalize=%s&rgb=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_TODO_OBJECT_MAPPING.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes(query, cuisine, exclude_cuisine, diet, intolerances, equipment, include_ingredients, exclude_ingredients, type, instructions_required, fill_ingredients, add_recipe_information, add_recipe_nutrition, author, tags, recipe_box_id, title_match, max_ready_time, ignore_pantry, sort, sort_direction, min_carbs, max_carbs, min_protein, max_protein, min_calories, max_calories, min_fat, max_fat, min_alcohol, max_alcohol, min_caffeine, max_caffeine, min_copper, max_copper, min_calcium, max_calcium, min_choline, max_choline, min_cholesterol, max_cholesterol, min_fluoride, max_fluoride, min_saturated_fat, max_saturated_fat, min_vitamin_a, max_vitamin_a, min_vitamin_c, max_vitamin_c, min_vitamin_d, max_vitamin_d, min_vitamin_e, max_vitamin_e, min_vitamin_k, max_vitamin_k, min_vitamin_b1, max_vitamin_b1, min_vitamin_b2, max_vitamin_b2, min_vitamin_b5, max_vitamin_b5, min_vitamin_b3, max_vitamin_b3, min_vitamin_b6, max_vitamin_b6, min_vitamin_b12, max_vitamin_b12, min_fiber, max_fiber, min_folate, max_folate, min_folic_acid, max_folic_acid, min_iodine, max_iodine, min_iron, max_iron, min_magnesium, max_magnesium, min_manganese, max_manganese, min_phosphorus, max_phosphorus, min_potassium, max_potassium, min_selenium, max_selenium, min_sodium, max_sodium, min_sugar, max_sugar, min_zinc, max_zinc, offset, Number_, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/complexSearch?query=%s&cuisine=%s&excludeCuisine=%s&diet=%s&intolerances=%s&equipment=%s&includeIngredients=%s&excludeIngredients=%s&type=%s&instructionsRequired=%s&fillIngredients=%s&addRecipeInformation=%s&addRecipeNutrition=%s&author=%s&tags=%s&recipeBoxId=%s&titleMatch=%s&maxReadyTime=%s&ignorePantry=%s&sort=%s&sortDirection=%s&minCarbs=%s&maxCarbs=%s&minProtein=%s&maxProtein=%s&minCalories=%s&maxCalories=%s&minFat=%s&maxFat=%s&minAlcohol=%s&maxAlcohol=%s&minCaffeine=%s&maxCaffeine=%s&minCopper=%s&maxCopper=%s&minCalcium=%s&maxCalcium=%s&minCholine=%s&maxCholine=%s&minCholesterol=%s&maxCholesterol=%s&minFluoride=%s&maxFluoride=%s&minSaturatedFat=%s&maxSaturatedFat=%s&minVitaminA=%s&maxVitaminA=%s&minVitaminC=%s&maxVitaminC=%s&minVitaminD=%s&maxVitaminD=%s&minVitaminE=%s&maxVitaminE=%s&minVitaminK=%s&maxVitaminK=%s&minVitaminB1=%s&maxVitaminB1=%s&minVitaminB2=%s&maxVitaminB2=%s&minVitaminB5=%s&maxVitaminB5=%s&minVitaminB3=%s&maxVitaminB3=%s&minVitaminB6=%s&maxVitaminB6=%s&minVitaminB12=%s&maxVitaminB12=%s&minFiber=%s&maxFiber=%s&minFolate=%s&maxFolate=%s&minFolicAcid=%s&maxFolicAcid=%s&minIodine=%s&maxIodine=%s&minIron=%s&maxIron=%s&minMagnesium=%s&maxMagnesium=%s&minManganese=%s&maxManganese=%s&minPhosphorus=%s&maxPhosphorus=%s&minPotassium=%s&maxPotassium=%s&minSelenium=%s&maxSelenium=%s&minSodium=%s&maxSodium=%s&minSugar=%s&maxSugar=%s&minZinc=%s&maxZinc=%s&offset=%s&number=%s&limitLicense=%s",
			self.basePath, http_util.encodeURIComponent(query), http_util.encodeURIComponent(cuisine), http_util.encodeURIComponent(exclude_cuisine), http_util.encodeURIComponent(diet), http_util.encodeURIComponent(intolerances), http_util.encodeURIComponent(equipment), http_util.encodeURIComponent(include_ingredients), http_util.encodeURIComponent(exclude_ingredients), http_util.encodeURIComponent(type), http_util.encodeURIComponent(instructions_required), http_util.encodeURIComponent(fill_ingredients), http_util.encodeURIComponent(add_recipe_information), http_util.encodeURIComponent(add_recipe_nutrition), http_util.encodeURIComponent(author), http_util.encodeURIComponent(tags), http_util.encodeURIComponent(recipe_box_id), http_util.encodeURIComponent(title_match), http_util.encodeURIComponent(max_ready_time), http_util.encodeURIComponent(ignore_pantry), http_util.encodeURIComponent(sort), http_util.encodeURIComponent(sort_direction), http_util.encodeURIComponent(min_carbs), http_util.encodeURIComponent(max_carbs), http_util.encodeURIComponent(min_protein), http_util.encodeURIComponent(max_protein), http_util.encodeURIComponent(min_calories), http_util.encodeURIComponent(max_calories), http_util.encodeURIComponent(min_fat), http_util.encodeURIComponent(max_fat), http_util.encodeURIComponent(min_alcohol), http_util.encodeURIComponent(max_alcohol), http_util.encodeURIComponent(min_caffeine), http_util.encodeURIComponent(max_caffeine), http_util.encodeURIComponent(min_copper), http_util.encodeURIComponent(max_copper), http_util.encodeURIComponent(min_calcium), http_util.encodeURIComponent(max_calcium), http_util.encodeURIComponent(min_choline), http_util.encodeURIComponent(max_choline), http_util.encodeURIComponent(min_cholesterol), http_util.encodeURIComponent(max_cholesterol), http_util.encodeURIComponent(min_fluoride), http_util.encodeURIComponent(max_fluoride), http_util.encodeURIComponent(min_saturated_fat), http_util.encodeURIComponent(max_saturated_fat), http_util.encodeURIComponent(min_vitamin_a), http_util.encodeURIComponent(max_vitamin_a), http_util.encodeURIComponent(min_vitamin_c), http_util.encodeURIComponent(max_vitamin_c), http_util.encodeURIComponent(min_vitamin_d), http_util.encodeURIComponent(max_vitamin_d), http_util.encodeURIComponent(min_vitamin_e), http_util.encodeURIComponent(max_vitamin_e), http_util.encodeURIComponent(min_vitamin_k), http_util.encodeURIComponent(max_vitamin_k), http_util.encodeURIComponent(min_vitamin_b1), http_util.encodeURIComponent(max_vitamin_b1), http_util.encodeURIComponent(min_vitamin_b2), http_util.encodeURIComponent(max_vitamin_b2), http_util.encodeURIComponent(min_vitamin_b5), http_util.encodeURIComponent(max_vitamin_b5), http_util.encodeURIComponent(min_vitamin_b3), http_util.encodeURIComponent(max_vitamin_b3), http_util.encodeURIComponent(min_vitamin_b6), http_util.encodeURIComponent(max_vitamin_b6), http_util.encodeURIComponent(min_vitamin_b12), http_util.encodeURIComponent(max_vitamin_b12), http_util.encodeURIComponent(min_fiber), http_util.encodeURIComponent(max_fiber), http_util.encodeURIComponent(min_folate), http_util.encodeURIComponent(max_folate), http_util.encodeURIComponent(min_folic_acid), http_util.encodeURIComponent(max_folic_acid), http_util.encodeURIComponent(min_iodine), http_util.encodeURIComponent(max_iodine), http_util.encodeURIComponent(min_iron), http_util.encodeURIComponent(max_iron), http_util.encodeURIComponent(min_magnesium), http_util.encodeURIComponent(max_magnesium), http_util.encodeURIComponent(min_manganese), http_util.encodeURIComponent(max_manganese), http_util.encodeURIComponent(min_phosphorus), http_util.encodeURIComponent(max_phosphorus), http_util.encodeURIComponent(min_potassium), http_util.encodeURIComponent(max_potassium), http_util.encodeURIComponent(min_selenium), http_util.encodeURIComponent(max_selenium), http_util.encodeURIComponent(min_sodium), http_util.encodeURIComponent(max_sodium), http_util.encodeURIComponent(min_sugar), http_util.encodeURIComponent(max_sugar), http_util.encodeURIComponent(min_zinc), http_util.encodeURIComponent(max_zinc), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_search_recipes_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes_by_ingredients(ingredients, Number_, limit_license, ranking, ignore_pantry)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/findByIngredients?ingredients=%s&number=%s&limitLicense=%s&ranking=%s&ignorePantry=%s",
			self.basePath, http_util.encodeURIComponent(ingredients), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license), http_util.encodeURIComponent(ranking), http_util.encodeURIComponent(ignore_pantry));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			openapiclient_search_recipes_by_ingredients_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes_by_nutrients(min_carbs, max_carbs, min_protein, max_protein, min_calories, max_calories, min_fat, max_fat, min_alcohol, max_alcohol, min_caffeine, max_caffeine, min_copper, max_copper, min_calcium, max_calcium, min_choline, max_choline, min_cholesterol, max_cholesterol, min_fluoride, max_fluoride, min_saturated_fat, max_saturated_fat, min_vitamin_a, max_vitamin_a, min_vitamin_c, max_vitamin_c, min_vitamin_d, max_vitamin_d, min_vitamin_e, max_vitamin_e, min_vitamin_k, max_vitamin_k, min_vitamin_b1, max_vitamin_b1, min_vitamin_b2, max_vitamin_b2, min_vitamin_b5, max_vitamin_b5, min_vitamin_b3, max_vitamin_b3, min_vitamin_b6, max_vitamin_b6, min_vitamin_b12, max_vitamin_b12, min_fiber, max_fiber, min_folate, max_folate, min_folic_acid, max_folic_acid, min_iodine, max_iodine, min_iron, max_iron, min_magnesium, max_magnesium, min_manganese, max_manganese, min_phosphorus, max_phosphorus, min_potassium, max_potassium, min_selenium, max_selenium, min_sodium, max_sodium, min_sugar, max_sugar, min_zinc, max_zinc, offset, Number_, random, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/findByNutrients?minCarbs=%s&maxCarbs=%s&minProtein=%s&maxProtein=%s&minCalories=%s&maxCalories=%s&minFat=%s&maxFat=%s&minAlcohol=%s&maxAlcohol=%s&minCaffeine=%s&maxCaffeine=%s&minCopper=%s&maxCopper=%s&minCalcium=%s&maxCalcium=%s&minCholine=%s&maxCholine=%s&minCholesterol=%s&maxCholesterol=%s&minFluoride=%s&maxFluoride=%s&minSaturatedFat=%s&maxSaturatedFat=%s&minVitaminA=%s&maxVitaminA=%s&minVitaminC=%s&maxVitaminC=%s&minVitaminD=%s&maxVitaminD=%s&minVitaminE=%s&maxVitaminE=%s&minVitaminK=%s&maxVitaminK=%s&minVitaminB1=%s&maxVitaminB1=%s&minVitaminB2=%s&maxVitaminB2=%s&minVitaminB5=%s&maxVitaminB5=%s&minVitaminB3=%s&maxVitaminB3=%s&minVitaminB6=%s&maxVitaminB6=%s&minVitaminB12=%s&maxVitaminB12=%s&minFiber=%s&maxFiber=%s&minFolate=%s&maxFolate=%s&minFolicAcid=%s&maxFolicAcid=%s&minIodine=%s&maxIodine=%s&minIron=%s&maxIron=%s&minMagnesium=%s&maxMagnesium=%s&minManganese=%s&maxManganese=%s&minPhosphorus=%s&maxPhosphorus=%s&minPotassium=%s&maxPotassium=%s&minSelenium=%s&maxSelenium=%s&minSodium=%s&maxSodium=%s&minSugar=%s&maxSugar=%s&minZinc=%s&maxZinc=%s&offset=%s&number=%s&random=%s&limitLicense=%s",
			self.basePath, http_util.encodeURIComponent(min_carbs), http_util.encodeURIComponent(max_carbs), http_util.encodeURIComponent(min_protein), http_util.encodeURIComponent(max_protein), http_util.encodeURIComponent(min_calories), http_util.encodeURIComponent(max_calories), http_util.encodeURIComponent(min_fat), http_util.encodeURIComponent(max_fat), http_util.encodeURIComponent(min_alcohol), http_util.encodeURIComponent(max_alcohol), http_util.encodeURIComponent(min_caffeine), http_util.encodeURIComponent(max_caffeine), http_util.encodeURIComponent(min_copper), http_util.encodeURIComponent(max_copper), http_util.encodeURIComponent(min_calcium), http_util.encodeURIComponent(max_calcium), http_util.encodeURIComponent(min_choline), http_util.encodeURIComponent(max_choline), http_util.encodeURIComponent(min_cholesterol), http_util.encodeURIComponent(max_cholesterol), http_util.encodeURIComponent(min_fluoride), http_util.encodeURIComponent(max_fluoride), http_util.encodeURIComponent(min_saturated_fat), http_util.encodeURIComponent(max_saturated_fat), http_util.encodeURIComponent(min_vitamin_a), http_util.encodeURIComponent(max_vitamin_a), http_util.encodeURIComponent(min_vitamin_c), http_util.encodeURIComponent(max_vitamin_c), http_util.encodeURIComponent(min_vitamin_d), http_util.encodeURIComponent(max_vitamin_d), http_util.encodeURIComponent(min_vitamin_e), http_util.encodeURIComponent(max_vitamin_e), http_util.encodeURIComponent(min_vitamin_k), http_util.encodeURIComponent(max_vitamin_k), http_util.encodeURIComponent(min_vitamin_b1), http_util.encodeURIComponent(max_vitamin_b1), http_util.encodeURIComponent(min_vitamin_b2), http_util.encodeURIComponent(max_vitamin_b2), http_util.encodeURIComponent(min_vitamin_b5), http_util.encodeURIComponent(max_vitamin_b5), http_util.encodeURIComponent(min_vitamin_b3), http_util.encodeURIComponent(max_vitamin_b3), http_util.encodeURIComponent(min_vitamin_b6), http_util.encodeURIComponent(max_vitamin_b6), http_util.encodeURIComponent(min_vitamin_b12), http_util.encodeURIComponent(max_vitamin_b12), http_util.encodeURIComponent(min_fiber), http_util.encodeURIComponent(max_fiber), http_util.encodeURIComponent(min_folate), http_util.encodeURIComponent(max_folate), http_util.encodeURIComponent(min_folic_acid), http_util.encodeURIComponent(max_folic_acid), http_util.encodeURIComponent(min_iodine), http_util.encodeURIComponent(max_iodine), http_util.encodeURIComponent(min_iron), http_util.encodeURIComponent(max_iron), http_util.encodeURIComponent(min_magnesium), http_util.encodeURIComponent(max_magnesium), http_util.encodeURIComponent(min_manganese), http_util.encodeURIComponent(max_manganese), http_util.encodeURIComponent(min_phosphorus), http_util.encodeURIComponent(max_phosphorus), http_util.encodeURIComponent(min_potassium), http_util.encodeURIComponent(max_potassium), http_util.encodeURIComponent(min_selenium), http_util.encodeURIComponent(max_selenium), http_util.encodeURIComponent(min_sodium), http_util.encodeURIComponent(max_sodium), http_util.encodeURIComponent(min_sugar), http_util.encodeURIComponent(max_sugar), http_util.encodeURIComponent(min_zinc), http_util.encodeURIComponent(max_zinc), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(random), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			openapiclient_search_recipes_by_nutrients_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:summarize_recipe(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/summary",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return openapiclient_summarize_recipe_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_equipment(content_type, accept)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeEquipment",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_price_breakdown(content_type, accept, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizePriceEstimator?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_equipment_by_id(id, default_css)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_ingredients_by_id(id, default_css, measure)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget?defaultCss=%s&measure=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css), http_util.encodeURIComponent(measure));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_nutrition(content_type, accept, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeNutrition?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_nutrition_by_id(id, default_css, accept)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_price_breakdown_by_id(id, default_css)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_taste(language, content_type, accept, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeTaste?language=%s&normalize=%s&rgb=%s",
			self.basePath, http_util.encodeURIComponent(language), http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_taste_by_id(id, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget?normalize=%s&rgb=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_recipes_api;
}
