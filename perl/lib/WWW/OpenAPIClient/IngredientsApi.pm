=begin comment

spoonacular API

The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

The version of the OpenAPI document: 1.1
Contact: mail@spoonacular.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::IngredientsApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# autocomplete_ingredient_search
#
# Autocomplete Ingredient Search
#
# @param string $query The (natural language) search query. (optional)
# @param int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
# @param boolean $meta_information Whether to return more meta information about the ingredients. (optional)
# @param string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
# @param string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
{
    my $params = {
    'query' => {
        data_type => 'string',
        description => 'The (natural language) search query.',
        required => '0',
    },
    'number' => {
        data_type => 'int',
        description => 'The maximum number of items to return (between 1 and 100). Defaults to 10.',
        required => '0',
    },
    'meta_information' => {
        data_type => 'boolean',
        description => 'Whether to return more meta information about the ingredients.',
        required => '0',
    },
    'intolerances' => {
        data_type => 'string',
        description => 'A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.',
        required => '0',
    },
    'language' => {
        data_type => 'string',
        description => 'The language of the input. Either &#39;en&#39; or &#39;de&#39;.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'autocomplete_ingredient_search' } = {
        summary => 'Autocomplete Ingredient Search',
        params => $params,
        returns => 'ARRAY[AutocompleteIngredientSearch200ResponseInner]',
        };
}
# @return ARRAY[AutocompleteIngredientSearch200ResponseInner]
#
sub autocomplete_ingredient_search {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/food/ingredients/autocomplete';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'query'}) {
        $query_params->{'query'} = $self->{api_client}->to_query_value($args{'query'});
    }

    # query params
    if ( exists $args{'number'}) {
        $query_params->{'number'} = $self->{api_client}->to_query_value($args{'number'});
    }

    # query params
    if ( exists $args{'meta_information'}) {
        $query_params->{'metaInformation'} = $self->{api_client}->to_query_value($args{'meta_information'});
    }

    # query params
    if ( exists $args{'intolerances'}) {
        $query_params->{'intolerances'} = $self->{api_client}->to_query_value($args{'intolerances'});
    }

    # query params
    if ( exists $args{'language'}) {
        $query_params->{'language'} = $self->{api_client}->to_query_value($args{'language'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[AutocompleteIngredientSearch200ResponseInner]', $response);
    return $_response_object;
}

#
# compute_ingredient_amount
#
# Compute Ingredient Amount
#
# @param double $id The id of the ingredient you want the amount for. (required)
# @param string $nutrient The target nutrient. See a list of supported nutrients. (required)
# @param double $target The target number of the given nutrient. (required)
# @param string $unit The target unit. (optional)
{
    my $params = {
    'id' => {
        data_type => 'double',
        description => 'The id of the ingredient you want the amount for.',
        required => '1',
    },
    'nutrient' => {
        data_type => 'string',
        description => 'The target nutrient. See a list of supported nutrients.',
        required => '1',
    },
    'target' => {
        data_type => 'double',
        description => 'The target number of the given nutrient.',
        required => '1',
    },
    'unit' => {
        data_type => 'string',
        description => 'The target unit.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'compute_ingredient_amount' } = {
        summary => 'Compute Ingredient Amount',
        params => $params,
        returns => 'ComputeIngredientAmount200Response',
        };
}
# @return ComputeIngredientAmount200Response
#
sub compute_ingredient_amount {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling compute_ingredient_amount");
    }

    # verify the required parameter 'nutrient' is set
    unless (exists $args{'nutrient'}) {
      croak("Missing the required parameter 'nutrient' when calling compute_ingredient_amount");
    }

    # verify the required parameter 'target' is set
    unless (exists $args{'target'}) {
      croak("Missing the required parameter 'target' when calling compute_ingredient_amount");
    }

    # parse inputs
    my $_resource_path = '/food/ingredients/{id}/amount';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'nutrient'}) {
        $query_params->{'nutrient'} = $self->{api_client}->to_query_value($args{'nutrient'});
    }

    # query params
    if ( exists $args{'target'}) {
        $query_params->{'target'} = $self->{api_client}->to_query_value($args{'target'});
    }

    # query params
    if ( exists $args{'unit'}) {
        $query_params->{'unit'} = $self->{api_client}->to_query_value($args{'unit'});
    }

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ComputeIngredientAmount200Response', $response);
    return $_response_object;
}

#
# get_ingredient_information
#
# Get Ingredient Information
#
# @param int $id The item&#39;s id. (required)
# @param double $amount The amount of this ingredient. (optional)
# @param string $unit The unit for the given amount. (optional)
{
    my $params = {
    'id' => {
        data_type => 'int',
        description => 'The item&#39;s id.',
        required => '1',
    },
    'amount' => {
        data_type => 'double',
        description => 'The amount of this ingredient.',
        required => '0',
    },
    'unit' => {
        data_type => 'string',
        description => 'The unit for the given amount.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_ingredient_information' } = {
        summary => 'Get Ingredient Information',
        params => $params,
        returns => 'GetIngredientInformation200Response',
        };
}
# @return GetIngredientInformation200Response
#
sub get_ingredient_information {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling get_ingredient_information");
    }

    # parse inputs
    my $_resource_path = '/food/ingredients/{id}/information';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'amount'}) {
        $query_params->{'amount'} = $self->{api_client}->to_query_value($args{'amount'});
    }

    # query params
    if ( exists $args{'unit'}) {
        $query_params->{'unit'} = $self->{api_client}->to_query_value($args{'unit'});
    }

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GetIngredientInformation200Response', $response);
    return $_response_object;
}

#
# get_ingredient_substitutes
#
# Get Ingredient Substitutes
#
# @param string $ingredient_name The name of the ingredient you want to replace. (required)
{
    my $params = {
    'ingredient_name' => {
        data_type => 'string',
        description => 'The name of the ingredient you want to replace.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_ingredient_substitutes' } = {
        summary => 'Get Ingredient Substitutes',
        params => $params,
        returns => 'GetIngredientSubstitutes200Response',
        };
}
# @return GetIngredientSubstitutes200Response
#
sub get_ingredient_substitutes {
    my ($self, %args) = @_;

    # verify the required parameter 'ingredient_name' is set
    unless (exists $args{'ingredient_name'}) {
      croak("Missing the required parameter 'ingredient_name' when calling get_ingredient_substitutes");
    }

    # parse inputs
    my $_resource_path = '/food/ingredients/substitutes';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'ingredient_name'}) {
        $query_params->{'ingredientName'} = $self->{api_client}->to_query_value($args{'ingredient_name'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GetIngredientSubstitutes200Response', $response);
    return $_response_object;
}

#
# get_ingredient_substitutes_by_id
#
# Get Ingredient Substitutes by ID
#
# @param int $id The item&#39;s id. (required)
{
    my $params = {
    'id' => {
        data_type => 'int',
        description => 'The item&#39;s id.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_ingredient_substitutes_by_id' } = {
        summary => 'Get Ingredient Substitutes by ID',
        params => $params,
        returns => 'GetIngredientSubstitutes200Response',
        };
}
# @return GetIngredientSubstitutes200Response
#
sub get_ingredient_substitutes_by_id {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling get_ingredient_substitutes_by_id");
    }

    # parse inputs
    my $_resource_path = '/food/ingredients/{id}/substitutes';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GetIngredientSubstitutes200Response', $response);
    return $_response_object;
}

#
# ingredient_search
#
# Ingredient Search
#
# @param string $query The (natural language) search query. (optional)
# @param boolean $add_children Whether to add children of found foods. (optional)
# @param double $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
# @param double $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
# @param double $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
# @param double $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
# @param double $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
# @param double $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
# @param boolean $meta_information Whether to return more meta information about the ingredients. (optional)
# @param string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
# @param string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
# @param string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
# @param int $offset The number of results to skip (between 0 and 900). (optional)
# @param int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
# @param string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
{
    my $params = {
    'query' => {
        data_type => 'string',
        description => 'The (natural language) search query.',
        required => '0',
    },
    'add_children' => {
        data_type => 'boolean',
        description => 'Whether to add children of found foods.',
        required => '0',
    },
    'min_protein_percent' => {
        data_type => 'double',
        description => 'The minimum percentage of protein the food must have (between 0 and 100).',
        required => '0',
    },
    'max_protein_percent' => {
        data_type => 'double',
        description => 'The maximum percentage of protein the food can have (between 0 and 100).',
        required => '0',
    },
    'min_fat_percent' => {
        data_type => 'double',
        description => 'The minimum percentage of fat the food must have (between 0 and 100).',
        required => '0',
    },
    'max_fat_percent' => {
        data_type => 'double',
        description => 'The maximum percentage of fat the food can have (between 0 and 100).',
        required => '0',
    },
    'min_carbs_percent' => {
        data_type => 'double',
        description => 'The minimum percentage of carbs the food must have (between 0 and 100).',
        required => '0',
    },
    'max_carbs_percent' => {
        data_type => 'double',
        description => 'The maximum percentage of carbs the food can have (between 0 and 100).',
        required => '0',
    },
    'meta_information' => {
        data_type => 'boolean',
        description => 'Whether to return more meta information about the ingredients.',
        required => '0',
    },
    'intolerances' => {
        data_type => 'string',
        description => 'A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'The strategy to sort recipes by. See a full list of supported sorting options.',
        required => '0',
    },
    'sort_direction' => {
        data_type => 'string',
        description => 'The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending).',
        required => '0',
    },
    'offset' => {
        data_type => 'int',
        description => 'The number of results to skip (between 0 and 900).',
        required => '0',
    },
    'number' => {
        data_type => 'int',
        description => 'The maximum number of items to return (between 1 and 100). Defaults to 10.',
        required => '0',
    },
    'language' => {
        data_type => 'string',
        description => 'The language of the input. Either &#39;en&#39; or &#39;de&#39;.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'ingredient_search' } = {
        summary => 'Ingredient Search',
        params => $params,
        returns => 'IngredientSearch200Response',
        };
}
# @return IngredientSearch200Response
#
sub ingredient_search {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/food/ingredients/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'query'}) {
        $query_params->{'query'} = $self->{api_client}->to_query_value($args{'query'});
    }

    # query params
    if ( exists $args{'add_children'}) {
        $query_params->{'addChildren'} = $self->{api_client}->to_query_value($args{'add_children'});
    }

    # query params
    if ( exists $args{'min_protein_percent'}) {
        $query_params->{'minProteinPercent'} = $self->{api_client}->to_query_value($args{'min_protein_percent'});
    }

    # query params
    if ( exists $args{'max_protein_percent'}) {
        $query_params->{'maxProteinPercent'} = $self->{api_client}->to_query_value($args{'max_protein_percent'});
    }

    # query params
    if ( exists $args{'min_fat_percent'}) {
        $query_params->{'minFatPercent'} = $self->{api_client}->to_query_value($args{'min_fat_percent'});
    }

    # query params
    if ( exists $args{'max_fat_percent'}) {
        $query_params->{'maxFatPercent'} = $self->{api_client}->to_query_value($args{'max_fat_percent'});
    }

    # query params
    if ( exists $args{'min_carbs_percent'}) {
        $query_params->{'minCarbsPercent'} = $self->{api_client}->to_query_value($args{'min_carbs_percent'});
    }

    # query params
    if ( exists $args{'max_carbs_percent'}) {
        $query_params->{'maxCarbsPercent'} = $self->{api_client}->to_query_value($args{'max_carbs_percent'});
    }

    # query params
    if ( exists $args{'meta_information'}) {
        $query_params->{'metaInformation'} = $self->{api_client}->to_query_value($args{'meta_information'});
    }

    # query params
    if ( exists $args{'intolerances'}) {
        $query_params->{'intolerances'} = $self->{api_client}->to_query_value($args{'intolerances'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'sort_direction'}) {
        $query_params->{'sortDirection'} = $self->{api_client}->to_query_value($args{'sort_direction'});
    }

    # query params
    if ( exists $args{'offset'}) {
        $query_params->{'offset'} = $self->{api_client}->to_query_value($args{'offset'});
    }

    # query params
    if ( exists $args{'number'}) {
        $query_params->{'number'} = $self->{api_client}->to_query_value($args{'number'});
    }

    # query params
    if ( exists $args{'language'}) {
        $query_params->{'language'} = $self->{api_client}->to_query_value($args{'language'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('IngredientSearch200Response', $response);
    return $_response_object;
}

#
# ingredients_by_id_image
#
# Ingredients by ID Image
#
# @param double $id The recipe id. (required)
# @param string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
{
    my $params = {
    'id' => {
        data_type => 'double',
        description => 'The recipe id.',
        required => '1',
    },
    'measure' => {
        data_type => 'string',
        description => 'Whether the the measures should be &#39;us&#39; or &#39;metric&#39;.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'ingredients_by_id_image' } = {
        summary => 'Ingredients by ID Image',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub ingredients_by_id_image {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling ingredients_by_id_image");
    }

    # parse inputs
    my $_resource_path = '/recipes/{id}/ingredientWidget.png';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('image/png');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'measure'}) {
        $query_params->{'measure'} = $self->{api_client}->to_query_value($args{'measure'});
    }

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# map_ingredients_to_grocery_products
#
# Map Ingredients to Grocery Products
#
# @param MapIngredientsToGroceryProductsRequest $map_ingredients_to_grocery_products_request  (required)
{
    my $params = {
    'map_ingredients_to_grocery_products_request' => {
        data_type => 'MapIngredientsToGroceryProductsRequest',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'map_ingredients_to_grocery_products' } = {
        summary => 'Map Ingredients to Grocery Products',
        params => $params,
        returns => 'ARRAY[MapIngredientsToGroceryProducts200ResponseInner]',
        };
}
# @return ARRAY[MapIngredientsToGroceryProducts200ResponseInner]
#
sub map_ingredients_to_grocery_products {
    my ($self, %args) = @_;

    # verify the required parameter 'map_ingredients_to_grocery_products_request' is set
    unless (exists $args{'map_ingredients_to_grocery_products_request'}) {
      croak("Missing the required parameter 'map_ingredients_to_grocery_products_request' when calling map_ingredients_to_grocery_products");
    }

    # parse inputs
    my $_resource_path = '/food/ingredients/map';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'map_ingredients_to_grocery_products_request'}) {
        $_body_data = $args{'map_ingredients_to_grocery_products_request'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[MapIngredientsToGroceryProducts200ResponseInner]', $response);
    return $_response_object;
}

#
# visualize_ingredients
#
# Ingredients Widget
#
# @param string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
# @param double $servings The number of servings. (required)
# @param string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
# @param string $measure The original system of measurement, either &#39;metric&#39; or &#39;us&#39;. (optional)
# @param string $view How to visualize the ingredients, either &#39;grid&#39; or &#39;list&#39;. (optional)
# @param boolean $default_css Whether the default CSS should be added to the response. (optional)
# @param boolean $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
{
    my $params = {
    'ingredient_list' => {
        data_type => 'string',
        description => 'The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n).',
        required => '1',
    },
    'servings' => {
        data_type => 'double',
        description => 'The number of servings.',
        required => '1',
    },
    'language' => {
        data_type => 'string',
        description => 'The language of the input. Either &#39;en&#39; or &#39;de&#39;.',
        required => '0',
    },
    'measure' => {
        data_type => 'string',
        description => 'The original system of measurement, either &#39;metric&#39; or &#39;us&#39;.',
        required => '0',
    },
    'view' => {
        data_type => 'string',
        description => 'How to visualize the ingredients, either &#39;grid&#39; or &#39;list&#39;.',
        required => '0',
    },
    'default_css' => {
        data_type => 'boolean',
        description => 'Whether the default CSS should be added to the response.',
        required => '0',
    },
    'show_backlink' => {
        data_type => 'boolean',
        description => 'Whether to show a backlink to spoonacular. If set false, this call counts against your quota.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'visualize_ingredients' } = {
        summary => 'Ingredients Widget',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub visualize_ingredients {
    my ($self, %args) = @_;

    # verify the required parameter 'ingredient_list' is set
    unless (exists $args{'ingredient_list'}) {
      croak("Missing the required parameter 'ingredient_list' when calling visualize_ingredients");
    }

    # verify the required parameter 'servings' is set
    unless (exists $args{'servings'}) {
      croak("Missing the required parameter 'servings' when calling visualize_ingredients");
    }

    # parse inputs
    my $_resource_path = '/recipes/visualizeIngredients';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/html');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/x-www-form-urlencoded');

    # query params
    if ( exists $args{'language'}) {
        $query_params->{'language'} = $self->{api_client}->to_query_value($args{'language'});
    }

    # form params
    if ( exists $args{'ingredient_list'} ) {
                $form_params->{'ingredientList'} = $self->{api_client}->to_form_value($args{'ingredient_list'});
    }

    # form params
    if ( exists $args{'servings'} ) {
                $form_params->{'servings'} = $self->{api_client}->to_form_value($args{'servings'});
    }

    # form params
    if ( exists $args{'measure'} ) {
                $form_params->{'measure'} = $self->{api_client}->to_form_value($args{'measure'});
    }

    # form params
    if ( exists $args{'view'} ) {
                $form_params->{'view'} = $self->{api_client}->to_form_value($args{'view'});
    }

    # form params
    if ( exists $args{'default_css'} ) {
                $form_params->{'defaultCss'} = $self->{api_client}->to_form_value($args{'default_css'});
    }

    # form params
    if ( exists $args{'show_backlink'} ) {
                $form_params->{'showBacklink'} = $self->{api_client}->to_form_value($args{'show_backlink'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(apiKeyScheme )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

1;
