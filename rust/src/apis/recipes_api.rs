/*
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`analyze_a_recipe_search_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnalyzeARecipeSearchQueryError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`analyze_recipe_instructions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnalyzeRecipeInstructionsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`autocomplete_recipe_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AutocompleteRecipeSearchError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`classify_cuisine`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClassifyCuisineError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`compute_glycemic_load`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ComputeGlycemicLoadError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`convert_amounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConvertAmountsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_recipe_card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRecipeCardError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`equipment_by_id_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EquipmentByIdImageError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_recipe_from_website`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractRecipeFromWebsiteError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_analyzed_recipe_instructions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAnalyzedRecipeInstructionsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_random_recipes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRandomRecipesError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recipe_equipment_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecipeEquipmentByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recipe_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecipeInformationError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recipe_information_bulk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecipeInformationBulkError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recipe_ingredients_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecipeIngredientsByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recipe_nutrition_widget_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecipeNutritionWidgetByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recipe_price_breakdown_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecipePriceBreakdownByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recipe_taste_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecipeTasteByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_similar_recipes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimilarRecipesError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`guess_nutrition_by_dish_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GuessNutritionByDishNameError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`parse_ingredients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParseIngredientsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`price_breakdown_by_id_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PriceBreakdownByIdImageError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`quick_answer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuickAnswerError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recipe_nutrition_by_id_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecipeNutritionByIdImageError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recipe_nutrition_label_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecipeNutritionLabelImageError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recipe_nutrition_label_widget`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecipeNutritionLabelWidgetError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recipe_taste_by_id_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecipeTasteByIdImageError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_recipes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRecipesError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_recipes_by_ingredients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRecipesByIngredientsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_recipes_by_nutrients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRecipesByNutrientsError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`summarize_recipe`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SummarizeRecipeError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_equipment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeEquipmentError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_price_breakdown`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizePriceBreakdownError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_recipe_equipment_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeRecipeEquipmentByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_recipe_ingredients_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeRecipeIngredientsByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_recipe_nutrition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeRecipeNutritionError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_recipe_nutrition_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeRecipeNutritionByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_recipe_price_breakdown_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeRecipePriceBreakdownByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_recipe_taste`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeRecipeTasteError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`visualize_recipe_taste_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VisualizeRecipeTasteByIdError {
    Status401(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}


/// Parse a recipe search query to find out its intention.
pub async fn analyze_a_recipe_search_query(configuration: &configuration::Configuration, q: &str) -> Result<models::AnalyzeARecipeSearchQuery200Response, Error<AnalyzeARecipeSearchQueryError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/queries/analyze", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("q", &q.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AnalyzeARecipeSearchQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to break down instructions into atomic steps. Furthermore, each step will contain the ingredients and equipment required. Additionally, all ingredients and equipment from the recipe's instructions will be extracted independently of the step they're used in.
pub async fn analyze_recipe_instructions(configuration: &configuration::Configuration, instructions: &str) -> Result<models::AnalyzeRecipeInstructions200Response, Error<AnalyzeRecipeInstructionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/analyzeInstructions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("instructions", instructions.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AnalyzeRecipeInstructionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Autocomplete a partial input to suggest possible recipe names.
pub async fn autocomplete_recipe_search(configuration: &configuration::Configuration, query: Option<&str>, number: Option<i32>) -> Result<Vec<models::AutocompleteRecipeSearch200ResponseInner>, Error<AutocompleteRecipeSearchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/autocomplete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = number {
        local_var_req_builder = local_var_req_builder.query(&[("number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AutocompleteRecipeSearchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Classify the recipe's cuisine.
pub async fn classify_cuisine(configuration: &configuration::Configuration, title: &str, ingredient_list: &str, language: Option<&str>) -> Result<models::ClassifyCuisine200Response, Error<ClassifyCuisineError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/cuisine", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("title", title.to_string());
    local_var_form_params.insert("ingredientList", ingredient_list.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ClassifyCuisineError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the glycemic index for a list of ingredients and compute the individual and total glycemic load.
pub async fn compute_glycemic_load(configuration: &configuration::Configuration, compute_glycemic_load_request: models::ComputeGlycemicLoadRequest, language: Option<&str>) -> Result<models::ComputeGlycemicLoad200Response, Error<ComputeGlycemicLoadError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/food/ingredients/glycemicLoad", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&compute_glycemic_load_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ComputeGlycemicLoadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Convert amounts like \"2 cups of flour to grams\".
pub async fn convert_amounts(configuration: &configuration::Configuration, ingredient_name: &str, source_amount: f64, source_unit: &str, target_unit: &str) -> Result<models::ConvertAmounts200Response, Error<ConvertAmountsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/convert", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ingredientName", &ingredient_name.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("sourceAmount", &source_amount.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("sourceUnit", &source_unit.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("targetUnit", &target_unit.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConvertAmountsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Generate a recipe card for a recipe.
pub async fn create_recipe_card(configuration: &configuration::Configuration, title: &str, ingredients: &str, instructions: &str, ready_in_minutes: f64, servings: f64, mask: &str, background_image: &str, image: Option<std::path::PathBuf>, image_url: Option<&str>, author: Option<&str>, background_color: Option<&str>, font_color: Option<&str>, source: Option<&str>) -> Result<models::CreateRecipeCard200Response, Error<CreateRecipeCardError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/visualizeRecipe", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form = reqwest::multipart::Form::new();
    local_var_form = local_var_form.text("title", title.to_string());
    local_var_form = local_var_form.text("ingredients", ingredients.to_string());
    local_var_form = local_var_form.text("instructions", instructions.to_string());
    local_var_form = local_var_form.text("readyInMinutes", ready_in_minutes.to_string());
    local_var_form = local_var_form.text("servings", servings.to_string());
    local_var_form = local_var_form.text("mask", mask.to_string());
    local_var_form = local_var_form.text("backgroundImage", background_image.to_string());
    // TODO: support file upload for 'image' parameter
    if let Some(local_var_param_value) = image_url {
        local_var_form = local_var_form.text("imageUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = author {
        local_var_form = local_var_form.text("author", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = background_color {
        local_var_form = local_var_form.text("backgroundColor", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = font_color {
        local_var_form = local_var_form.text("fontColor", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = source {
        local_var_form = local_var_form.text("source", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateRecipeCardError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's equipment list as an image.
pub async fn equipment_by_id_image(configuration: &configuration::Configuration, id: f64) -> Result<std::path::PathBuf, Error<EquipmentByIdImageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/equipmentWidget.png", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EquipmentByIdImageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint lets you extract recipe data such as title, ingredients, and instructions from any properly formatted Website.
pub async fn extract_recipe_from_website(configuration: &configuration::Configuration, url: &str, force_extraction: Option<bool>, analyze: Option<bool>, include_nutrition: Option<bool>, include_taste: Option<bool>) -> Result<models::GetRecipeInformation200Response, Error<ExtractRecipeFromWebsiteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/extract", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("url", &url.to_string())]);
    if let Some(ref local_var_str) = force_extraction {
        local_var_req_builder = local_var_req_builder.query(&[("forceExtraction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = analyze {
        local_var_req_builder = local_var_req_builder.query(&[("analyze", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_nutrition {
        local_var_req_builder = local_var_req_builder.query(&[("includeNutrition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_taste {
        local_var_req_builder = local_var_req_builder.query(&[("includeTaste", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ExtractRecipeFromWebsiteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get an analyzed breakdown of a recipe's instructions. Each step is enriched with the ingredients and equipment required.
pub async fn get_analyzed_recipe_instructions(configuration: &configuration::Configuration, id: i32, step_breakdown: Option<bool>) -> Result<models::GetAnalyzedRecipeInstructions200Response, Error<GetAnalyzedRecipeInstructionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/analyzedInstructions", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = step_breakdown {
        local_var_req_builder = local_var_req_builder.query(&[("stepBreakdown", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAnalyzedRecipeInstructionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Find random (popular) recipes. If you need to filter recipes by diet, nutrition etc. you might want to consider using the complex recipe search endpoint and set the sort request parameter to random.
pub async fn get_random_recipes(configuration: &configuration::Configuration, limit_license: Option<bool>, include_nutrition: Option<bool>, include_tags: Option<&str>, exclude_tags: Option<&str>, number: Option<i32>) -> Result<models::GetRandomRecipes200Response, Error<GetRandomRecipesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/random", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit_license {
        local_var_req_builder = local_var_req_builder.query(&[("limitLicense", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_nutrition {
        local_var_req_builder = local_var_req_builder.query(&[("includeNutrition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_tags {
        local_var_req_builder = local_var_req_builder.query(&[("include-tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_tags {
        local_var_req_builder = local_var_req_builder.query(&[("exclude-tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = number {
        local_var_req_builder = local_var_req_builder.query(&[("number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRandomRecipesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's equipment list.
pub async fn get_recipe_equipment_by_id(configuration: &configuration::Configuration, id: i32) -> Result<models::GetRecipeEquipmentById200Response, Error<GetRecipeEquipmentByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/equipmentWidget.json", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRecipeEquipmentByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Use a recipe id to get full information about a recipe, such as ingredients, nutrition, diet and allergen information, etc.
pub async fn get_recipe_information(configuration: &configuration::Configuration, id: i32, include_nutrition: Option<bool>) -> Result<models::GetRecipeInformation200Response, Error<GetRecipeInformationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/information", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_nutrition {
        local_var_req_builder = local_var_req_builder.query(&[("includeNutrition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRecipeInformationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get information about multiple recipes at once. This is equivalent to calling the Get Recipe Information endpoint multiple times, but faster.
pub async fn get_recipe_information_bulk(configuration: &configuration::Configuration, ids: &str, include_nutrition: Option<bool>) -> Result<Vec<models::GetRecipeInformationBulk200ResponseInner>, Error<GetRecipeInformationBulkError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/informationBulk", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ids", &ids.to_string())]);
    if let Some(ref local_var_str) = include_nutrition {
        local_var_req_builder = local_var_req_builder.query(&[("includeNutrition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRecipeInformationBulkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's ingredient list.
pub async fn get_recipe_ingredients_by_id(configuration: &configuration::Configuration, id: i32) -> Result<models::GetRecipeIngredientsById200Response, Error<GetRecipeIngredientsByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/ingredientWidget.json", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRecipeIngredientsByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's nutrition data.
pub async fn get_recipe_nutrition_widget_by_id(configuration: &configuration::Configuration, id: i32) -> Result<models::GetRecipeNutritionWidgetById200Response, Error<GetRecipeNutritionWidgetByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/nutritionWidget.json", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRecipeNutritionWidgetByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's price breakdown data.
pub async fn get_recipe_price_breakdown_by_id(configuration: &configuration::Configuration, id: i32) -> Result<models::GetRecipePriceBreakdownById200Response, Error<GetRecipePriceBreakdownByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/priceBreakdownWidget.json", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRecipePriceBreakdownByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
pub async fn get_recipe_taste_by_id(configuration: &configuration::Configuration, id: i32, normalize: Option<bool>) -> Result<models::GetRecipeTasteById200Response, Error<GetRecipeTasteByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/tasteWidget.json", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = normalize {
        local_var_req_builder = local_var_req_builder.query(&[("normalize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRecipeTasteByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Find recipes which are similar to the given one.
pub async fn get_similar_recipes(configuration: &configuration::Configuration, id: i32, number: Option<i32>, limit_license: Option<bool>) -> Result<Vec<models::GetSimilarRecipes200ResponseInner>, Error<GetSimilarRecipesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/similar", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = number {
        local_var_req_builder = local_var_req_builder.query(&[("number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit_license {
        local_var_req_builder = local_var_req_builder.query(&[("limitLicense", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSimilarRecipesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Estimate the macronutrients of a dish based on its title.
pub async fn guess_nutrition_by_dish_name(configuration: &configuration::Configuration, title: &str) -> Result<models::GuessNutritionByDishName200Response, Error<GuessNutritionByDishNameError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/guessNutrition", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("title", &title.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GuessNutritionByDishNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Extract an ingredient from plain text.
pub async fn parse_ingredients(configuration: &configuration::Configuration, ingredient_list: &str, servings: f64, language: Option<&str>, include_nutrition: Option<bool>) -> Result<Vec<models::ParseIngredients200ResponseInner>, Error<ParseIngredientsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/parseIngredients", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ingredientList", ingredient_list.to_string());
    local_var_form_params.insert("servings", servings.to_string());
    if let Some(local_var_param_value) = include_nutrition {
        local_var_form_params.insert("includeNutrition", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ParseIngredientsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's price breakdown.
pub async fn price_breakdown_by_id_image(configuration: &configuration::Configuration, id: f64) -> Result<std::path::PathBuf, Error<PriceBreakdownByIdImageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/priceBreakdownWidget.png", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PriceBreakdownByIdImageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Answer a nutrition related natural language question.
pub async fn quick_answer(configuration: &configuration::Configuration, q: &str) -> Result<models::QuickAnswer200Response, Error<QuickAnswerError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/quickAnswer", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("q", &q.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<QuickAnswerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's nutritional information as an image.
pub async fn recipe_nutrition_by_id_image(configuration: &configuration::Configuration, id: f64) -> Result<std::path::PathBuf, Error<RecipeNutritionByIdImageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/nutritionWidget.png", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RecipeNutritionByIdImageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's nutrition label as an image.
pub async fn recipe_nutrition_label_image(configuration: &configuration::Configuration, id: f64, show_optional_nutrients: Option<bool>, show_zero_values: Option<bool>, show_ingredients: Option<bool>) -> Result<std::path::PathBuf, Error<RecipeNutritionLabelImageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/nutritionLabel.png", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = show_optional_nutrients {
        local_var_req_builder = local_var_req_builder.query(&[("showOptionalNutrients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = show_zero_values {
        local_var_req_builder = local_var_req_builder.query(&[("showZeroValues", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = show_ingredients {
        local_var_req_builder = local_var_req_builder.query(&[("showIngredients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RecipeNutritionLabelImageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's nutrition label as an HTML widget.
pub async fn recipe_nutrition_label_widget(configuration: &configuration::Configuration, id: f64, default_css: Option<bool>, show_optional_nutrients: Option<bool>, show_zero_values: Option<bool>, show_ingredients: Option<bool>) -> Result<String, Error<RecipeNutritionLabelWidgetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/nutritionLabel", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = default_css {
        local_var_req_builder = local_var_req_builder.query(&[("defaultCss", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = show_optional_nutrients {
        local_var_req_builder = local_var_req_builder.query(&[("showOptionalNutrients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = show_zero_values {
        local_var_req_builder = local_var_req_builder.query(&[("showZeroValues", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = show_ingredients {
        local_var_req_builder = local_var_req_builder.query(&[("showIngredients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RecipeNutritionLabelWidgetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's taste as an image. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
pub async fn recipe_taste_by_id_image(configuration: &configuration::Configuration, id: f64, normalize: Option<bool>, rgb: Option<&str>) -> Result<std::path::PathBuf, Error<RecipeTasteByIdImageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/tasteWidget.png", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = normalize {
        local_var_req_builder = local_var_req_builder.query(&[("normalize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rgb {
        local_var_req_builder = local_var_req_builder.query(&[("rgb", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RecipeTasteByIdImageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search through hundreds of thousands of recipes using advanced filtering and ranking. NOTE: This method combines searching by query, by ingredients, and by nutrients into one endpoint.
pub async fn search_recipes(configuration: &configuration::Configuration, query: Option<&str>, cuisine: Option<&str>, exclude_cuisine: Option<&str>, diet: Option<&str>, intolerances: Option<&str>, equipment: Option<&str>, include_ingredients: Option<&str>, exclude_ingredients: Option<&str>, r#type: Option<&str>, instructions_required: Option<bool>, fill_ingredients: Option<bool>, add_recipe_information: Option<bool>, add_recipe_nutrition: Option<bool>, author: Option<&str>, tags: Option<&str>, recipe_box_id: Option<f64>, title_match: Option<&str>, max_ready_time: Option<f64>, min_servings: Option<f64>, max_servings: Option<f64>, ignore_pantry: Option<bool>, sort: Option<&str>, sort_direction: Option<&str>, min_carbs: Option<f64>, max_carbs: Option<f64>, min_protein: Option<f64>, max_protein: Option<f64>, min_calories: Option<f64>, max_calories: Option<f64>, min_fat: Option<f64>, max_fat: Option<f64>, min_alcohol: Option<f64>, max_alcohol: Option<f64>, min_caffeine: Option<f64>, max_caffeine: Option<f64>, min_copper: Option<f64>, max_copper: Option<f64>, min_calcium: Option<f64>, max_calcium: Option<f64>, min_choline: Option<f64>, max_choline: Option<f64>, min_cholesterol: Option<f64>, max_cholesterol: Option<f64>, min_fluoride: Option<f64>, max_fluoride: Option<f64>, min_saturated_fat: Option<f64>, max_saturated_fat: Option<f64>, min_vitamin_a: Option<f64>, max_vitamin_a: Option<f64>, min_vitamin_c: Option<f64>, max_vitamin_c: Option<f64>, min_vitamin_d: Option<f64>, max_vitamin_d: Option<f64>, min_vitamin_e: Option<f64>, max_vitamin_e: Option<f64>, min_vitamin_k: Option<f64>, max_vitamin_k: Option<f64>, min_vitamin_b1: Option<f64>, max_vitamin_b1: Option<f64>, min_vitamin_b2: Option<f64>, max_vitamin_b2: Option<f64>, min_vitamin_b5: Option<f64>, max_vitamin_b5: Option<f64>, min_vitamin_b3: Option<f64>, max_vitamin_b3: Option<f64>, min_vitamin_b6: Option<f64>, max_vitamin_b6: Option<f64>, min_vitamin_b12: Option<f64>, max_vitamin_b12: Option<f64>, min_fiber: Option<f64>, max_fiber: Option<f64>, min_folate: Option<f64>, max_folate: Option<f64>, min_folic_acid: Option<f64>, max_folic_acid: Option<f64>, min_iodine: Option<f64>, max_iodine: Option<f64>, min_iron: Option<f64>, max_iron: Option<f64>, min_magnesium: Option<f64>, max_magnesium: Option<f64>, min_manganese: Option<f64>, max_manganese: Option<f64>, min_phosphorus: Option<f64>, max_phosphorus: Option<f64>, min_potassium: Option<f64>, max_potassium: Option<f64>, min_selenium: Option<f64>, max_selenium: Option<f64>, min_sodium: Option<f64>, max_sodium: Option<f64>, min_sugar: Option<f64>, max_sugar: Option<f64>, min_zinc: Option<f64>, max_zinc: Option<f64>, offset: Option<i32>, number: Option<i32>, limit_license: Option<bool>) -> Result<models::SearchRecipes200Response, Error<SearchRecipesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/complexSearch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cuisine {
        local_var_req_builder = local_var_req_builder.query(&[("cuisine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_cuisine {
        local_var_req_builder = local_var_req_builder.query(&[("excludeCuisine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = diet {
        local_var_req_builder = local_var_req_builder.query(&[("diet", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = intolerances {
        local_var_req_builder = local_var_req_builder.query(&[("intolerances", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = equipment {
        local_var_req_builder = local_var_req_builder.query(&[("equipment", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_ingredients {
        local_var_req_builder = local_var_req_builder.query(&[("includeIngredients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_ingredients {
        local_var_req_builder = local_var_req_builder.query(&[("excludeIngredients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = instructions_required {
        local_var_req_builder = local_var_req_builder.query(&[("instructionsRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fill_ingredients {
        local_var_req_builder = local_var_req_builder.query(&[("fillIngredients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = add_recipe_information {
        local_var_req_builder = local_var_req_builder.query(&[("addRecipeInformation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = add_recipe_nutrition {
        local_var_req_builder = local_var_req_builder.query(&[("addRecipeNutrition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = author {
        local_var_req_builder = local_var_req_builder.query(&[("author", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = local_var_req_builder.query(&[("tags", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = recipe_box_id {
        local_var_req_builder = local_var_req_builder.query(&[("recipeBoxId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = title_match {
        local_var_req_builder = local_var_req_builder.query(&[("titleMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_ready_time {
        local_var_req_builder = local_var_req_builder.query(&[("maxReadyTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_servings {
        local_var_req_builder = local_var_req_builder.query(&[("minServings", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_servings {
        local_var_req_builder = local_var_req_builder.query(&[("maxServings", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ignore_pantry {
        local_var_req_builder = local_var_req_builder.query(&[("ignorePantry", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_direction {
        local_var_req_builder = local_var_req_builder.query(&[("sortDirection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_carbs {
        local_var_req_builder = local_var_req_builder.query(&[("minCarbs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_carbs {
        local_var_req_builder = local_var_req_builder.query(&[("maxCarbs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_protein {
        local_var_req_builder = local_var_req_builder.query(&[("minProtein", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_protein {
        local_var_req_builder = local_var_req_builder.query(&[("maxProtein", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_calories {
        local_var_req_builder = local_var_req_builder.query(&[("minCalories", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_calories {
        local_var_req_builder = local_var_req_builder.query(&[("maxCalories", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_fat {
        local_var_req_builder = local_var_req_builder.query(&[("minFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_fat {
        local_var_req_builder = local_var_req_builder.query(&[("maxFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_alcohol {
        local_var_req_builder = local_var_req_builder.query(&[("minAlcohol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_alcohol {
        local_var_req_builder = local_var_req_builder.query(&[("maxAlcohol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_caffeine {
        local_var_req_builder = local_var_req_builder.query(&[("minCaffeine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_caffeine {
        local_var_req_builder = local_var_req_builder.query(&[("maxCaffeine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_copper {
        local_var_req_builder = local_var_req_builder.query(&[("minCopper", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_copper {
        local_var_req_builder = local_var_req_builder.query(&[("maxCopper", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_calcium {
        local_var_req_builder = local_var_req_builder.query(&[("minCalcium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_calcium {
        local_var_req_builder = local_var_req_builder.query(&[("maxCalcium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_choline {
        local_var_req_builder = local_var_req_builder.query(&[("minCholine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_choline {
        local_var_req_builder = local_var_req_builder.query(&[("maxCholine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_cholesterol {
        local_var_req_builder = local_var_req_builder.query(&[("minCholesterol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_cholesterol {
        local_var_req_builder = local_var_req_builder.query(&[("maxCholesterol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_fluoride {
        local_var_req_builder = local_var_req_builder.query(&[("minFluoride", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_fluoride {
        local_var_req_builder = local_var_req_builder.query(&[("maxFluoride", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_saturated_fat {
        local_var_req_builder = local_var_req_builder.query(&[("minSaturatedFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_saturated_fat {
        local_var_req_builder = local_var_req_builder.query(&[("maxSaturatedFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_a {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminA", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_a {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminA", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_c {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminC", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_c {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminC", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_d {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminD", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_d {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminD", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_e {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminE", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_e {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminE", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_k {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminK", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_k {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminK", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b1 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB1", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b1 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB1", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b2 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB2", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b2 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB2", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b5 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB5", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b5 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB5", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b3 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB3", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b3 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB3", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b6 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB6", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b6 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB6", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b12 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB12", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b12 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB12", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_fiber {
        local_var_req_builder = local_var_req_builder.query(&[("minFiber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_fiber {
        local_var_req_builder = local_var_req_builder.query(&[("maxFiber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_folate {
        local_var_req_builder = local_var_req_builder.query(&[("minFolate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_folate {
        local_var_req_builder = local_var_req_builder.query(&[("maxFolate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_folic_acid {
        local_var_req_builder = local_var_req_builder.query(&[("minFolicAcid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_folic_acid {
        local_var_req_builder = local_var_req_builder.query(&[("maxFolicAcid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_iodine {
        local_var_req_builder = local_var_req_builder.query(&[("minIodine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_iodine {
        local_var_req_builder = local_var_req_builder.query(&[("maxIodine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_iron {
        local_var_req_builder = local_var_req_builder.query(&[("minIron", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_iron {
        local_var_req_builder = local_var_req_builder.query(&[("maxIron", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_magnesium {
        local_var_req_builder = local_var_req_builder.query(&[("minMagnesium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_magnesium {
        local_var_req_builder = local_var_req_builder.query(&[("maxMagnesium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_manganese {
        local_var_req_builder = local_var_req_builder.query(&[("minManganese", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_manganese {
        local_var_req_builder = local_var_req_builder.query(&[("maxManganese", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_phosphorus {
        local_var_req_builder = local_var_req_builder.query(&[("minPhosphorus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_phosphorus {
        local_var_req_builder = local_var_req_builder.query(&[("maxPhosphorus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_potassium {
        local_var_req_builder = local_var_req_builder.query(&[("minPotassium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_potassium {
        local_var_req_builder = local_var_req_builder.query(&[("maxPotassium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_selenium {
        local_var_req_builder = local_var_req_builder.query(&[("minSelenium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_selenium {
        local_var_req_builder = local_var_req_builder.query(&[("maxSelenium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_sodium {
        local_var_req_builder = local_var_req_builder.query(&[("minSodium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_sodium {
        local_var_req_builder = local_var_req_builder.query(&[("maxSodium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_sugar {
        local_var_req_builder = local_var_req_builder.query(&[("minSugar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_sugar {
        local_var_req_builder = local_var_req_builder.query(&[("maxSugar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_zinc {
        local_var_req_builder = local_var_req_builder.query(&[("minZinc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_zinc {
        local_var_req_builder = local_var_req_builder.query(&[("maxZinc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = number {
        local_var_req_builder = local_var_req_builder.query(&[("number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit_license {
        local_var_req_builder = local_var_req_builder.query(&[("limitLicense", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SearchRecipesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don't currently have (post shopping).         
pub async fn search_recipes_by_ingredients(configuration: &configuration::Configuration, ingredients: Option<&str>, number: Option<i32>, limit_license: Option<bool>, ranking: Option<f64>, ignore_pantry: Option<bool>) -> Result<Vec<models::SearchRecipesByIngredients200ResponseInner>, Error<SearchRecipesByIngredientsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/findByIngredients", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ingredients {
        local_var_req_builder = local_var_req_builder.query(&[("ingredients", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = number {
        local_var_req_builder = local_var_req_builder.query(&[("number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit_license {
        local_var_req_builder = local_var_req_builder.query(&[("limitLicense", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ranking {
        local_var_req_builder = local_var_req_builder.query(&[("ranking", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ignore_pantry {
        local_var_req_builder = local_var_req_builder.query(&[("ignorePantry", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SearchRecipesByIngredientsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Find a set of recipes that adhere to the given nutritional limits. You may set limits for macronutrients (calories, protein, fat, and carbohydrate) and/or many micronutrients.
pub async fn search_recipes_by_nutrients(configuration: &configuration::Configuration, min_carbs: Option<f64>, max_carbs: Option<f64>, min_protein: Option<f64>, max_protein: Option<f64>, min_calories: Option<f64>, max_calories: Option<f64>, min_fat: Option<f64>, max_fat: Option<f64>, min_alcohol: Option<f64>, max_alcohol: Option<f64>, min_caffeine: Option<f64>, max_caffeine: Option<f64>, min_copper: Option<f64>, max_copper: Option<f64>, min_calcium: Option<f64>, max_calcium: Option<f64>, min_choline: Option<f64>, max_choline: Option<f64>, min_cholesterol: Option<f64>, max_cholesterol: Option<f64>, min_fluoride: Option<f64>, max_fluoride: Option<f64>, min_saturated_fat: Option<f64>, max_saturated_fat: Option<f64>, min_vitamin_a: Option<f64>, max_vitamin_a: Option<f64>, min_vitamin_c: Option<f64>, max_vitamin_c: Option<f64>, min_vitamin_d: Option<f64>, max_vitamin_d: Option<f64>, min_vitamin_e: Option<f64>, max_vitamin_e: Option<f64>, min_vitamin_k: Option<f64>, max_vitamin_k: Option<f64>, min_vitamin_b1: Option<f64>, max_vitamin_b1: Option<f64>, min_vitamin_b2: Option<f64>, max_vitamin_b2: Option<f64>, min_vitamin_b5: Option<f64>, max_vitamin_b5: Option<f64>, min_vitamin_b3: Option<f64>, max_vitamin_b3: Option<f64>, min_vitamin_b6: Option<f64>, max_vitamin_b6: Option<f64>, min_vitamin_b12: Option<f64>, max_vitamin_b12: Option<f64>, min_fiber: Option<f64>, max_fiber: Option<f64>, min_folate: Option<f64>, max_folate: Option<f64>, min_folic_acid: Option<f64>, max_folic_acid: Option<f64>, min_iodine: Option<f64>, max_iodine: Option<f64>, min_iron: Option<f64>, max_iron: Option<f64>, min_magnesium: Option<f64>, max_magnesium: Option<f64>, min_manganese: Option<f64>, max_manganese: Option<f64>, min_phosphorus: Option<f64>, max_phosphorus: Option<f64>, min_potassium: Option<f64>, max_potassium: Option<f64>, min_selenium: Option<f64>, max_selenium: Option<f64>, min_sodium: Option<f64>, max_sodium: Option<f64>, min_sugar: Option<f64>, max_sugar: Option<f64>, min_zinc: Option<f64>, max_zinc: Option<f64>, offset: Option<i32>, number: Option<i32>, random: Option<bool>, limit_license: Option<bool>) -> Result<Vec<models::SearchRecipesByNutrients200ResponseInner>, Error<SearchRecipesByNutrientsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/findByNutrients", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_carbs {
        local_var_req_builder = local_var_req_builder.query(&[("minCarbs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_carbs {
        local_var_req_builder = local_var_req_builder.query(&[("maxCarbs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_protein {
        local_var_req_builder = local_var_req_builder.query(&[("minProtein", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_protein {
        local_var_req_builder = local_var_req_builder.query(&[("maxProtein", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_calories {
        local_var_req_builder = local_var_req_builder.query(&[("minCalories", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_calories {
        local_var_req_builder = local_var_req_builder.query(&[("maxCalories", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_fat {
        local_var_req_builder = local_var_req_builder.query(&[("minFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_fat {
        local_var_req_builder = local_var_req_builder.query(&[("maxFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_alcohol {
        local_var_req_builder = local_var_req_builder.query(&[("minAlcohol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_alcohol {
        local_var_req_builder = local_var_req_builder.query(&[("maxAlcohol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_caffeine {
        local_var_req_builder = local_var_req_builder.query(&[("minCaffeine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_caffeine {
        local_var_req_builder = local_var_req_builder.query(&[("maxCaffeine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_copper {
        local_var_req_builder = local_var_req_builder.query(&[("minCopper", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_copper {
        local_var_req_builder = local_var_req_builder.query(&[("maxCopper", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_calcium {
        local_var_req_builder = local_var_req_builder.query(&[("minCalcium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_calcium {
        local_var_req_builder = local_var_req_builder.query(&[("maxCalcium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_choline {
        local_var_req_builder = local_var_req_builder.query(&[("minCholine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_choline {
        local_var_req_builder = local_var_req_builder.query(&[("maxCholine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_cholesterol {
        local_var_req_builder = local_var_req_builder.query(&[("minCholesterol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_cholesterol {
        local_var_req_builder = local_var_req_builder.query(&[("maxCholesterol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_fluoride {
        local_var_req_builder = local_var_req_builder.query(&[("minFluoride", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_fluoride {
        local_var_req_builder = local_var_req_builder.query(&[("maxFluoride", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_saturated_fat {
        local_var_req_builder = local_var_req_builder.query(&[("minSaturatedFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_saturated_fat {
        local_var_req_builder = local_var_req_builder.query(&[("maxSaturatedFat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_a {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminA", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_a {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminA", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_c {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminC", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_c {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminC", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_d {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminD", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_d {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminD", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_e {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminE", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_e {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminE", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_k {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminK", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_k {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminK", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b1 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB1", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b1 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB1", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b2 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB2", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b2 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB2", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b5 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB5", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b5 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB5", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b3 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB3", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b3 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB3", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b6 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB6", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b6 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB6", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_vitamin_b12 {
        local_var_req_builder = local_var_req_builder.query(&[("minVitaminB12", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_vitamin_b12 {
        local_var_req_builder = local_var_req_builder.query(&[("maxVitaminB12", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_fiber {
        local_var_req_builder = local_var_req_builder.query(&[("minFiber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_fiber {
        local_var_req_builder = local_var_req_builder.query(&[("maxFiber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_folate {
        local_var_req_builder = local_var_req_builder.query(&[("minFolate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_folate {
        local_var_req_builder = local_var_req_builder.query(&[("maxFolate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_folic_acid {
        local_var_req_builder = local_var_req_builder.query(&[("minFolicAcid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_folic_acid {
        local_var_req_builder = local_var_req_builder.query(&[("maxFolicAcid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_iodine {
        local_var_req_builder = local_var_req_builder.query(&[("minIodine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_iodine {
        local_var_req_builder = local_var_req_builder.query(&[("maxIodine", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_iron {
        local_var_req_builder = local_var_req_builder.query(&[("minIron", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_iron {
        local_var_req_builder = local_var_req_builder.query(&[("maxIron", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_magnesium {
        local_var_req_builder = local_var_req_builder.query(&[("minMagnesium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_magnesium {
        local_var_req_builder = local_var_req_builder.query(&[("maxMagnesium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_manganese {
        local_var_req_builder = local_var_req_builder.query(&[("minManganese", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_manganese {
        local_var_req_builder = local_var_req_builder.query(&[("maxManganese", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_phosphorus {
        local_var_req_builder = local_var_req_builder.query(&[("minPhosphorus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_phosphorus {
        local_var_req_builder = local_var_req_builder.query(&[("maxPhosphorus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_potassium {
        local_var_req_builder = local_var_req_builder.query(&[("minPotassium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_potassium {
        local_var_req_builder = local_var_req_builder.query(&[("maxPotassium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_selenium {
        local_var_req_builder = local_var_req_builder.query(&[("minSelenium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_selenium {
        local_var_req_builder = local_var_req_builder.query(&[("maxSelenium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_sodium {
        local_var_req_builder = local_var_req_builder.query(&[("minSodium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_sodium {
        local_var_req_builder = local_var_req_builder.query(&[("maxSodium", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_sugar {
        local_var_req_builder = local_var_req_builder.query(&[("minSugar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_sugar {
        local_var_req_builder = local_var_req_builder.query(&[("maxSugar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_zinc {
        local_var_req_builder = local_var_req_builder.query(&[("minZinc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_zinc {
        local_var_req_builder = local_var_req_builder.query(&[("maxZinc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = number {
        local_var_req_builder = local_var_req_builder.query(&[("number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = random {
        local_var_req_builder = local_var_req_builder.query(&[("random", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit_license {
        local_var_req_builder = local_var_req_builder.query(&[("limitLicense", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SearchRecipesByNutrientsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Automatically generate a short description that summarizes key information about the recipe.
pub async fn summarize_recipe(configuration: &configuration::Configuration, id: i32) -> Result<models::SummarizeRecipe200Response, Error<SummarizeRecipeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/summary", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SummarizeRecipeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize the equipment used to make a recipe.
pub async fn visualize_equipment(configuration: &configuration::Configuration, instructions: &str, view: Option<&str>, default_css: Option<bool>, show_backlink: Option<bool>) -> Result<String, Error<VisualizeEquipmentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/visualizeEquipment", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("instructions", instructions.to_string());
    if let Some(local_var_param_value) = view {
        local_var_form_params.insert("view", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_css {
        local_var_form_params.insert("defaultCss", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = show_backlink {
        local_var_form_params.insert("showBacklink", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeEquipmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize the price breakdown of a recipe.
pub async fn visualize_price_breakdown(configuration: &configuration::Configuration, ingredient_list: &str, servings: f64, language: Option<&str>, mode: Option<f64>, default_css: Option<bool>, show_backlink: Option<bool>) -> Result<String, Error<VisualizePriceBreakdownError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/visualizePriceEstimator", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ingredientList", ingredient_list.to_string());
    local_var_form_params.insert("servings", servings.to_string());
    if let Some(local_var_param_value) = mode {
        local_var_form_params.insert("mode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_css {
        local_var_form_params.insert("defaultCss", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = show_backlink {
        local_var_form_params.insert("showBacklink", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizePriceBreakdownError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's equipment list.
pub async fn visualize_recipe_equipment_by_id(configuration: &configuration::Configuration, id: i32, default_css: Option<bool>) -> Result<String, Error<VisualizeRecipeEquipmentByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/equipmentWidget", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = default_css {
        local_var_req_builder = local_var_req_builder.query(&[("defaultCss", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeRecipeEquipmentByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's ingredient list.
pub async fn visualize_recipe_ingredients_by_id(configuration: &configuration::Configuration, id: i32, default_css: Option<bool>, measure: Option<&str>) -> Result<String, Error<VisualizeRecipeIngredientsByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/ingredientWidget", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = default_css {
        local_var_req_builder = local_var_req_builder.query(&[("defaultCss", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = measure {
        local_var_req_builder = local_var_req_builder.query(&[("measure", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeRecipeIngredientsByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's nutritional information as HTML including CSS.
pub async fn visualize_recipe_nutrition(configuration: &configuration::Configuration, ingredient_list: &str, servings: f64, language: Option<&str>, default_css: Option<bool>, show_backlink: Option<bool>) -> Result<String, Error<VisualizeRecipeNutritionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/visualizeNutrition", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ingredientList", ingredient_list.to_string());
    local_var_form_params.insert("servings", servings.to_string());
    if let Some(local_var_param_value) = default_css {
        local_var_form_params.insert("defaultCss", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = show_backlink {
        local_var_form_params.insert("showBacklink", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeRecipeNutritionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's nutritional information as HTML including CSS.
pub async fn visualize_recipe_nutrition_by_id(configuration: &configuration::Configuration, id: i32, default_css: Option<bool>) -> Result<String, Error<VisualizeRecipeNutritionByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/nutritionWidget", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = default_css {
        local_var_req_builder = local_var_req_builder.query(&[("defaultCss", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeRecipeNutritionByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's price breakdown.
pub async fn visualize_recipe_price_breakdown_by_id(configuration: &configuration::Configuration, id: i32, default_css: Option<bool>) -> Result<String, Error<VisualizeRecipePriceBreakdownByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/priceBreakdownWidget", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = default_css {
        local_var_req_builder = local_var_req_builder.query(&[("defaultCss", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeRecipePriceBreakdownByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Visualize a recipe's taste information as HTML including CSS. You can play around with that endpoint!
pub async fn visualize_recipe_taste(configuration: &configuration::Configuration, ingredient_list: &str, language: Option<&str>, normalize: Option<bool>, rgb: Option<&str>) -> Result<String, Error<VisualizeRecipeTasteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/visualizeTaste", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ingredientList", ingredient_list.to_string());
    if let Some(local_var_param_value) = normalize {
        local_var_form_params.insert("normalize", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = rgb {
        local_var_form_params.insert("rgb", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeRecipeTasteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a recipe's taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.
pub async fn visualize_recipe_taste_by_id(configuration: &configuration::Configuration, id: i32, normalize: Option<bool>, rgb: Option<&str>) -> Result<String, Error<VisualizeRecipeTasteByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recipes/{id}/tasteWidget", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = normalize {
        local_var_req_builder = local_var_req_builder.query(&[("normalize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rgb {
        local_var_req_builder = local_var_req_builder.query(&[("rgb", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VisualizeRecipeTasteByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

